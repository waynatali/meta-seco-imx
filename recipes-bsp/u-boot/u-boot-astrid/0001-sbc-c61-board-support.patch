diff --git a/arch/arm/mach-imx/imx8m/Kconfig b/arch/arm/mach-imx/imx8m/Kconfig
index fae7049995..e6e82a0be0 100644
--- a/arch/arm/mach-imx/imx8m/Kconfig
+++ b/arch/arm/mach-imx/imx8m/Kconfig
@@ -203,6 +203,14 @@ config TARGET_IMX8MP_RSB3720A1_6G
 	select IMX8MP
 	select SUPPORT_SPL
 	select IMX8M_LPDDR4
+
+config TARGET_SECO_IMX8MM_C61
+	bool "imx8mm LPDDR4 EVK board"
+	select BINMAN
+	select IMX8MM
+	select SUPPORT_SPL
+	select IMX8M_LPDDR4
+
 endchoice
 
 source "board/advantech/imx8mp_rsb3720a1/Kconfig"
@@ -225,5 +233,7 @@ source "board/technexion/pico-imx8mq/Kconfig"
 source "board/variscite/imx8mn_var_som/Kconfig"
 source "board/toradex/verdin-imx8mm/Kconfig"
 source "board/toradex/verdin-imx8mp/Kconfig"
+source "board/seco/seco_imx8mm_c61/Kconfig"
+
 
 endif
diff --git a/board/seco/seco_imx8mm_c61/Kconfig b/board/seco/seco_imx8mm_c61/Kconfig
new file mode 100644
index 0000000000..2f00c6a7bd
--- /dev/null
+++ b/board/seco/seco_imx8mm_c61/Kconfig
@@ -0,0 +1,22 @@
+if TARGET_SECO_IMX8MM_C61
+
+config SYS_BOARD
+	default "seco_imx8mm_c61"
+
+config SYS_VENDOR
+	default "seco"
+
+config SYS_CONFIG_NAME
+	default "seco_imx8mm_c61"
+
+config IMX_CONFIG
+	default "board/seco/seco_imx8mm_c61/imximage-8mm-lpddr4.cfg"
+
+config BL32_ENTRY_ADDR
+	hex "Entry point of the BL32 image"
+	default 0xbe000000
+
+config DRAM_BANKS_2
+	bool "Enable PHYS_SDRAM_2_SIZE for the board with 4Gb RAM"
+	default n
+endif
diff --git a/board/seco/seco_imx8mm_c61/Makefile b/board/seco/seco_imx8mm_c61/Makefile
new file mode 100644
index 0000000000..2c520205be
--- /dev/null
+++ b/board/seco/seco_imx8mm_c61/Makefile
@@ -0,0 +1,13 @@
+#
+# Copyright 2018 NXP
+#
+# SPDX-License-Identifier:      GPL-2.0+
+#
+
+obj-y += mmc.o
+obj-y += seco_imx8mm_c61.o
+ifdef CONFIG_SPL_BUILD
+obj-y += spl.o
+obj-$(CONFIG_IMX8M_LPDDR4) += lpddr4_timing.o
+endif
+obj-$(CONFIG_TARGET_SECO_IMX8MM_C61) += seco_imx8mm_c61_setup.o
diff --git a/board/seco/seco_imx8mm_c61/imximage-8mm-lpddr4.cfg b/board/seco/seco_imx8mm_c61/imximage-8mm-lpddr4.cfg
new file mode 100644
index 0000000000..f9ce7f89d7
--- /dev/null
+++ b/board/seco/seco_imx8mm_c61/imximage-8mm-lpddr4.cfg
@@ -0,0 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright 2021 NXP
+ */
+
+
+BOOT_FROM	sd
+LOADER		u-boot-spl-ddr.bin	0x7e1000
diff --git a/board/seco/seco_imx8mm_c61/lpddr4_timing.c b/board/seco/seco_imx8mm_c61/lpddr4_timing.c
new file mode 100644
index 0000000000..9078f8b644
--- /dev/null
+++ b/board/seco/seco_imx8mm_c61/lpddr4_timing.c
@@ -0,0 +1,1851 @@
+/*
+ * Copyright 2018 NXP
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Generated code from MX8M_DDR_tool
+ * Align with uboot-imx_v2018.03_4.14.78_1.0.0_ga
+ */
+
+#include <linux/kernel.h>
+#include <asm/arch/ddr.h>
+
+struct dram_cfg_param ddr_ddrc_cfg[] = {
+	/** Initialize DDRC registers **/
+	{0x3d400304,0x1},
+	{0x3d400030,0x1},
+	{0x3d400000,0xa1080020},
+	{0x3d400020,0x223},
+	{0x3d400024,0x3a980},
+	{0x3d400064,0x5b00d2},
+	{0x3d4000d0,0xc00305ba},
+	{0x3d4000d4,0x940000},
+	{0x3d4000dc,0xd4002d},
+	{0x3d4000e0,0x310000},
+	{0x3d4000e8,0x66004d},
+	{0x3d4000ec,0x16004d},
+	{0x3d400100,0x191e1920},
+	{0x3d400104,0x60630},
+	{0x3d40010c,0xb0b000},
+	{0x3d400110,0xe04080e},
+	{0x3d400114,0x2040c0c},
+	{0x3d400118,0x1010007},
+	{0x3d40011c,0x401},
+	{0x3d400130,0x20600},
+	{0x3d400134,0xc100002},
+	{0x3d400138,0xd8},
+	{0x3d400144,0x96004b},
+	{0x3d400180,0x2ee0017},
+	{0x3d400184,0x2605b8e},
+	{0x3d400188,0x0},
+	{0x3d400190,0x497820a},
+	{0x3d400194,0x80303},
+	{0x3d4001b4,0x170a},
+	{0x3d4001a0,0xe0400018},
+	{0x3d4001a4,0xdf00e4},
+	{0x3d4001a8,0x80000000},
+	{0x3d4001b0,0x11},
+	{0x3d4001c0,0x1},
+	{0x3d4001c4,0x0},
+	{0x3d4000f4,0xc99},
+	{0x3d400108,0x70e1617},
+	{0x3d400200,0x1f},
+	{0x3d40020c,0x0},
+	{0x3d400210,0x1f1f},
+	{0x3d400204,0x80808},
+	{0x3d400214,0x7070707},
+	{0x3d400218,0x7070707},
+	{0x3d400250,0x29001701},
+	{0x3d400254,0x2c},
+	{0x3d40025c,0x4000030},
+	{0x3d400264,0x900093e7},
+	{0x3d40026c,0x2005574},
+	{0x3d400400,0x111},
+	{0x3d400408,0x72ff},
+	{0x3d400494,0x2100e07},
+	{0x3d400498,0x620096},
+	{0x3d40049c,0x1100e07},
+	{0x3d4004a0,0xc8012c},
+	{0x3d402020,0x21},
+	{0x3d402024,0x7d00},
+	{0x3d402050,0x20d040},
+	{0x3d402064,0xc001c},
+	{0x3d4020dc,0x840000},
+	{0x3d4020e0,0x310000},
+	{0x3d4020e8,0x66004d},
+	{0x3d4020ec,0x16004d},
+	{0x3d402100,0xa040305},
+	{0x3d402104,0x30407},
+	{0x3d402108,0x203060b},
+	{0x3d40210c,0x505000},
+	{0x3d402110,0x2040202},
+	{0x3d402114,0x2030202},
+	{0x3d402118,0x1010004},
+	{0x3d40211c,0x301},
+	{0x3d402130,0x20300},
+	{0x3d402134,0xa100002},
+	{0x3d402138,0x1d},
+	{0x3d402144,0x14000a},
+	{0x3d402180,0x640004},
+	{0x3d402190,0x3818200},
+	{0x3d402194,0x80303},
+	{0x3d4021b4,0x100},
+	{0x3d4020f4,0xc99},
+	{0x3d403020,0x21},
+	{0x3d403024,0x1f40},
+	{0x3d403050,0x20d040},
+	{0x3d403064,0x30007},
+	{0x3d4030dc,0x840000},
+	{0x3d4030e0,0x310000},
+	{0x3d4030e8,0x66004d},
+	{0x3d4030ec,0x16004d},
+	{0x3d403100,0xa010102},
+	{0x3d403104,0x30404},
+	{0x3d403108,0x203060b},
+	{0x3d40310c,0x505000},
+	{0x3d403110,0x2040202},
+	{0x3d403114,0x2030202},
+	{0x3d403118,0x1010004},
+	{0x3d40311c,0x301},
+	{0x3d403130,0x20300},
+	{0x3d403134,0xa100002},
+	{0x3d403138,0x8},
+	{0x3d403144,0x50003},
+	{0x3d403180,0x190004},
+	{0x3d403190,0x3818200},
+	{0x3d403194,0x80303},
+	{0x3d4031b4,0x100},
+	{0x3d4030f4,0xc99},
+	{0x3d400028,0x0},
+};
+
+/* PHY Initialize Configuration */
+struct dram_cfg_param ddr_ddrphy_cfg[] = {
+	{0x100a0,0x0},
+	{0x100a1,0x1},
+	{0x100a2,0x2},
+	{0x100a3,0x3},
+	{0x100a4,0x4},
+	{0x100a5,0x5},
+	{0x100a6,0x6},
+	{0x100a7,0x7},
+	{0x110a0,0x0},
+	{0x110a1,0x1},
+	{0x110a2,0x3},
+	{0x110a3,0x4},
+	{0x110a4,0x5},
+	{0x110a5,0x2},
+	{0x110a6,0x7},
+	{0x110a7,0x6},
+	{0x120a0,0x0},
+	{0x120a1,0x1},
+	{0x120a2,0x3},
+	{0x120a3,0x2},
+	{0x120a4,0x5},
+	{0x120a5,0x4},
+	{0x120a6,0x7},
+	{0x120a7,0x6},
+	{0x130a0,0x0},
+	{0x130a1,0x1},
+	{0x130a2,0x2},
+	{0x130a3,0x3},
+	{0x130a4,0x4},
+	{0x130a5,0x5},
+	{0x130a6,0x6},
+	{0x130a7,0x7},
+	{0x1005f,0x1ff},
+	{0x1015f,0x1ff},
+	{0x1105f,0x1ff},
+	{0x1115f,0x1ff},
+	{0x1205f,0x1ff},
+	{0x1215f,0x1ff},
+	{0x1305f,0x1ff},
+	{0x1315f,0x1ff},
+	{0x11005f,0x1ff},
+	{0x11015f,0x1ff},
+	{0x11105f,0x1ff},
+	{0x11115f,0x1ff},
+	{0x11205f,0x1ff},
+	{0x11215f,0x1ff},
+	{0x11305f,0x1ff},
+	{0x11315f,0x1ff},
+	{0x21005f,0x1ff},
+	{0x21015f,0x1ff},
+	{0x21105f,0x1ff},
+	{0x21115f,0x1ff},
+	{0x21205f,0x1ff},
+	{0x21215f,0x1ff},
+	{0x21305f,0x1ff},
+	{0x21315f,0x1ff},
+	{0x55,0x1ff},
+	{0x1055,0x1ff},
+	{0x2055,0x1ff},
+	{0x3055,0x1ff},
+	{0x4055,0x1ff},
+	{0x5055,0x1ff},
+	{0x6055,0x1ff},
+	{0x7055,0x1ff},
+	{0x8055,0x1ff},
+	{0x9055,0x1ff},
+	{0x200c5,0x19},
+	{0x1200c5,0x7},
+	{0x2200c5,0x7},
+	{0x2002e,0x2},
+	{0x12002e,0x2},
+	{0x22002e,0x2},
+	{0x90204,0x0},
+	{0x190204,0x0},
+	{0x290204,0x0},
+	{0x20024,0x1ab},
+	{0x2003a,0x0},
+	{0x120024,0x1ab},
+	{0x2003a,0x0},
+	{0x220024,0x1ab},
+	{0x2003a,0x0},
+	{0x20056,0x3},
+	{0x120056,0xa},
+	{0x220056,0xa},
+	{0x1004d,0xe00},
+	{0x1014d,0xe00},
+	{0x1104d,0xe00},
+	{0x1114d,0xe00},
+	{0x1204d,0xe00},
+	{0x1214d,0xe00},
+	{0x1304d,0xe00},
+	{0x1314d,0xe00},
+	{0x11004d,0xe00},
+	{0x11014d,0xe00},
+	{0x11104d,0xe00},
+	{0x11114d,0xe00},
+	{0x11204d,0xe00},
+	{0x11214d,0xe00},
+	{0x11304d,0xe00},
+	{0x11314d,0xe00},
+	{0x21004d,0xe00},
+	{0x21014d,0xe00},
+	{0x21104d,0xe00},
+	{0x21114d,0xe00},
+	{0x21204d,0xe00},
+	{0x21214d,0xe00},
+	{0x21304d,0xe00},
+	{0x21314d,0xe00},
+	{0x10049,0xeba},
+	{0x10149,0xeba},
+	{0x11049,0xeba},
+	{0x11149,0xeba},
+	{0x12049,0xeba},
+	{0x12149,0xeba},
+	{0x13049,0xeba},
+	{0x13149,0xeba},
+	{0x110049,0xeba},
+	{0x110149,0xeba},
+	{0x111049,0xeba},
+	{0x111149,0xeba},
+	{0x112049,0xeba},
+	{0x112149,0xeba},
+	{0x113049,0xeba},
+	{0x113149,0xeba},
+	{0x210049,0xeba},
+	{0x210149,0xeba},
+	{0x211049,0xeba},
+	{0x211149,0xeba},
+	{0x212049,0xeba},
+	{0x212149,0xeba},
+	{0x213049,0xeba},
+	{0x213149,0xeba},
+	{0x43,0x63},
+	{0x1043,0x63},
+	{0x2043,0x63},
+	{0x3043,0x63},
+	{0x4043,0x63},
+	{0x5043,0x63},
+	{0x6043,0x63},
+	{0x7043,0x63},
+	{0x8043,0x63},
+	{0x9043,0x63},
+	{0x20018,0x3},
+	{0x20075,0x4},
+	{0x20050,0x0},
+	{0x20008,0x2ee},
+	{0x120008,0x64},
+	{0x220008,0x19},
+	{0x20088,0x9},
+	{0x200b2,0xdc},
+	{0x10043,0x5a1},
+	{0x10143,0x5a1},
+	{0x11043,0x5a1},
+	{0x11143,0x5a1},
+	{0x12043,0x5a1},
+	{0x12143,0x5a1},
+	{0x13043,0x5a1},
+	{0x13143,0x5a1},
+	{0x1200b2,0xdc},
+	{0x110043,0x5a1},
+	{0x110143,0x5a1},
+	{0x111043,0x5a1},
+	{0x111143,0x5a1},
+	{0x112043,0x5a1},
+	{0x112143,0x5a1},
+	{0x113043,0x5a1},
+	{0x113143,0x5a1},
+	{0x2200b2,0xdc},
+	{0x210043,0x5a1},
+	{0x210143,0x5a1},
+	{0x211043,0x5a1},
+	{0x211143,0x5a1},
+	{0x212043,0x5a1},
+	{0x212143,0x5a1},
+	{0x213043,0x5a1},
+	{0x213143,0x5a1},
+	{0x200fa,0x1},
+	{0x1200fa,0x1},
+	{0x2200fa,0x1},
+	{0x20019,0x1},
+	{0x120019,0x1},
+	{0x220019,0x1},
+	{0x200f0,0x660},
+	{0x200f1,0x0},
+	{0x200f2,0x4444},
+	{0x200f3,0x8888},
+	{0x200f4,0x5665},
+	{0x200f5,0x0},
+	{0x200f6,0x0},
+	{0x200f7,0xf000},
+	{0x20025,0x0},
+	{0x2002d,0x0},
+	{0x12002d,0x0},
+	{0x22002d,0x0},
+	{0x200c7,0x21},
+	{0x1200c7,0x21},
+	{0x2200c7,0x21},
+	{0x200ca,0x24},
+	{0x1200ca,0x24},
+	{0x2200ca,0x24},
+};
+
+/* ddr phy trained csr */
+struct dram_cfg_param ddr_ddrphy_trained_csr[] = {
+	{ 0x200b2, 0x0 },  
+	{ 0x1200b2, 0x0 },
+	{ 0x2200b2, 0x0 },
+	{ 0x200cb, 0x0 },  
+	{ 0x10043, 0x0 },  
+	{ 0x110043, 0x0 },
+	{ 0x210043, 0x0 },
+	{ 0x10143, 0x0 },  
+	{ 0x110143, 0x0 },
+	{ 0x210143, 0x0 },
+	{ 0x11043, 0x0 },  
+	{ 0x111043, 0x0 },
+	{ 0x211043, 0x0 },
+	{ 0x11143, 0x0 },  
+	{ 0x111143, 0x0 },
+	{ 0x211143, 0x0 },
+	{ 0x12043, 0x0 },  
+	{ 0x112043, 0x0 },
+	{ 0x212043, 0x0 },
+	{ 0x12143, 0x0 },  
+	{ 0x112143, 0x0 },
+	{ 0x212143, 0x0 },
+	{ 0x13043, 0x0 },  
+	{ 0x113043, 0x0 },
+	{ 0x213043, 0x0 },
+	{ 0x13143, 0x0 },  
+	{ 0x113143, 0x0 },
+	{ 0x213143, 0x0 },
+	{ 0x80, 0x0 },       
+	{ 0x100080, 0x0 },
+	{ 0x200080, 0x0 },
+	{ 0x1080, 0x0 },    
+	{ 0x101080, 0x0 },
+	{ 0x201080, 0x0 },
+	{ 0x2080, 0x0 },    
+	{ 0x102080, 0x0 },
+	{ 0x202080, 0x0 },
+	{ 0x3080, 0x0 },    
+	{ 0x103080, 0x0 },
+	{ 0x203080, 0x0 },
+	{ 0x4080, 0x0 },    
+	{ 0x104080, 0x0 },
+	{ 0x204080, 0x0 },
+	{ 0x5080, 0x0 },    
+	{ 0x105080, 0x0 },
+	{ 0x205080, 0x0 },
+	{ 0x6080, 0x0 },    
+	{ 0x106080, 0x0 },
+	{ 0x206080, 0x0 },
+	{ 0x7080, 0x0 },    
+	{ 0x107080, 0x0 },
+	{ 0x207080, 0x0 },
+	{ 0x8080, 0x0 },    
+	{ 0x108080, 0x0 },
+	{ 0x208080, 0x0 },
+	{ 0x9080, 0x0 },    
+	{ 0x109080, 0x0 },
+	{ 0x209080, 0x0 },
+	{ 0x10080, 0x0 },  
+	{ 0x110080, 0x0 },
+	{ 0x210080, 0x0 },
+	{ 0x10180, 0x0 },  
+	{ 0x110180, 0x0 },
+	{ 0x210180, 0x0 },
+	{ 0x11080, 0x0 },  
+	{ 0x111080, 0x0 },
+	{ 0x211080, 0x0 },
+	{ 0x11180, 0x0 },  
+	{ 0x111180, 0x0 },
+	{ 0x211180, 0x0 },
+	{ 0x12080, 0x0 },  
+	{ 0x112080, 0x0 },
+	{ 0x212080, 0x0 },
+	{ 0x12180, 0x0 },  
+	{ 0x112180, 0x0 },
+	{ 0x212180, 0x0 },
+	{ 0x13080, 0x0 },  
+	{ 0x113080, 0x0 },
+	{ 0x213080, 0x0 },
+	{ 0x13180, 0x0 },  
+	{ 0x113180, 0x0 },
+	{ 0x213180, 0x0 },
+	{ 0x10081, 0x0 },  
+	{ 0x110081, 0x0 },
+	{ 0x210081, 0x0 },
+	{ 0x10181, 0x0 },  
+	{ 0x110181, 0x0 },
+	{ 0x210181, 0x0 },
+	{ 0x11081, 0x0 },  
+	{ 0x111081, 0x0 },
+	{ 0x211081, 0x0 },
+	{ 0x11181, 0x0 },  
+	{ 0x111181, 0x0 },
+	{ 0x211181, 0x0 },
+	{ 0x12081, 0x0 },  
+	{ 0x112081, 0x0 },
+	{ 0x212081, 0x0 },
+	{ 0x12181, 0x0 },  
+	{ 0x112181, 0x0 },
+	{ 0x212181, 0x0 },
+	{ 0x13081, 0x0 },  
+	{ 0x113081, 0x0 },
+	{ 0x213081, 0x0 },
+	{ 0x13181, 0x0 },  
+	{ 0x113181, 0x0 },
+	{ 0x213181, 0x0 },
+	{ 0x100d0, 0x0 },  
+	{ 0x1100d0, 0x0 },
+	{ 0x2100d0, 0x0 },
+	{ 0x101d0, 0x0 },  
+	{ 0x1101d0, 0x0 },
+	{ 0x2101d0, 0x0 },
+	{ 0x110d0, 0x0 },  
+	{ 0x1110d0, 0x0 },
+	{ 0x2110d0, 0x0 },
+	{ 0x111d0, 0x0 },  
+	{ 0x1111d0, 0x0 },
+	{ 0x2111d0, 0x0 },
+	{ 0x120d0, 0x0 },  
+	{ 0x1120d0, 0x0 },
+	{ 0x2120d0, 0x0 },
+	{ 0x121d0, 0x0 },  
+	{ 0x1121d0, 0x0 },
+	{ 0x2121d0, 0x0 },
+	{ 0x130d0, 0x0 },  
+	{ 0x1130d0, 0x0 },
+	{ 0x2130d0, 0x0 },
+	{ 0x131d0, 0x0 },  
+	{ 0x1131d0, 0x0 },
+	{ 0x2131d0, 0x0 },
+	{ 0x100d1, 0x0 },  
+	{ 0x1100d1, 0x0 },
+	{ 0x2100d1, 0x0 },
+	{ 0x101d1, 0x0 }, 
+	{ 0x1101d1, 0x0 },
+	{ 0x2101d1, 0x0 },
+	{ 0x110d1, 0x0 }, 
+	{ 0x1110d1, 0x0 },
+	{ 0x2110d1, 0x0 },
+	{ 0x111d1, 0x0 }, 
+	{ 0x1111d1, 0x0 },
+	{ 0x2111d1, 0x0 },
+	{ 0x120d1, 0x0 }, 
+	{ 0x1120d1, 0x0 },
+	{ 0x2120d1, 0x0 },
+	{ 0x121d1, 0x0 }, 
+	{ 0x1121d1, 0x0 },
+	{ 0x2121d1, 0x0 },
+	{ 0x130d1, 0x0 }, 
+	{ 0x1130d1, 0x0 },
+	{ 0x2130d1, 0x0 },
+	{ 0x131d1, 0x0 }, 
+	{ 0x1131d1, 0x0 },
+	{ 0x2131d1, 0x0 },
+	{ 0x10068, 0x0 },
+	{ 0x10168, 0x0 },
+	{ 0x10268, 0x0 },
+	{ 0x10368, 0x0 },
+	{ 0x10468, 0x0 },
+	{ 0x10568, 0x0 },
+	{ 0x10668, 0x0 },
+	{ 0x10768, 0x0 },
+	{ 0x10868, 0x0 },
+	{ 0x11068, 0x0 },
+	{ 0x11168, 0x0 },
+	{ 0x11268, 0x0 },
+	{ 0x11368, 0x0 },
+	{ 0x11468, 0x0 },
+	{ 0x11568, 0x0 },
+	{ 0x11668, 0x0 },
+	{ 0x11768, 0x0 },
+	{ 0x11868, 0x0 },
+	{ 0x12068, 0x0 },
+	{ 0x12168, 0x0 },
+	{ 0x12268, 0x0 },
+	{ 0x12368, 0x0 },
+	{ 0x12468, 0x0 },
+	{ 0x12568, 0x0 },
+	{ 0x12668, 0x0 },
+	{ 0x12768, 0x0 },
+	{ 0x12868, 0x0 },
+	{ 0x13068, 0x0 },
+	{ 0x13168, 0x0 },
+	{ 0x13268, 0x0 },
+	{ 0x13368, 0x0 },
+	{ 0x13468, 0x0 },
+	{ 0x13568, 0x0 },
+	{ 0x13668, 0x0 },
+	{ 0x13768, 0x0 },
+	{ 0x13868, 0x0 },
+	{ 0x10069, 0x0 },
+	{ 0x10169, 0x0 },
+	{ 0x10269, 0x0 },
+	{ 0x10369, 0x0 },
+	{ 0x10469, 0x0 },
+	{ 0x10569, 0x0 },
+	{ 0x10669, 0x0 },
+	{ 0x10769, 0x0 },
+	{ 0x10869, 0x0 },
+	{ 0x11069, 0x0 },
+	{ 0x11169, 0x0 },
+	{ 0x11269, 0x0 },
+	{ 0x11369, 0x0 },
+	{ 0x11469, 0x0 },
+	{ 0x11569, 0x0 },
+	{ 0x11669, 0x0 },
+	{ 0x11769, 0x0 },
+	{ 0x11869, 0x0 },
+	{ 0x12069, 0x0 },
+	{ 0x12169, 0x0 },
+	{ 0x12269, 0x0 },
+	{ 0x12369, 0x0 },
+	{ 0x12469, 0x0 },
+	{ 0x12569, 0x0 },
+	{ 0x12669, 0x0 },
+	{ 0x12769, 0x0 },
+	{ 0x12869, 0x0 },
+	{ 0x13069, 0x0 },
+	{ 0x13169, 0x0 },
+	{ 0x13269, 0x0 },
+	{ 0x13369, 0x0 },
+	{ 0x13469, 0x0 },
+	{ 0x13569, 0x0 },
+	{ 0x13669, 0x0 },
+	{ 0x13769, 0x0 },
+	{ 0x13869, 0x0 },
+	{ 0x1008c, 0x0 },
+	{ 0x11008c, 0x0 },
+	{ 0x21008c, 0x0 },
+	{ 0x1018c, 0x0 }, 
+	{ 0x11018c, 0x0 },
+	{ 0x21018c, 0x0 },
+	{ 0x1108c, 0x0 }, 
+	{ 0x11108c, 0x0 },
+	{ 0x21108c, 0x0 },
+	{ 0x1118c, 0x0 }, 
+	{ 0x11118c, 0x0 },
+	{ 0x21118c, 0x0 },
+	{ 0x1208c, 0x0 }, 
+	{ 0x11208c, 0x0 },
+	{ 0x21208c, 0x0 },
+	{ 0x1218c, 0x0 }, 
+	{ 0x11218c, 0x0 },
+	{ 0x21218c, 0x0 },
+	{ 0x1308c, 0x0 }, 
+	{ 0x11308c, 0x0 },
+	{ 0x21308c, 0x0 },
+	{ 0x1318c, 0x0 }, 
+	{ 0x11318c, 0x0 },
+	{ 0x21318c, 0x0 },
+	{ 0x1008d, 0x0 }, 
+	{ 0x11008d, 0x0 },
+	{ 0x21008d, 0x0 },
+	{ 0x1018d, 0x0 }, 
+	{ 0x11018d, 0x0 },
+	{ 0x21018d, 0x0 },
+	{ 0x1108d, 0x0 }, 
+	{ 0x11108d, 0x0 },
+	{ 0x21108d, 0x0 },
+	{ 0x1118d, 0x0 }, 
+	{ 0x11118d, 0x0 },
+	{ 0x21118d, 0x0 },
+	{ 0x1208d, 0x0 }, 
+	{ 0x11208d, 0x0 },
+	{ 0x21208d, 0x0 },
+	{ 0x1218d, 0x0 }, 
+	{ 0x11218d, 0x0 },
+	{ 0x21218d, 0x0 },
+	{ 0x1308d, 0x0 }, 
+	{ 0x11308d, 0x0 },
+	{ 0x21308d, 0x0 },
+	{ 0x1318d, 0x0 }, 
+	{ 0x11318d, 0x0 },
+	{ 0x21318d, 0x0 },
+	{ 0x100c0, 0x0 }, 
+	{ 0x1100c0, 0x0 },
+	{ 0x2100c0, 0x0 },
+	{ 0x101c0, 0x0 }, 
+	{ 0x1101c0, 0x0 },
+	{ 0x2101c0, 0x0 },
+	{ 0x102c0, 0x0 }, 
+	{ 0x1102c0, 0x0 },
+	{ 0x2102c0, 0x0 },
+	{ 0x103c0, 0x0 }, 
+	{ 0x1103c0, 0x0 },
+	{ 0x2103c0, 0x0 },
+	{ 0x104c0, 0x0 }, 
+	{ 0x1104c0, 0x0 },
+	{ 0x2104c0, 0x0 },
+	{ 0x105c0, 0x0 }, 
+	{ 0x1105c0, 0x0 },
+	{ 0x2105c0, 0x0 },
+	{ 0x106c0, 0x0 }, 
+	{ 0x1106c0, 0x0 },
+	{ 0x2106c0, 0x0 },
+	{ 0x107c0, 0x0 }, 
+	{ 0x1107c0, 0x0 },
+	{ 0x2107c0, 0x0 },
+	{ 0x108c0, 0x0 }, 
+	{ 0x1108c0, 0x0 },
+	{ 0x2108c0, 0x0 },
+	{ 0x110c0, 0x0 }, 
+	{ 0x1110c0, 0x0 },
+	{ 0x2110c0, 0x0 },
+	{ 0x111c0, 0x0 }, 
+	{ 0x1111c0, 0x0 },
+	{ 0x2111c0, 0x0 },
+	{ 0x112c0, 0x0 }, 
+	{ 0x1112c0, 0x0 },
+	{ 0x2112c0, 0x0 },
+	{ 0x113c0, 0x0 }, 
+	{ 0x1113c0, 0x0 },
+	{ 0x2113c0, 0x0 },
+	{ 0x114c0, 0x0 }, 
+	{ 0x1114c0, 0x0 },
+	{ 0x2114c0, 0x0 },
+	{ 0x115c0, 0x0 }, 
+	{ 0x1115c0, 0x0 },
+	{ 0x2115c0, 0x0 },
+	{ 0x116c0, 0x0 }, 
+	{ 0x1116c0, 0x0 },
+	{ 0x2116c0, 0x0 },
+	{ 0x117c0, 0x0 }, 
+	{ 0x1117c0, 0x0 },
+	{ 0x2117c0, 0x0 },
+	{ 0x118c0, 0x0 }, 
+	{ 0x1118c0, 0x0 },
+	{ 0x2118c0, 0x0 },
+	{ 0x120c0, 0x0 }, 
+	{ 0x1120c0, 0x0 },
+	{ 0x2120c0, 0x0 },
+	{ 0x121c0, 0x0 }, 
+	{ 0x1121c0, 0x0 },
+	{ 0x2121c0, 0x0 },
+	{ 0x122c0, 0x0 }, 
+	{ 0x1122c0, 0x0 },
+	{ 0x2122c0, 0x0 },
+	{ 0x123c0, 0x0 }, 
+	{ 0x1123c0, 0x0 },
+	{ 0x2123c0, 0x0 },
+	{ 0x124c0, 0x0 }, 
+	{ 0x1124c0, 0x0 },
+	{ 0x2124c0, 0x0 },
+	{ 0x125c0, 0x0 }, 
+	{ 0x1125c0, 0x0 },
+	{ 0x2125c0, 0x0 },
+	{ 0x126c0, 0x0 }, 
+	{ 0x1126c0, 0x0 },
+	{ 0x2126c0, 0x0 },
+	{ 0x127c0, 0x0 }, 
+	{ 0x1127c0, 0x0 },
+	{ 0x2127c0, 0x0 },
+	{ 0x128c0, 0x0 }, 
+	{ 0x1128c0, 0x0 },
+	{ 0x2128c0, 0x0 },
+	{ 0x130c0, 0x0 }, 
+	{ 0x1130c0, 0x0 },
+	{ 0x2130c0, 0x0 },
+	{ 0x131c0, 0x0 }, 
+	{ 0x1131c0, 0x0 },
+	{ 0x2131c0, 0x0 },
+	{ 0x132c0, 0x0 }, 
+	{ 0x1132c0, 0x0 },
+	{ 0x2132c0, 0x0 },
+	{ 0x133c0, 0x0 }, 
+	{ 0x1133c0, 0x0 },
+	{ 0x2133c0, 0x0 },
+	{ 0x134c0, 0x0 }, 
+	{ 0x1134c0, 0x0 },
+	{ 0x2134c0, 0x0 },
+	{ 0x135c0, 0x0 }, 
+	{ 0x1135c0, 0x0 },
+	{ 0x2135c0, 0x0 },
+	{ 0x136c0, 0x0 }, 
+	{ 0x1136c0, 0x0 },
+	{ 0x2136c0, 0x0 },
+	{ 0x137c0, 0x0 }, 
+	{ 0x1137c0, 0x0 },
+	{ 0x2137c0, 0x0 },
+	{ 0x138c0, 0x0 }, 
+	{ 0x1138c0, 0x0 },
+	{ 0x2138c0, 0x0 },
+	{ 0x100c1, 0x0 }, 
+	{ 0x1100c1, 0x0 },
+	{ 0x2100c1, 0x0 },
+	{ 0x101c1, 0x0 }, 
+	{ 0x1101c1, 0x0 },
+	{ 0x2101c1, 0x0 },
+	{ 0x102c1, 0x0 }, 
+	{ 0x1102c1, 0x0 },
+	{ 0x2102c1, 0x0 },
+	{ 0x103c1, 0x0 }, 
+	{ 0x1103c1, 0x0 },
+	{ 0x2103c1, 0x0 },
+	{ 0x104c1, 0x0 }, 
+	{ 0x1104c1, 0x0 },
+	{ 0x2104c1, 0x0 },
+	{ 0x105c1, 0x0 }, 
+	{ 0x1105c1, 0x0 },
+	{ 0x2105c1, 0x0 },
+	{ 0x106c1, 0x0 }, 
+	{ 0x1106c1, 0x0 },
+	{ 0x2106c1, 0x0 },
+	{ 0x107c1, 0x0 }, 
+	{ 0x1107c1, 0x0 },
+	{ 0x2107c1, 0x0 },
+	{ 0x108c1, 0x0 }, 
+	{ 0x1108c1, 0x0 },
+	{ 0x2108c1, 0x0 },
+	{ 0x110c1, 0x0 }, 
+	{ 0x1110c1, 0x0 },
+	{ 0x2110c1, 0x0 },
+	{ 0x111c1, 0x0 }, 
+	{ 0x1111c1, 0x0 },
+	{ 0x2111c1, 0x0 },
+	{ 0x112c1, 0x0 }, 
+	{ 0x1112c1, 0x0 },
+	{ 0x2112c1, 0x0 },
+	{ 0x113c1, 0x0 }, 
+	{ 0x1113c1, 0x0 },
+	{ 0x2113c1, 0x0 },
+	{ 0x114c1, 0x0 }, 
+	{ 0x1114c1, 0x0 },
+	{ 0x2114c1, 0x0 },
+	{ 0x115c1, 0x0 }, 
+	{ 0x1115c1, 0x0 },
+	{ 0x2115c1, 0x0 },
+	{ 0x116c1, 0x0 }, 
+	{ 0x1116c1, 0x0 },
+	{ 0x2116c1, 0x0 },
+	{ 0x117c1, 0x0 }, 
+	{ 0x1117c1, 0x0 },
+	{ 0x2117c1, 0x0 },
+	{ 0x118c1, 0x0 }, 
+	{ 0x1118c1, 0x0 },
+	{ 0x2118c1, 0x0 },
+	{ 0x120c1, 0x0 }, 
+	{ 0x1120c1, 0x0 },
+	{ 0x2120c1, 0x0 },
+	{ 0x121c1, 0x0 }, 
+	{ 0x1121c1, 0x0 },
+	{ 0x2121c1, 0x0 },
+	{ 0x122c1, 0x0 }, 
+	{ 0x1122c1, 0x0 },
+	{ 0x2122c1, 0x0 },
+	{ 0x123c1, 0x0 }, 
+	{ 0x1123c1, 0x0 },
+	{ 0x2123c1, 0x0 },
+	{ 0x124c1, 0x0 }, 
+	{ 0x1124c1, 0x0 },
+	{ 0x2124c1, 0x0 },
+	{ 0x125c1, 0x0 }, 
+	{ 0x1125c1, 0x0 },
+	{ 0x2125c1, 0x0 },
+	{ 0x126c1, 0x0 }, 
+	{ 0x1126c1, 0x0 },
+	{ 0x2126c1, 0x0 },
+	{ 0x127c1, 0x0 }, 
+	{ 0x1127c1, 0x0 },
+	{ 0x2127c1, 0x0 },
+	{ 0x128c1, 0x0 }, 
+	{ 0x1128c1, 0x0 },
+	{ 0x2128c1, 0x0 },
+	{ 0x130c1, 0x0 }, 
+	{ 0x1130c1, 0x0 },
+	{ 0x2130c1, 0x0 },
+	{ 0x131c1, 0x0 }, 
+	{ 0x1131c1, 0x0 },
+	{ 0x2131c1, 0x0 },
+	{ 0x132c1, 0x0 }, 
+	{ 0x1132c1, 0x0 },
+	{ 0x2132c1, 0x0 },
+	{ 0x133c1, 0x0 }, 
+	{ 0x1133c1, 0x0 },
+	{ 0x2133c1, 0x0 },
+	{ 0x134c1, 0x0 }, 
+	{ 0x1134c1, 0x0 },
+	{ 0x2134c1, 0x0 },
+	{ 0x135c1, 0x0 }, 
+	{ 0x1135c1, 0x0 },
+	{ 0x2135c1, 0x0 },
+	{ 0x136c1, 0x0 }, 
+	{ 0x1136c1, 0x0 },
+	{ 0x2136c1, 0x0 },
+	{ 0x137c1, 0x0 }, 
+	{ 0x1137c1, 0x0 },
+	{ 0x2137c1, 0x0 },
+	{ 0x138c1, 0x0 }, 
+	{ 0x1138c1, 0x0 },
+	{ 0x2138c1, 0x0 },
+	{ 0x10020, 0x0 }, 
+	{ 0x110020, 0x0 },
+	{ 0x210020, 0x0 },
+	{ 0x11020, 0x0 }, 
+	{ 0x111020, 0x0 },
+	{ 0x211020, 0x0 },
+	{ 0x12020, 0x0 }, 
+	{ 0x112020, 0x0 },
+	{ 0x212020, 0x0 },
+	{ 0x13020, 0x0 }, 
+	{ 0x113020, 0x0 },
+	{ 0x213020, 0x0 },
+	{ 0x20072, 0x0 }, 
+	{ 0x20073, 0x0 }, 
+	{ 0x20074, 0x0 }, 
+	{ 0x100aa, 0x0 }, 
+	{ 0x110aa, 0x0 }, 
+	{ 0x120aa, 0x0 }, 
+	{ 0x130aa, 0x0 }, 
+	{ 0x20010, 0x0 }, 
+	{ 0x120010, 0x0 },
+	{ 0x220010, 0x0 },
+	{ 0x20011, 0x0 }, 
+	{ 0x120011, 0x0 },
+	{ 0x220011, 0x0 },
+	{ 0x100ae, 0x0 }, 
+	{ 0x1100ae, 0x0 },
+	{ 0x2100ae, 0x0 },
+	{ 0x100af, 0x0 }, 
+	{ 0x1100af, 0x0 },
+	{ 0x2100af, 0x0 },
+	{ 0x110ae, 0x0 }, 
+	{ 0x1110ae, 0x0 },
+	{ 0x2110ae, 0x0 },
+	{ 0x110af, 0x0 }, 
+	{ 0x1110af, 0x0 },
+	{ 0x2110af, 0x0 },
+	{ 0x120ae, 0x0 }, 
+	{ 0x1120ae, 0x0 },
+	{ 0x2120ae, 0x0 },
+	{ 0x120af, 0x0 }, 
+	{ 0x1120af, 0x0 },
+	{ 0x2120af, 0x0 },
+	{ 0x130ae, 0x0 }, 
+	{ 0x1130ae, 0x0 },
+	{ 0x2130ae, 0x0 },
+	{ 0x130af, 0x0 }, 
+	{ 0x1130af, 0x0 },
+	{ 0x2130af, 0x0 },
+	{ 0x20020, 0x0 }, 
+	{ 0x120020, 0x0 },
+	{ 0x220020, 0x0 },
+	{ 0x100a0, 0x0 }, 
+	{ 0x100a1, 0x0 },
+	{ 0x100a2, 0x0 },
+	{ 0x100a3, 0x0 },
+	{ 0x100a4, 0x0 },
+	{ 0x100a5, 0x0 },
+	{ 0x100a6, 0x0 },
+	{ 0x100a7, 0x0 },
+	{ 0x110a0, 0x0 },
+	{ 0x110a1, 0x0 },
+	{ 0x110a2, 0x0 },
+	{ 0x110a3, 0x0 },
+	{ 0x110a4, 0x0 },
+	{ 0x110a5, 0x0 },
+	{ 0x110a6, 0x0 },
+	{ 0x110a7, 0x0 },
+	{ 0x120a0, 0x0 },
+	{ 0x120a1, 0x0 },
+	{ 0x120a2, 0x0 },
+	{ 0x120a3, 0x0 },
+	{ 0x120a4, 0x0 },
+	{ 0x120a5, 0x0 },
+	{ 0x120a6, 0x0 },
+	{ 0x120a7, 0x0 },
+	{ 0x130a0, 0x0 },
+	{ 0x130a1, 0x0 },
+	{ 0x130a2, 0x0 },
+	{ 0x130a3, 0x0 },
+	{ 0x130a4, 0x0 }, 
+	{ 0x130a5, 0x0 }, 
+	{ 0x130a6, 0x0 }, 
+	{ 0x130a7, 0x0 }, 
+	{ 0x2007c, 0x0 }, 
+	{ 0x12007c, 0x0 },
+	{ 0x22007c, 0x0 },
+	{ 0x2007d, 0x0 }, 
+	{ 0x12007d, 0x0 },
+	{ 0x22007d, 0x0 },
+	{ 0x400fd, 0x0 }, 
+	{ 0x400c0, 0x0 }, 
+	{ 0x90201, 0x0 }, 
+	{ 0x190201, 0x0 },
+	{ 0x290201, 0x0 },
+	{ 0x90202, 0x0 }, 
+	{ 0x190202, 0x0 },
+	{ 0x290202, 0x0 },
+	{ 0x90203, 0x0 }, 
+	{ 0x190203, 0x0 },
+	{ 0x290203, 0x0 },
+	{ 0x90204, 0x0 }, 
+	{ 0x190204, 0x0 },
+	{ 0x290204, 0x0 },
+	{ 0x90205, 0x0 }, 
+	{ 0x190205, 0x0 },
+	{ 0x290205, 0x0 },
+	{ 0x90206, 0x0 }, 
+	{ 0x190206, 0x0 },
+	{ 0x290206, 0x0 },
+	{ 0x90207, 0x0 }, 
+	{ 0x190207, 0x0 },
+	{ 0x290207, 0x0 },
+	{ 0x90208, 0x0 }, 
+	{ 0x190208, 0x0 },
+	{ 0x290208, 0x0 },
+	{ 0x10062, 0x0 }, 
+	{ 0x10162, 0x0 }, 
+	{ 0x10262, 0x0 }, 
+	{ 0x10362, 0x0 }, 
+	{ 0x10462, 0x0 }, 
+	{ 0x10562, 0x0 }, 
+	{ 0x10662, 0x0 }, 
+	{ 0x10762, 0x0 }, 
+	{ 0x10862, 0x0 }, 
+	{ 0x11062, 0x0 }, 
+	{ 0x11162, 0x0 }, 
+	{ 0x11262, 0x0 }, 
+	{ 0x11362, 0x0 }, 
+	{ 0x11462, 0x0 }, 
+	{ 0x11562, 0x0 }, 
+	{ 0x11662, 0x0 },
+	{ 0x11762, 0x0 },
+	{ 0x11862, 0x0 },
+	{ 0x12062, 0x0 },
+	{ 0x12162, 0x0 },
+	{ 0x12262, 0x0 },
+	{ 0x12362, 0x0 },
+	{ 0x12462, 0x0 },
+	{ 0x12562, 0x0 },
+	{ 0x12662, 0x0 },
+	{ 0x12762, 0x0 },
+	{ 0x12862, 0x0 },
+	{ 0x13062, 0x0 },
+	{ 0x13162, 0x0 },
+	{ 0x13262, 0x0 },
+	{ 0x13362, 0x0 },
+	{ 0x13462, 0x0 },
+	{ 0x13562, 0x0 },
+	{ 0x13662, 0x0 },
+	{ 0x13762, 0x0 },
+	{ 0x13862, 0x0 },
+	{ 0x20077, 0x0 },
+	{ 0x10001, 0x0 },
+	{ 0x11001, 0x0 },
+	{ 0x12001, 0x0 },
+	{ 0x13001, 0x0 },
+	{ 0x10040, 0x0 },
+	{ 0x10140, 0x0 },
+	{ 0x10240, 0x0 },
+	{ 0x10340, 0x0 },
+	{ 0x10440, 0x0 },
+	{ 0x10540, 0x0 },
+	{ 0x10640, 0x0 },
+	{ 0x10740, 0x0 },
+	{ 0x10840, 0x0 },
+	{ 0x10030, 0x0 },
+	{ 0x10130, 0x0 },
+	{ 0x10230, 0x0 },
+	{ 0x10330, 0x0 },
+	{ 0x10430, 0x0 },
+	{ 0x10530, 0x0 },
+	{ 0x10630, 0x0 },
+	{ 0x10730, 0x0 },
+	{ 0x10830, 0x0 },
+	{ 0x11040, 0x0 },
+	{ 0x11140, 0x0 },
+	{ 0x11240, 0x0 },
+	{ 0x11340, 0x0 },
+	{ 0x11440, 0x0 },
+	{ 0x11540, 0x0 },
+	{ 0x11640, 0x0 },
+	{ 0x11740, 0x0 },
+	{ 0x11840, 0x0 },
+	{ 0x11030, 0x0 },
+	{ 0x11130, 0x0 },
+	{ 0x11230, 0x0 },
+	{ 0x11330, 0x0 },
+	{ 0x11430, 0x0 },
+	{ 0x11530, 0x0 },
+	{ 0x11630, 0x0 },
+	{ 0x11730, 0x0 },
+	{ 0x11830, 0x0 },
+	{ 0x12040, 0x0 },
+	{ 0x12140, 0x0 },
+	{ 0x12240, 0x0 },
+	{ 0x12340, 0x0 },
+	{ 0x12440, 0x0 },
+	{ 0x12540, 0x0 },
+	{ 0x12640, 0x0 },
+	{ 0x12740, 0x0 },
+	{ 0x12840, 0x0 },
+	{ 0x12030, 0x0 },
+	{ 0x12130, 0x0 },
+	{ 0x12230, 0x0 },
+	{ 0x12330, 0x0 },
+	{ 0x12430, 0x0 },
+	{ 0x12530, 0x0 },
+	{ 0x12630, 0x0 },
+	{ 0x12730, 0x0 },
+	{ 0x12830, 0x0 },
+	{ 0x13040, 0x0 },
+	{ 0x13140, 0x0 },
+	{ 0x13240, 0x0 },
+	{ 0x13340, 0x0 },
+	{ 0x13440, 0x0 },
+	{ 0x13540, 0x0 },
+	{ 0x13640, 0x0 },
+	{ 0x13740, 0x0 },
+	{ 0x13840, 0x0 },
+	{ 0x13030, 0x0 },
+	{ 0x13130, 0x0 },
+	{ 0x13230, 0x0 },
+	{ 0x13330, 0x0 },
+	{ 0x13430, 0x0 },
+	{ 0x13530, 0x0 },
+	{ 0x13630, 0x0 },
+	{ 0x13730, 0x0 },
+	{ 0x13830, 0x0 },
+};
+/* P0 message block paremeter for training firmware */
+struct dram_cfg_param ddr_fsp0_cfg[] = {
+	{0xd0000, 0x0},
+	{0x54003,0xbb8},
+	{0x54004,0x2},
+	{0x54005,0x2228},
+	{0x54006,0x11},
+	{0x54008,0x131f},
+	{0x54009,0xc8},
+	{0x5400b,0x2},
+	{0x5400d,0x100},
+	{0x54012,0x110},
+	{0x54019,0x2dd4},
+	{0x5401a,0x31},
+	{0x5401b,0x4d66},
+	{0x5401c,0x4d00},
+	{0x5401e,0x16},
+	{0x5401f,0x2dd4},
+	{0x54020,0x31},
+	{0x54021,0x4d66},
+	{0x54022,0x4d00},
+	{0x54024,0x16},
+	{0x5402b,0x1000},
+	{0x5402c,0x1},
+	{0x54032,0xd400},
+	{0x54033,0x312d},
+	{0x54034,0x6600},
+	{0x54035,0x4d},
+	{0x54036,0x4d},
+	{0x54037,0x1600},
+	{0x54038,0xd400},
+	{0x54039,0x312d},
+	{0x5403a,0x6600},
+	{0x5403b,0x4d},
+	{0x5403c,0x4d},
+	{0x5403d,0x1600},
+	{0xd0000, 0x1},
+};
+
+
+/* P1 message block paremeter for training firmware */
+struct dram_cfg_param ddr_fsp1_cfg[] = {
+	{0xd0000, 0x0},
+	{0x54002,0x101},
+	{0x54003,0x190},
+	{0x54004,0x2},
+	{0x54005,0x2228},
+	{0x54006,0x11},
+	{0x54008,0x121f},
+	{0x54009,0xc8},
+	{0x5400b,0x2},
+	{0x5400d,0x100},
+	{0x54012,0x110},
+	{0x54019,0x84},
+	{0x5401a,0x31},
+	{0x5401b,0x4d66},
+	{0x5401c,0x4d00},
+	{0x5401e,0x16},
+	{0x5401f,0x84},
+	{0x54020,0x31},
+	{0x54021,0x4d66},
+	{0x54022,0x4d00},
+	{0x54024,0x16},
+	{0x5402b,0x1000},
+	{0x5402c,0x1},
+	{0x54032,0x8400},
+	{0x54033,0x3100},
+	{0x54034,0x6600},
+	{0x54035,0x4d},
+	{0x54036,0x4d},
+	{0x54037,0x1600},
+	{0x54038,0x8400},
+	{0x54039,0x3100},
+	{0x5403a,0x6600},
+	{0x5403b,0x4d},
+	{0x5403c,0x4d},
+	{0x5403d,0x1600},
+	{0xd0000, 0x1},
+};
+
+
+/* P2 message block paremeter for training firmware */
+struct dram_cfg_param ddr_fsp2_cfg[] = {
+	{0xd0000, 0x0},
+	{0x54002,0x102},
+	{0x54003,0x64},
+	{0x54004,0x2},
+	{0x54005,0x2228},
+	{0x54006,0x11},
+	{0x54008,0x121f},
+	{0x54009,0xc8},
+	{0x5400b,0x2},
+	{0x5400d,0x100},
+	{0x54012,0x110},
+	{0x54019,0x84},
+	{0x5401a,0x31},
+	{0x5401b,0x4d66},
+	{0x5401c,0x4d00},
+	{0x5401e,0x16},
+	{0x5401f,0x84},
+	{0x54020,0x31},
+	{0x54021,0x4d66},
+	{0x54022,0x4d00},
+	{0x54024,0x16},
+	{0x5402b,0x1000},
+	{0x5402c,0x1},
+	{0x54032,0x8400},
+	{0x54033,0x3100},
+	{0x54034,0x6600},
+	{0x54035,0x4d},
+	{0x54036,0x4d},
+	{0x54037,0x1600},
+	{0x54038,0x8400},
+	{0x54039,0x3100},
+	{0x5403a,0x6600},
+	{0x5403b,0x4d},
+	{0x5403c,0x4d},
+	{0x5403d,0x1600},
+	{0xd0000, 0x1},
+};
+
+
+/* P0 2D message block paremeter for training firmware */
+struct dram_cfg_param ddr_fsp0_2d_cfg[] = {
+	{0xd0000, 0x0},
+	{0x54003,0xbb8},
+	{0x54004,0x2},
+	{0x54005,0x2228},
+	{0x54006,0x11},
+	{0x54008,0x61},
+	{0x54009,0xc8},
+	{0x5400b,0x2},
+	{0x5400f,0x100},
+	{0x54010,0x1f7f},
+	{0x54012,0x110},
+	{0x54019,0x2dd4},
+	{0x5401a,0x31},
+	{0x5401b,0x4d66},
+	{0x5401c,0x4d00},
+	{0x5401e,0x16},
+	{0x5401f,0x2dd4},
+	{0x54020,0x31},
+	{0x54021,0x4d66},
+	{0x54022,0x4d00},
+	{0x54024,0x16},
+	{0x5402b,0x1000},
+	{0x5402c,0x1},
+	{0x54032,0xd400},
+	{0x54033,0x312d},
+	{0x54034,0x6600},
+	{0x54035,0x4d},
+	{0x54036,0x4d},
+	{0x54037,0x1600},
+	{0x54038,0xd400},
+	{0x54039,0x312d},
+	{0x5403a,0x6600},
+	{0x5403b,0x4d},
+	{0x5403c,0x4d},
+	{0x5403d,0x1600},
+	{ 0xd0000, 0x1 },
+};
+
+/* DRAM PHY init engine image */
+struct dram_cfg_param ddr_phy_pie[] = {
+	{0xd0000, 0x0},
+	{0x90000,0x10},
+	{0x90001,0x400},
+	{0x90002,0x10e},
+	{0x90003,0x0},
+	{0x90004,0x0},
+	{0x90005,0x8},
+	{0x90029,0xb},
+	{0x9002a,0x480},
+	{0x9002b,0x109},
+	{0x9002c,0x8},
+	{0x9002d,0x448},
+	{0x9002e,0x139},
+	{0x9002f,0x8},
+	{0x90030,0x478},
+	{0x90031,0x109},
+	{0x90032,0x0},
+	{0x90033,0xe8},
+	{0x90034,0x109},
+	{0x90035,0x2},
+	{0x90036,0x10},
+	{0x90037,0x139},
+	{0x90038,0xf},
+	{0x90039,0x7c0},
+	{0x9003a,0x139},
+	{0x9003b,0x44},
+	{0x9003c,0x630},
+	{0x9003d,0x159},
+	{0x9003e,0x14f},
+	{0x9003f,0x630},
+	{0x90040,0x159},
+	{0x90041,0x47},
+	{0x90042,0x630},
+	{0x90043,0x149},
+	{0x90044,0x4f},
+	{0x90045,0x630},
+	{0x90046,0x179},
+	{0x90047,0x8},
+	{0x90048,0xe0},
+	{0x90049,0x109},
+	{0x9004a,0x0},
+	{0x9004b,0x7c8},
+	{0x9004c,0x109},
+	{0x9004d,0x0},
+	{0x9004e,0x1},
+	{0x9004f,0x8},
+	{0x90050,0x0},
+	{0x90051,0x45a},
+	{0x90052,0x9},
+	{0x90053,0x0},
+	{0x90054,0x448},
+	{0x90055,0x109},
+	{0x90056,0x40},
+	{0x90057,0x630},
+	{0x90058,0x179},
+	{0x90059,0x1},
+	{0x9005a,0x618},
+	{0x9005b,0x109},
+	{0x9005c,0x40c0},
+	{0x9005d,0x630},
+	{0x9005e,0x149},
+	{0x9005f,0x8},
+	{0x90060,0x4},
+	{0x90061,0x48},
+	{0x90062,0x4040},
+	{0x90063,0x630},
+	{0x90064,0x149},
+	{0x90065,0x0},
+	{0x90066,0x4},
+	{0x90067,0x48},
+	{0x90068,0x40},
+	{0x90069,0x630},
+	{0x9006a,0x149},
+	{0x9006b,0x10},
+	{0x9006c,0x4},
+	{0x9006d,0x18},
+	{0x9006e,0x0},
+	{0x9006f,0x4},
+	{0x90070,0x78},
+	{0x90071,0x549},
+	{0x90072,0x630},
+	{0x90073,0x159},
+	{0x90074,0xd49},
+	{0x90075,0x630},
+	{0x90076,0x159},
+	{0x90077,0x94a},
+	{0x90078,0x630},
+	{0x90079,0x159},
+	{0x9007a,0x441},
+	{0x9007b,0x630},
+	{0x9007c,0x149},
+	{0x9007d,0x42},
+	{0x9007e,0x630},
+	{0x9007f,0x149},
+	{0x90080,0x1},
+	{0x90081,0x630},
+	{0x90082,0x149},
+	{0x90083,0x0},
+	{0x90084,0xe0},
+	{0x90085,0x109},
+	{0x90086,0xa},
+	{0x90087,0x10},
+	{0x90088,0x109},
+	{0x90089,0x9},
+	{0x9008a,0x3c0},
+	{0x9008b,0x149},
+	{0x9008c,0x9},
+	{0x9008d,0x3c0},
+	{0x9008e,0x159},
+	{0x9008f,0x18},
+	{0x90090,0x10},
+	{0x90091,0x109},
+	{0x90092,0x0},
+	{0x90093,0x3c0},
+	{0x90094,0x109},
+	{0x90095,0x18},
+	{0x90096,0x4},
+	{0x90097,0x48},
+	{0x90098,0x18},
+	{0x90099,0x4},
+	{0x9009a,0x58},
+	{0x9009b,0xa},
+	{0x9009c,0x10},
+	{0x9009d,0x109},
+	{0x9009e,0x2},
+	{0x9009f,0x10},
+	{0x900a0,0x109},
+	{0x900a1,0x5},
+	{0x900a2,0x7c0},
+	{0x900a3,0x109},
+	{0x900a4,0x10},
+	{0x900a5,0x10},
+	{0x900a6,0x109},
+	{0x40000,0x811},
+	{0x40020,0x880},
+	{0x40040,0x0},
+	{0x40060,0x0},
+	{0x40001,0x4008},
+	{0x40021,0x83},
+	{0x40041,0x4f},
+	{0x40061,0x0},
+	{0x40002,0x4040},
+	{0x40022,0x83},
+	{0x40042,0x51},
+	{0x40062,0x0},
+	{0x40003,0x811},
+	{0x40023,0x880},
+	{0x40043,0x0},
+	{0x40063,0x0},
+	{0x40004,0x720},
+	{0x40024,0xf},
+	{0x40044,0x1740},
+	{0x40064,0x0},
+	{0x40005,0x16},
+	{0x40025,0x83},
+	{0x40045,0x4b},
+	{0x40065,0x0},
+	{0x40006,0x716},
+	{0x40026,0xf},
+	{0x40046,0x2001},
+	{0x40066,0x0},
+	{0x40007,0x716},
+	{0x40027,0xf},
+	{0x40047,0x2800},
+	{0x40067,0x0},
+	{0x40008,0x716},
+	{0x40028,0xf},
+	{0x40048,0xf00},
+	{0x40068,0x0},
+	{0x40009,0x720},
+	{0x40029,0xf},
+	{0x40049,0x1400},
+	{0x40069,0x0},
+	{0x4000a,0xe08},
+	{0x4002a,0xc15},
+	{0x4004a,0x0},
+	{0x4006a,0x0},
+	{0x4000b,0x623},
+	{0x4002b,0x15},
+	{0x4004b,0x0},
+	{0x4006b,0x0},
+	{0x4000c,0x4028},
+	{0x4002c,0x80},
+	{0x4004c,0x0},
+	{0x4006c,0x0},
+	{0x4000d,0xe08},
+	{0x4002d,0xc1a},
+	{0x4004d,0x0},
+	{0x4006d,0x0},
+	{0x4000e,0x623},
+	{0x4002e,0x1a},
+	{0x4004e,0x0},
+	{0x4006e,0x0},
+	{0x4000f,0x4040},
+	{0x4002f,0x80},
+	{0x4004f,0x0},
+	{0x4006f,0x0},
+	{0x40010,0x2604},
+	{0x40030,0x15},
+	{0x40050,0x0},
+	{0x40070,0x0},
+	{0x40011,0x708},
+	{0x40031,0x5},
+	{0x40051,0x0},
+	{0x40071,0x2002},
+	{0x40012,0x8},
+	{0x40032,0x80},
+	{0x40052,0x0},
+	{0x40072,0x0},
+	{0x40013,0x2604},
+	{0x40033,0x1a},
+	{0x40053,0x0},
+	{0x40073,0x0},
+	{0x40014,0x708},
+	{0x40034,0xa},
+	{0x40054,0x0},
+	{0x40074,0x2002},
+	{0x40015,0x4040},
+	{0x40035,0x80},
+	{0x40055,0x0},
+	{0x40075,0x0},
+	{0x40016,0x60a},
+	{0x40036,0x15},
+	{0x40056,0x1200},
+	{0x40076,0x0},
+	{0x40017,0x61a},
+	{0x40037,0x15},
+	{0x40057,0x1300},
+	{0x40077,0x0},
+	{0x40018,0x60a},
+	{0x40038,0x1a},
+	{0x40058,0x1200},
+	{0x40078,0x0},
+	{0x40019,0x642},
+	{0x40039,0x1a},
+	{0x40059,0x1300},
+	{0x40079,0x0},
+	{0x4001a,0x4808},
+	{0x4003a,0x880},
+	{0x4005a,0x0},
+	{0x4007a,0x0},
+	{0x900a7,0x0},
+	{0x900a8,0x790},
+	{0x900a9,0x11a},
+	{0x900aa,0x8},
+	{0x900ab,0x7aa},
+	{0x900ac,0x2a},
+	{0x900ad,0x10},
+	{0x900ae,0x7b2},
+	{0x900af,0x2a},
+	{0x900b0,0x0},
+	{0x900b1,0x7c8},
+	{0x900b2,0x109},
+	{0x900b3,0x10},
+	{0x900b4,0x2a8},
+	{0x900b5,0x129},
+	{0x900b6,0x8},
+	{0x900b7,0x370},
+	{0x900b8,0x129},
+	{0x900b9,0xa},
+	{0x900ba,0x3c8},
+	{0x900bb,0x1a9},
+	{0x900bc,0xc},
+	{0x900bd,0x408},
+	{0x900be,0x199},
+	{0x900bf,0x14},
+	{0x900c0,0x790},
+	{0x900c1,0x11a},
+	{0x900c2,0x8},
+	{0x900c3,0x4},
+	{0x900c4,0x18},
+	{0x900c5,0xe},
+	{0x900c6,0x408},
+	{0x900c7,0x199},
+	{0x900c8,0x8},
+	{0x900c9,0x8568},
+	{0x900ca,0x108},
+	{0x900cb,0x18},
+	{0x900cc,0x790},
+	{0x900cd,0x16a},
+	{0x900ce,0x8},
+	{0x900cf,0x1d8},
+	{0x900d0,0x169},
+	{0x900d1,0x10},
+	{0x900d2,0x8558},
+	{0x900d3,0x168},
+	{0x900d4,0x70},
+	{0x900d5,0x788},
+	{0x900d6,0x16a},
+	{0x900d7,0x1ff8},
+	{0x900d8,0x85a8},
+	{0x900d9,0x1e8},
+	{0x900da,0x50},
+	{0x900db,0x798},
+	{0x900dc,0x16a},
+	{0x900dd,0x60},
+	{0x900de,0x7a0},
+	{0x900df,0x16a},
+	{0x900e0,0x8},
+	{0x900e1,0x8310},
+	{0x900e2,0x168},
+	{0x900e3,0x8},
+	{0x900e4,0xa310},
+	{0x900e5,0x168},
+	{0x900e6,0xa},
+	{0x900e7,0x408},
+	{0x900e8,0x169},
+	{0x900e9,0x6e},
+	{0x900ea,0x0},
+	{0x900eb,0x68},
+	{0x900ec,0x0},
+	{0x900ed,0x408},
+	{0x900ee,0x169},
+	{0x900ef,0x0},
+	{0x900f0,0x8310},
+	{0x900f1,0x168},
+	{0x900f2,0x0},
+	{0x900f3,0xa310},
+	{0x900f4,0x168},
+	{0x900f5,0x1ff8},
+	{0x900f6,0x85a8},
+	{0x900f7,0x1e8},
+	{0x900f8,0x68},
+	{0x900f9,0x798},
+	{0x900fa,0x16a},
+	{0x900fb,0x78},
+	{0x900fc,0x7a0},
+	{0x900fd,0x16a},
+	{0x900fe,0x68},
+	{0x900ff,0x790},
+	{0x90100,0x16a},
+	{0x90101,0x8},
+	{0x90102,0x8b10},
+	{0x90103,0x168},
+	{0x90104,0x8},
+	{0x90105,0xab10},
+	{0x90106,0x168},
+	{0x90107,0xa},
+	{0x90108,0x408},
+	{0x90109,0x169},
+	{0x9010a,0x58},
+	{0x9010b,0x0},
+	{0x9010c,0x68},
+	{0x9010d,0x0},
+	{0x9010e,0x408},
+	{0x9010f,0x169},
+	{0x90110,0x0},
+	{0x90111,0x8b10},
+	{0x90112,0x168},
+	{0x90113,0x0},
+	{0x90114,0xab10},
+	{0x90115,0x168},
+	{0x90116,0x0},
+	{0x90117,0x1d8},
+	{0x90118,0x169},
+	{0x90119,0x80},
+	{0x9011a,0x790},
+	{0x9011b,0x16a},
+	{0x9011c,0x18},
+	{0x9011d,0x7aa},
+	{0x9011e,0x6a},
+	{0x9011f,0xa},
+	{0x90120,0x0},
+	{0x90121,0x1e9},
+	{0x90122,0x8},
+	{0x90123,0x8080},
+	{0x90124,0x108},
+	{0x90125,0xf},
+	{0x90126,0x408},
+	{0x90127,0x169},
+	{0x90128,0xc},
+	{0x90129,0x0},
+	{0x9012a,0x68},
+	{0x9012b,0x9},
+	{0x9012c,0x0},
+	{0x9012d,0x1a9},
+	{0x9012e,0x0},
+	{0x9012f,0x408},
+	{0x90130,0x169},
+	{0x90131,0x0},
+	{0x90132,0x8080},
+	{0x90133,0x108},
+	{0x90134,0x8},
+	{0x90135,0x7aa},
+	{0x90136,0x6a},
+	{0x90137,0x0},
+	{0x90138,0x8568},
+	{0x90139,0x108},
+	{0x9013a,0xb7},
+	{0x9013b,0x790},
+	{0x9013c,0x16a},
+	{0x9013d,0x1f},
+	{0x9013e,0x0},
+	{0x9013f,0x68},
+	{0x90140,0x8},
+	{0x90141,0x8558},
+	{0x90142,0x168},
+	{0x90143,0xf},
+	{0x90144,0x408},
+	{0x90145,0x169},
+	{0x90146,0xc},
+	{0x90147,0x0},
+	{0x90148,0x68},
+	{0x90149,0x0},
+	{0x9014a,0x408},
+	{0x9014b,0x169},
+	{0x9014c,0x0},
+	{0x9014d,0x8558},
+	{0x9014e,0x168},
+	{0x9014f,0x8},
+	{0x90150,0x3c8},
+	{0x90151,0x1a9},
+	{0x90152,0x3},
+	{0x90153,0x370},
+	{0x90154,0x129},
+	{0x90155,0x20},
+	{0x90156,0x2aa},
+	{0x90157,0x9},
+	{0x90158,0x0},
+	{0x90159,0x400},
+	{0x9015a,0x10e},
+	{0x9015b,0x8},
+	{0x9015c,0xe8},
+	{0x9015d,0x109},
+	{0x9015e,0x0},
+	{0x9015f,0x8140},
+	{0x90160,0x10c},
+	{0x90161,0x10},
+	{0x90162,0x8138},
+	{0x90163,0x10c},
+	{0x90164,0x8},
+	{0x90165,0x7c8},
+	{0x90166,0x101},
+	{0x90167,0x8},
+	{0x90168,0x0},
+	{0x90169,0x8},
+	{0x9016a,0x8},
+	{0x9016b,0x448},
+	{0x9016c,0x109},
+	{0x9016d,0xf},
+	{0x9016e,0x7c0},
+	{0x9016f,0x109},
+	{0x90170,0x0},
+	{0x90171,0xe8},
+	{0x90172,0x109},
+	{0x90173,0x47},
+	{0x90174,0x630},
+	{0x90175,0x109},
+	{0x90176,0x8},
+	{0x90177,0x618},
+	{0x90178,0x109},
+	{0x90179,0x8},
+	{0x9017a,0xe0},
+	{0x9017b,0x109},
+	{0x9017c,0x0},
+	{0x9017d,0x7c8},
+	{0x9017e,0x109},
+	{0x9017f,0x8},
+	{0x90180,0x8140},
+	{0x90181,0x10c},
+	{0x90182,0x0},
+	{0x90183,0x1},
+	{0x90184,0x8},
+	{0x90185,0x8},
+	{0x90186,0x4},
+	{0x90187,0x8},
+	{0x90188,0x8},
+	{0x90189,0x7c8},
+	{0x9018a,0x101},
+	{0x90006,0x0},
+	{0x90007,0x0},
+	{0x90008,0x8},
+	{0x90009,0x0},
+	{0x9000a,0x0},
+	{0x9000b,0x0},
+	{0xd00e7,0x400},
+	{0x90017,0x0},
+	{0x9001f,0x2a},
+	{0x90026,0x6a},
+	{0x400d0,0x0},
+	{0x400d1,0x101},
+	{0x400d2,0x105},
+	{0x400d3,0x107},
+	{0x400d4,0x10f},
+	{0x400d5,0x202},
+	{0x400d6,0x20a},
+	{0x400d7,0x20b},
+	{0x2003a,0x2},
+	{0x2000b,0x5d},
+	{0x2000c,0xbb},
+	{0x2000d,0x753},
+	{0x2000e,0x2c},
+	{0x12000b,0xc},
+	{0x12000c,0x19},
+	{0x12000d,0xfa},
+	{0x12000e,0x10},
+	{0x22000b,0x3},
+	{0x22000c,0x6},
+	{0x22000d,0x3e},
+	{0x22000e,0x10},
+	{0x9000c,0x0},
+	{0x9000d,0x173},
+	{0x9000e,0x60},
+	{0x9000f,0x6110},
+	{0x90010,0x2152},
+	{0x90011,0xdfbd},
+	{0x90012,0x60},
+	{0x90013,0x6152},
+	{0x20010,0x5a},
+	{0x20011,0x3},
+	{0x120010,0x5a},
+	{0x120011,0x3},
+	{0x220010,0x5a},
+	{0x220011,0x3},
+	{0x40080,0xe0},
+	{0x40081,0x12},
+	{0x40082,0xe0},
+	{0x40083,0x12},
+	{0x40084,0xe0},
+	{0x40085,0x12},
+	{0x140080,0xe0},
+	{0x140081,0x12},
+	{0x140082,0xe0},
+	{0x140083,0x12},
+	{0x140084,0xe0},
+	{0x140085,0x12},
+	{0x240080,0xe0},
+	{0x240081,0x12},
+	{0x240082,0xe0},
+	{0x240083,0x12},
+	{0x240084,0xe0},
+	{0x240085,0x12},
+	{0x400fd,0xf},
+	{0x10011,0x1},
+	{0x10012,0x1},
+	{0x10013,0x180},
+	{0x10018,0x1},
+	{0x10002,0x6209},
+	{0x100b2,0x1},
+	{0x101b4,0x1},
+	{0x102b4,0x1},
+	{0x103b4,0x1},
+	{0x104b4,0x1},
+	{0x105b4,0x1},
+	{0x106b4,0x1},
+	{0x107b4,0x1},
+	{0x108b4,0x1},
+	{0x11011,0x1},
+	{0x11012,0x1},
+	{0x11013,0x180},
+	{0x11018,0x1},
+	{0x11002,0x6209},
+	{0x110b2,0x1},
+	{0x111b4,0x1},
+	{0x112b4,0x1},
+	{0x113b4,0x1},
+	{0x114b4,0x1},
+	{0x115b4,0x1},
+	{0x116b4,0x1},
+	{0x117b4,0x1},
+	{0x118b4,0x1},
+	{0x12011,0x1},
+	{0x12012,0x1},
+	{0x12013,0x180},
+	{0x12018,0x1},
+	{0x12002,0x6209},
+	{0x120b2,0x1},
+	{0x121b4,0x1},
+	{0x122b4,0x1},
+	{0x123b4,0x1},
+	{0x124b4,0x1},
+	{0x125b4,0x1},
+	{0x126b4,0x1},
+	{0x127b4,0x1},
+	{0x128b4,0x1},
+	{0x13011,0x1},
+	{0x13012,0x1},
+	{0x13013,0x180},
+	{0x13018,0x1},
+	{0x13002,0x6209},
+	{0x130b2,0x1},
+	{0x131b4,0x1},
+	{0x132b4,0x1},
+	{0x133b4,0x1},
+	{0x134b4,0x1},
+	{0x135b4,0x1},
+	{0x136b4,0x1},
+	{0x137b4,0x1},
+	{0x138b4,0x1},
+	{0x2003a,0x2},
+	{0xc0080,0x2},
+	{0xd0000, 0x1}
+};
+
+struct dram_fsp_msg ddr_dram_fsp_msg[] = {
+	{
+		/* P0 3000mts 1D */
+		.drate = 3000,
+		.fw_type = FW_1D_IMAGE,
+		.fsp_cfg = ddr_fsp0_cfg,
+		.fsp_cfg_num = ARRAY_SIZE(ddr_fsp0_cfg),
+	},
+	{
+		/* P1 400mts 1D */
+		.drate = 400,
+		.fw_type = FW_1D_IMAGE,
+		.fsp_cfg = ddr_fsp1_cfg,
+		.fsp_cfg_num = ARRAY_SIZE(ddr_fsp1_cfg),
+	},
+	{
+		/* P2 100mts 1D */
+		.drate = 100,
+		.fw_type = FW_1D_IMAGE,
+		.fsp_cfg = ddr_fsp2_cfg,
+		.fsp_cfg_num = ARRAY_SIZE(ddr_fsp2_cfg),
+	},
+	{
+		/* P0 3000mts 2D */
+		.drate = 3000,
+		.fw_type = FW_2D_IMAGE,
+		.fsp_cfg = ddr_fsp0_2d_cfg,
+		.fsp_cfg_num = ARRAY_SIZE(ddr_fsp0_2d_cfg),
+	},
+};
+
+/* ddr timing config params */
+struct dram_timing_info dram_timing = {
+	.ddrc_cfg = ddr_ddrc_cfg,
+	.ddrc_cfg_num = ARRAY_SIZE(ddr_ddrc_cfg),
+	.ddrphy_cfg = ddr_ddrphy_cfg,
+	.ddrphy_cfg_num = ARRAY_SIZE(ddr_ddrphy_cfg),
+	.fsp_msg = ddr_dram_fsp_msg,
+	.fsp_msg_num = ARRAY_SIZE(ddr_dram_fsp_msg),
+	.ddrphy_trained_csr = ddr_ddrphy_trained_csr,
+	.ddrphy_trained_csr_num = ARRAY_SIZE(ddr_ddrphy_trained_csr),
+	.ddrphy_pie = ddr_phy_pie,
+	.ddrphy_pie_num = ARRAY_SIZE(ddr_phy_pie),
+	.fsp_table = { 3000, 400, 100, },
+};
+
diff --git a/board/seco/seco_imx8mm_c61/mmc.c b/board/seco/seco_imx8mm_c61/mmc.c
new file mode 100644
index 0000000000..3a490695f1
--- /dev/null
+++ b/board/seco/seco_imx8mm_c61/mmc.c
@@ -0,0 +1,57 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright (C) 2016 Freescale Semiconductor, Inc.
+ * Copyright 2018 NXP
+ */
+#include <common.h>
+#include <command.h>
+#include <env.h>
+#include <asm/arch/sys_proto.h>
+#include <linux/errno.h>
+#include <asm/io.h>
+#include <stdbool.h>
+#include <mmc.h>
+
+static int check_mmc_autodetect(void)
+{
+	char *autodetect_str = env_get("mmcautodetect");
+
+	if ((autodetect_str != NULL) &&
+		(strcmp(autodetect_str, "yes") == 0)) {
+		return 1;
+	}
+
+	return 0;
+}
+
+/* This should be defined for each board */
+__weak int mmc_map_to_kernel_blk(int dev_no)
+{
+	return dev_no;
+}
+
+void board_late_mmc_env_init(void)
+{
+	char cmd[32];
+	char mmcblk[32];
+	u32 dev_no = mmc_get_env_dev();
+
+	if (!check_mmc_autodetect())
+		return;
+
+	env_set_ulong("mmcdev", dev_no);
+
+	env_set_ulong ("root_device_id", dev_no);
+	env_set_ulong ("kernel_device_id", dev_no);
+	env_set_ulong ("bootscript_device_id", dev_no);
+	env_set_ulong ("fdt_device_id", dev_no);
+	env_set_ulong ("ramfs_device_id", dev_no);
+
+	/* Set mmcblk env */
+	sprintf(mmcblk, "/dev/mmcblk%dp2 rootwait rw",
+		mmc_map_to_kernel_blk(dev_no));
+	env_set("mmcroot", mmcblk);
+
+	sprintf(cmd, "mmc dev %d", dev_no);
+	run_command(cmd, 0);
+}
diff --git a/board/seco/seco_imx8mm_c61/seco_imx8mm_c61.c b/board/seco/seco_imx8mm_c61/seco_imx8mm_c61.c
new file mode 100644
index 0000000000..ccd1047bba
--- /dev/null
+++ b/board/seco/seco_imx8mm_c61/seco_imx8mm_c61.c
@@ -0,0 +1,390 @@
+/*
+ * Copyright 2018 NXP
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <errno.h>
+#include <asm/io.h>
+#include <init.h>
+#include <miiphy.h>
+#include <netdev.h>
+#include <asm/mach-imx/iomux-v3.h>
+#include <fsl_esdhc.h>
+#include <mmc.h>
+#include <asm/arch/imx8mm_pins.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/mach-imx/boot_mode.h>
+#include <asm/mach-imx/dma.h>
+#include <asm/mach-imx/gpio.h>
+#include <asm/mach-imx/mxc_i2c.h>
+#include <asm/mach-imx/video.h>
+#include <asm/arch/clock.h>
+#include <spl.h>
+#include <power/pmic.h>
+#include <power/bd71837.h>
+#include <usb.h>
+#include <dsi_host.h>
+#include <video_bridge.h>
+#include <panel.h>
+#include <linux/delay.h>
+#ifdef CONFIG_APX_WATCHDOG
+#include "wdt.h"
+#endif
+#include "tcpc.h"
+#include "seco_imx8mm_c61_setup.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define UART_PAD_CTRL	(PAD_CTL_DSE6 | PAD_CTL_FSEL1)
+#define WDOG_PAD_CTRL	(PAD_CTL_DSE6 | PAD_CTL_ODE | PAD_CTL_PUE | PAD_CTL_PE)
+
+#define IOMUXC_GPR_GPR1_GPR_ENET1_TX_CLK_SEL_SHIFT 13
+
+static iomux_v3_cfg_t const uart_pads[] = {
+	IMX8MM_PAD_UART2_RXD_UART2_RX | MUX_PAD_CTRL(UART_PAD_CTRL),
+	IMX8MM_PAD_UART2_TXD_UART2_TX | MUX_PAD_CTRL(UART_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const wdog_pads[] = {
+	IMX8MM_PAD_GPIO1_IO02_WDOG1_WDOG_B | MUX_PAD_CTRL(WDOG_PAD_CTRL),
+	IMX8MM_PAD_SAI5_RXD0_GPIO3_IO21 | MUX_PAD_CTRL(WDOG_PAD_CTRL),
+	IMX8MM_PAD_SAI5_RXD1_GPIO3_IO22 | MUX_PAD_CTRL(WDOG_PAD_CTRL),
+	IMX8MM_PAD_SAI1_TXC_GPIO4_IO11  | MUX_PAD_CTRL(WDOG_PAD_CTRL), // WDG DISABLED
+};
+
+static iomux_v3_cfg_t const pca6416_pads[] = {
+        IMX8MM_PAD_SAI2_RXFS_GPIO4_IO21 | MUX_PAD_CTRL(PAD_CTL_PE | PAD_CTL_PUE),
+	IMX8MM_PAD_SAI2_RXC_GPIO4_IO22 | MUX_PAD_CTRL(0x0),
+};
+
+static iomux_v3_cfg_t const usb_hub_pads[] = {
+        IMX8MM_PAD_SAI1_RXD4_GPIO4_IO6 | MUX_PAD_CTRL(PAD_CTL_PE | PAD_CTL_PUE),
+        IMX8MM_PAD_SAI1_RXD0_GPIO4_IO2 | MUX_PAD_CTRL(PAD_CTL_PE | PAD_CTL_PUE),
+};
+
+static iomux_v3_cfg_t const video_disable_pads[] = {
+        IMX8MM_PAD_GPIO1_IO11_GPIO1_IO11 | MUX_PAD_CTRL(PAD_CTL_PE | PAD_CTL_PUE),
+	IMX8MM_PAD_SAI1_RXD2_GPIO4_IO4 | MUX_PAD_CTRL(PAD_CTL_PE | PAD_CTL_PUE),
+	IMX8MM_PAD_SAI1_RXD3_GPIO4_IO5 | MUX_PAD_CTRL(PAD_CTL_PE | PAD_CTL_PUE),
+};
+
+void pca6416_reset ( void ) {
+	
+	gpio_request(IMX_GPIO_NR(4, 21), "PCA6416_RST");	
+	gpio_direction_output(IMX_GPIO_NR(4, 21), 1);
+
+}
+
+void usb_hub_init ( void ) {
+	
+	imx_iomux_v3_setup_multiple_pads(usb_hub_pads, ARRAY_SIZE(usb_hub_pads));
+
+	gpio_request(IMX_GPIO_NR(4, 2), "USB_HUB_RST");	
+
+	gpio_direction_output(IMX_GPIO_NR(4, 2), 0);
+
+}
+
+void video_bridge_disable ( void ) {
+
+	struct gpio_desc desc_lcd, desc_bkl;
+	int ret;
+
+	imx_iomux_v3_setup_multiple_pads(video_disable_pads, ARRAY_SIZE(video_disable_pads));	
+
+	gpio_request(IMX_GPIO_NR(1, 11), "PD-BRIDGE");
+	gpio_request(IMX_GPIO_NR(4, 4), "BKL_ON");
+	gpio_request(IMX_GPIO_NR(4, 5), "PANEL_ON");
+	gpio_direction_output(IMX_GPIO_NR(1, 11), 0);
+	gpio_direction_output(IMX_GPIO_NR(4, 4), 0);
+	gpio_direction_output(IMX_GPIO_NR(4, 5), 0);
+
+
+	ret = dm_gpio_lookup_name("gpio@20_5", &desc_lcd);
+	if(ret)
+		printf("Error requesting gpio@20_5");
+
+	ret = dm_gpio_lookup_name("gpio@20_9", &desc_bkl);
+	if(ret)
+		printf("Error requesting gpio@20_9");
+
+	ret = dm_gpio_request(&desc_lcd, "gpio20_lcd");
+	if(ret)
+		printf("Error configuring gpio@20_5");
+
+	ret = dm_gpio_request(&desc_bkl, "gpio20_bkl");
+	if(ret)
+		printf("Error configuring gpio@20_9");
+
+
+	dm_gpio_set_dir_flags(&desc_lcd, GPIOD_IS_OUT);
+	dm_gpio_set_value(&desc_lcd, 0);
+
+	dm_gpio_set_dir_flags(&desc_bkl, GPIOD_IS_OUT);
+	dm_gpio_set_value(&desc_bkl, 0);
+}
+
+#if 0
+#ifdef CONFIG_FSL_FSPI
+
+int board_qspi_init(void)
+{
+
+	set_clk_qspi();
+
+	return 0;
+}
+#endif
+#endif
+
+#ifdef CONFIG_NAND_MXS
+#ifdef CONFIG_SPL_BUILD
+#define NAND_PAD_CTRL	(PAD_CTL_DSE6 | PAD_CTL_FSEL2 | PAD_CTL_HYS)
+#define NAND_PAD_READY0_CTRL (PAD_CTL_DSE6 | PAD_CTL_FSEL2 | PAD_CTL_PUE)
+static iomux_v3_cfg_t const gpmi_pads[] = {
+	IMX8MM_PAD_NAND_ALE_RAWNAND_ALE | MUX_PAD_CTRL(NAND_PAD_CTRL),
+	IMX8MM_PAD_NAND_CE0_B_RAWNAND_CE0_B | MUX_PAD_CTRL(NAND_PAD_CTRL),
+	IMX8MM_PAD_NAND_CE1_B_RAWNAND_CE1_B | MUX_PAD_CTRL(NAND_PAD_CTRL),
+	IMX8MM_PAD_NAND_CLE_RAWNAND_CLE | MUX_PAD_CTRL(NAND_PAD_CTRL),
+	IMX8MM_PAD_NAND_DATA00_RAWNAND_DATA00 | MUX_PAD_CTRL(NAND_PAD_CTRL),
+	IMX8MM_PAD_NAND_DATA01_RAWNAND_DATA01 | MUX_PAD_CTRL(NAND_PAD_CTRL),
+	IMX8MM_PAD_NAND_DATA02_RAWNAND_DATA02 | MUX_PAD_CTRL(NAND_PAD_CTRL),
+	IMX8MM_PAD_NAND_DATA03_RAWNAND_DATA03 | MUX_PAD_CTRL(NAND_PAD_CTRL),
+	IMX8MM_PAD_NAND_DATA04_RAWNAND_DATA04 | MUX_PAD_CTRL(NAND_PAD_CTRL),
+	IMX8MM_PAD_NAND_DATA05_RAWNAND_DATA05	| MUX_PAD_CTRL(NAND_PAD_CTRL),
+	IMX8MM_PAD_NAND_DATA06_RAWNAND_DATA06	| MUX_PAD_CTRL(NAND_PAD_CTRL),
+	IMX8MM_PAD_NAND_DATA07_RAWNAND_DATA07	| MUX_PAD_CTRL(NAND_PAD_CTRL),
+	IMX8MM_PAD_NAND_RE_B_RAWNAND_RE_B | MUX_PAD_CTRL(NAND_PAD_CTRL),
+	IMX8MM_PAD_NAND_READY_B_RAWNAND_READY_B | MUX_PAD_CTRL(NAND_PAD_READY0_CTRL),
+	IMX8MM_PAD_NAND_WE_B_RAWNAND_WE_B | MUX_PAD_CTRL(NAND_PAD_CTRL),
+	IMX8MM_PAD_NAND_WP_B_RAWNAND_WP_B | MUX_PAD_CTRL(NAND_PAD_CTRL),
+};
+#endif
+
+static void setup_gpmi_nand(void)
+{
+#ifdef CONFIG_SPL_BUILD
+	imx_iomux_v3_setup_multiple_pads(gpmi_pads, ARRAY_SIZE(gpmi_pads));
+#endif
+	init_nand_clk();
+}
+#endif
+
+int board_early_init_f(void)
+{
+	struct wdog_regs *wdog = (struct wdog_regs *)WDOG1_BASE_ADDR;
+
+	imx_iomux_v3_setup_multiple_pads(wdog_pads, ARRAY_SIZE(wdog_pads));
+
+	set_wdog_reset(wdog);
+
+	// DISABLE WDG 
+	gpio_request(IMX_GPIO_NR(4, 11), "DISABLE_WDG");	
+	gpio_direction_output(IMX_GPIO_NR(4, 11), 0);
+
+
+	imx_iomux_v3_setup_multiple_pads(uart_pads, ARRAY_SIZE(uart_pads));
+
+	init_uart_clk(1);
+
+#ifdef CONFIG_NAND_MXS
+	setup_gpmi_nand(); /* SPL will call the board_early_init_f */
+#endif
+
+	imx_iomux_v3_setup_multiple_pads(pca6416_pads, ARRAY_SIZE(pca6416_pads));
+	
+	pca6416_reset();	
+
+	usb_hub_init();
+
+	return 0;
+}
+
+int board_phys_sdram_size(phys_size_t *size)
+{
+	if (!size)
+		return -EINVAL;
+
+	if(C61_IS_1GB)
+                *size = PHYS_DRAM_IS_1GB ;
+        if(C61_IS_2GB)
+                *size = PHYS_DRAM_IS_2GB ;
+        if(C61_IS_4GB)
+                *size = PHYS_DRAM_IS_3GB ;
+
+	return 0;
+}
+
+#ifdef CONFIG_OF_BOARD_SETUP
+int ft_board_setup(void *blob, struct bd_info *bd)
+{
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_FEC_MXC
+
+static void setup_iomux_fec(void)
+{
+
+	struct gpio_desc desc_enet0;
+        int ret;
+
+	ret = dm_gpio_lookup_name("gpio@20_12", &desc_enet0);
+	if(ret)	
+		printf("Error requesting gpio@20_12");
+
+	ret = dm_gpio_request(&desc_enet0, "gpio20_ethrst");
+	if(ret)
+                printf("Error configuring gpio@20_12");
+
+	dm_gpio_set_dir_flags(&desc_enet0, GPIOD_IS_OUT);	
+	dm_gpio_set_value(&desc_enet0, 0);
+	udelay(500);
+	dm_gpio_set_value(&desc_enet0, 1);
+}
+
+static int setup_fec(void)
+{
+	struct iomuxc_gpr_base_regs *const iomuxc_gpr_regs
+		= (struct iomuxc_gpr_base_regs *) IOMUXC_GPR_BASE_ADDR;
+
+	//setup_iomux_fec();
+
+	/* Use 125M anatop REF_CLK1 for ENET1, not from external */
+	clrsetbits_le32(&iomuxc_gpr_regs->gpr[1],
+			IOMUXC_GPR_GPR1_GPR_ENET1_TX_CLK_SEL_SHIFT, 0);
+	return set_clk_enet(ENET_125MHZ);
+}
+
+int board_phy_config(struct phy_device *phydev)
+{
+	/* enable rgmii rxc skew and phy mode select to RGMII copper */
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x1f);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, 0x8);
+
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x00);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, 0x82ee);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x05);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, 0x100);
+
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+	return 0;
+}
+#endif
+
+
+#ifdef CONFIG_USB_EHCI_HCD
+int board_usb_init(int index, enum usb_init_type init)
+{
+        int ret = 0;
+#ifdef CONFIG_USB_TCPC
+        struct tcpc_port *port_ptr;
+#endif
+
+        debug("board_usb_init %d, type %d\n", index, init);
+
+        imx8m_usb_power(index, true);
+
+#ifdef CONFIG_USB_TCPC
+        if (index == 0)
+                port_ptr = &port1;
+        else
+                port_ptr = &port2;
+
+        if (init == USB_INIT_HOST)
+                tcpc_setup_dfp_mode(port_ptr);
+        else
+                tcpc_setup_ufp_mode(port_ptr);
+#endif
+
+        return ret;
+}
+
+int board_usb_cleanup(int index, enum usb_init_type init)
+{
+        int ret = 0;
+
+        debug("board_usb_cleanup %d, type %d\n", index, init);
+
+#ifdef CONFIG_USB_TCPC
+        if (init == USB_INIT_HOST) {
+                if (index == 0)
+                        ret = tcpc_disable_src_vbus(&port1);
+                else
+                        ret = tcpc_disable_src_vbus(&port2);
+        }
+#endif
+
+        imx8m_usb_power(index, false);
+        return ret;
+}
+
+#ifdef CONFIG_USB_TCPC
+int board_ehci_usb_phy_mode(struct udevice *dev)
+{
+        int ret = 0;
+        enum typec_cc_polarity pol;
+        enum typec_cc_state state;
+        struct tcpc_port *port_ptr;
+
+        if (dev->seq == 0)
+                port_ptr = &port1;
+        else
+                port_ptr = &port2;
+
+        tcpc_setup_ufp_mode(port_ptr);
+
+        ret = tcpc_get_cc_status(port_ptr, &pol, &state);
+        if (!ret) {
+                if (state == TYPEC_STATE_SRC_RD_RA || state == TYPEC_STATE_SRC_RD)
+                        return USB_INIT_HOST;
+        }
+
+        return USB_INIT_DEVICE;
+}
+#endif
+#endif
+
+
+int board_init(void)
+{
+#ifdef CONFIG_USB_TCPC
+	setup_typec();
+#endif
+
+#ifdef CONFIG_FEC_MXC
+	setup_fec();
+#endif
+
+#if 0
+#ifdef CONFIG_FSL_FSPI
+	board_qspi_init();
+#endif
+#endif
+
+	video_bridge_disable();
+
+	return 0;
+}
+
+int board_late_init(void)
+{
+#ifdef CONFIG_ENV_IS_IN_MMC
+	board_late_mmc_env_init();
+#endif
+	return 0;
+}
+
+int board_mmc_get_env_dev(int devno)
+{
+	if (get_boot_device() == MMC3_BOOT)
+		return 0;
+
+	return devno;
+}
+
diff --git a/board/seco/seco_imx8mm_c61/seco_imx8mm_c61_setup.c b/board/seco/seco_imx8mm_c61/seco_imx8mm_c61_setup.c
new file mode 100644
index 0000000000..3064d03e25
--- /dev/null
+++ b/board/seco/seco_imx8mm_c61/seco_imx8mm_c61_setup.c
@@ -0,0 +1,251 @@
+/*
+ *
+ * Reading C61 Board type
+ *
+ * marco.sandrelli@seco.com
+ *
+ *
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <errno.h>
+#include <asm/io.h>
+#include <miiphy.h>
+#include <netdev.h>
+#include <asm/mach-imx/iomux-v3.h>
+#include <asm-generic/gpio.h>
+#include <fsl_esdhc.h>
+#include <mmc.h>
+#include <asm/arch/imx8mm_pins.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/mach-imx/gpio.h>
+#include "seco_imx8mm_c61_setup.h"
+
+#define PULLUP_PAD_CTRL  (PAD_CTL_PUE )
+
+#define C61_IOMUX_REG(x)        ((x))
+#define C61_PADCTRL_REG(x)      ((x))
+#define C61_GDIR_REG_IN(x,n)    writel((readl(x + 0x4)) & ~(1<<n), x + 0x4 )
+#define C61_PSR_REG(x,n)	(readl(x + 0x8) & (1<<n))
+
+#define shift_0                 0
+#define shift_1                 1
+#define shift_2                 2
+#define shift_3                 3
+
+#define GPIO4_PAD_BASE		 0x30230000
+/* RAM straps */
+#define GPIO_CFG_0              0
+#define GPIO_CFG_1              1
+/* HDMI straps */
+#define GPIO_CFG_2              17
+/* Wilink Strap */
+#define GPIO_CFG_3		 13
+
+#define GPIO1_PAD_BASE          0x30200000
+#define GPIO4_PAD_BASE          0x30230000
+#define GPIO_CFG_4              15
+#define GPIO_CFG_5              22
+#define GPIO_CFG_6              21
+#define GPIO_CFG_7              0
+
+/* Quad - Quad Lite Strap */
+#define GPIO_CFG_8              5
+/* SPI - CAN RTC Strap */
+#define GPIO_CFG_9              29
+
+struct sizes {
+	u32 s0;
+	u32 s1;
+};
+
+DECLARE_GLOBAL_DATA_PTR;
+
+iomux_v3_cfg_t const board_conf_pads[] = {
+
+        /* RAM CONFIG */
+        IMX8MM_PAD_SAI1_RXFS_GPIO4_IO0	| MUX_PAD_CTRL(PULLUP_PAD_CTRL),   /* cfg_0 */
+        IMX8MM_PAD_SAI1_RXC_GPIO4_IO1	| MUX_PAD_CTRL(PULLUP_PAD_CTRL),   /* cfg_1 */
+
+};
+
+
+int c61_get_board_configuration ( void ) {
+
+        ulong value = 0;
+
+	/* 
+         *
+         * CFG code is composed in this way:
+         * cfg_0 -> first bit   X 
+         * cfg_1 -> second bit  X
+         * cfg_2 -> third bit   X
+         *  
+         */
+	
+	imx_iomux_v3_setup_multiple_pads(board_conf_pads, ARRAY_SIZE(board_conf_pads));
+
+	/* Mux as Input */
+	C61_GDIR_REG_IN(GPIO4_PAD_BASE,GPIO_CFG_0);
+	C61_GDIR_REG_IN(GPIO4_PAD_BASE,GPIO_CFG_1);
+
+	/* Read Conf value */
+	value = (C61_PSR_REG(GPIO4_PAD_BASE,GPIO_CFG_0) >> GPIO_CFG_0) << shift_0 | 
+		(C61_PSR_REG(GPIO4_PAD_BASE,GPIO_CFG_1) >> GPIO_CFG_1) << shift_1 ; 
+
+        return value;
+
+}
+
+int c61_get_configuration_port1 ( void ) {
+	
+	struct gpio_desc desc_enet8;
+        struct gpio_desc desc_enet9;
+	int ret, value_sum;
+
+	ret = dm_gpio_lookup_name("gpio@21_8", &desc_enet8);
+        if (ret)
+                return -1;
+
+        ret = dm_gpio_lookup_name("gpio@21_9", &desc_enet9);
+        if (ret)
+                return -1;
+
+	ret = dm_gpio_request(&desc_enet8, "gpio21_cfg0");
+        if (ret)
+                return -1;
+
+        ret = dm_gpio_request(&desc_enet9, "gpio21_cfg1");
+        if (ret)
+                return -1;
+
+	dm_gpio_set_dir_flags(&desc_enet8, GPIOD_IS_IN);
+	dm_gpio_set_dir_flags(&desc_enet9, GPIOD_IS_IN);
+
+	value_sum = dm_gpio_get_value(&desc_enet8)  | dm_gpio_get_value(&desc_enet9) << 1;
+
+	ret = dm_gpio_free((desc_enet8.dev),&desc_enet8);
+        if (ret)
+                return -1;
+
+        ret = dm_gpio_free((desc_enet9.dev), &desc_enet9);
+        if (ret)
+                return -1;
+
+
+        //printf("PCA953x cfg port1 = 0x%x\n",value_sum);
+
+        return value_sum;
+
+}
+
+int c61_get_configuration_port2 ( void ) {
+	
+	struct gpio_desc desc_enet10;
+        struct gpio_desc desc_enet11;
+	int ret, value_sum;
+
+	ret = dm_gpio_lookup_name("gpio@21_10", &desc_enet10);
+        if (ret)
+                return -1;
+
+        ret = dm_gpio_lookup_name("gpio@21_11", &desc_enet11);
+        if (ret)
+                return -1;
+
+	ret = dm_gpio_request(&desc_enet10, "gpio21_cfg2");
+        if (ret)
+                return -1;
+
+        ret = dm_gpio_request(&desc_enet11, "gpio21_cfg3");
+        if (ret)
+                return -1;
+
+	dm_gpio_set_dir_flags(&desc_enet10, GPIOD_IS_IN);
+	dm_gpio_set_dir_flags(&desc_enet11, GPIOD_IS_IN);
+
+	value_sum = dm_gpio_get_value(&desc_enet10)  | dm_gpio_get_value(&desc_enet11) << 1;
+
+	ret = dm_gpio_free((desc_enet10.dev), &desc_enet10);
+        if (ret)
+                return -1;
+
+        ret = dm_gpio_free((desc_enet11.dev), &desc_enet11);
+        if (ret)
+                return -1;
+
+	//printf("PCA953x cfg port2 = 0x%x\n",value_sum);
+
+        return value_sum;
+
+}
+
+int c61_get_configuration_video ( void ) {
+
+        struct gpio_desc desc_enet3;
+        struct gpio_desc desc_enet4;
+        int ret, value_sum;
+
+        ret = dm_gpio_lookup_name("gpio@21_3", &desc_enet3);
+        if (ret)
+                return -1;
+
+        ret = dm_gpio_lookup_name("gpio@21_4", &desc_enet4);
+        if (ret)
+                return -1;
+
+        ret = dm_gpio_request(&desc_enet4, "gpio21_cfg13");
+        if (ret)
+                return -1;
+
+        ret = dm_gpio_request(&desc_enet3, "gpio21_cfg14");
+        if (ret)
+                return -1;
+
+        dm_gpio_set_dir_flags(&desc_enet3, GPIOD_IS_IN);
+        dm_gpio_set_dir_flags(&desc_enet4, GPIOD_IS_IN);
+
+        value_sum = dm_gpio_get_value(&desc_enet4)  | dm_gpio_get_value(&desc_enet3) << 1;
+
+	ret = dm_gpio_free((desc_enet4.dev), &desc_enet4);
+        if (ret)
+                return -1;
+
+        ret = dm_gpio_free((desc_enet3.dev), &desc_enet3);
+        if (ret)
+                return -1;
+
+	//printf("PCA953x cfg video = 0x%x\n",value_sum);
+
+        return value_sum;
+
+}
+
+int c61_get_configuration_modem ( void ) {
+
+        struct gpio_desc desc_enet6;
+        int ret, value_sum;
+
+
+        ret = dm_gpio_lookup_name("gpio@21_6", &desc_enet6);
+        if (ret)
+                return -1;
+
+        ret = dm_gpio_request(&desc_enet6, "gpio21_cfg11");
+        if (ret)
+                return -1;
+
+        dm_gpio_set_dir_flags(&desc_enet6, GPIOD_IS_IN);
+
+        value_sum = dm_gpio_get_value(&desc_enet6);
+
+        ret = dm_gpio_free((desc_enet6.dev), &desc_enet6);
+        if (ret)
+                return -1;
+
+	//printf("PCA953x cfg modem = 0x%x\n",value_sum);
+
+        return value_sum;
+
+}
diff --git a/board/seco/seco_imx8mm_c61/seco_imx8mm_c61_setup.h b/board/seco/seco_imx8mm_c61/seco_imx8mm_c61_setup.h
new file mode 100644
index 0000000000..0ec520ae1b
--- /dev/null
+++ b/board/seco/seco_imx8mm_c61/seco_imx8mm_c61_setup.h
@@ -0,0 +1,73 @@
+#ifndef _C61_REVISION_H_
+#define _C61_REVISION_H_
+
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/crm_regs.h>
+#include <common.h>
+#include <malloc.h>
+#include <errno.h>
+#include <asm/io.h>
+#include <miiphy.h>
+#include <netdev.h>
+#include <asm/mach-imx/iomux-v3.h>
+
+#include <linux/libfdt.h>
+/*
+ *      This typedef must be matched with:
+ *              overlay_video_mode_list[]
+ *              overlay_addons_list[]
+ *      in env_conf.c files 
+ *
+*/
+
+typedef enum {
+	NO_VIDEO = 0,
+	EDP_VIDEO,
+	LVDS_VIDEO,
+	LVDS_LEDRIVER_VIDEO,
+	NUM_VIDEO_MODES,
+} VIDEO_MODES;
+
+typedef enum  {
+	GPIO_OPT = 0,
+	RS232_OPT,
+	RS485_OPT,
+	CAN_OPT,
+	NUM_ADDONS,
+} ADDONS;
+
+#define BOOT_DEV_ID_EMMC      __stringify(BOOT_ID_EMMC)"\0"
+#define BOOT_DEV_ID_U_SD      __stringify(BOOT_ID_USD)"\0"
+#define BOOT_DEV_ID_EXT_SD    __stringify(BOOT_ID_EXT_SD)"\0"
+#define BOOT_DEV_ID_SPI       "0"
+#define BOOT_DEV_ID_SATA      "0"
+#define BOOT_DEV_ID_USB       "0"
+
+#define ROOT_DEV_ID_EMMC      __stringify(ROOT_ID_EMMC)"\0"
+#define ROOT_DEV_ID_U_SD      __stringify(ROOT_ID_USD)"\0"
+#define ROOT_DEV_ID_EXT_SD    __stringify(ROOT_ID_EXT_SD)"\0"
+
+void c61_fdt_ram_setup(void *blob, struct bd_info *bdev);
+void c61_fdt_vpu_setup(void *blob, struct bd_info *bdev);
+void c61_fdt_pcie_setup(void *blob, struct bd_info *bdev);
+int c61_get_board_configuration (void);
+int c61_get_configuration_port1 (void);
+int c61_get_configuration_port2 (void);
+int c61_get_configuration_video (void);
+int c61_get_configuration_modem (void);
+
+int c61_get_hw_revision ( void );
+int c61_get_q_ql ( void );
+int c61_get_spi_canrtc ( void );
+int c61_get_pcie ( void );
+
+
+#define C61_IS_1GB	((!(c61_get_board_configuration() & 0x1)) & (!((c61_get_board_configuration() & 0x2)>>1)))
+#define C61_IS_2GB	(((c61_get_board_configuration() & 0x2)>>1) & ~(c61_get_board_configuration() & 0x1))
+#define C61_IS_4GB      ((c61_get_board_configuration() & 0x1) & (c61_get_board_configuration() & 0x2)>>1)
+
+#define C61_GET_CONF_PORT1	c61_get_configuration_port1()
+#define C61_GET_CONF_PORT2	c61_get_configuration_port2()
+#define C61_GET_CONF_VIDEO	c61_get_configuration_video()
+#define C61_MODEM_IS_PRESENT	(c61_get_configuration_modem() & 0x1)
+#endif
diff --git a/board/seco/seco_imx8mm_c61/spl.c b/board/seco/seco_imx8mm_c61/spl.c
new file mode 100644
index 0000000000..02dc2f5d70
--- /dev/null
+++ b/board/seco/seco_imx8mm_c61/spl.c
@@ -0,0 +1,324 @@
+/*
+ * Copyright 2018 NXP
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <spl.h>
+#include <asm/io.h>
+#include <hang.h>
+#include <init.h>
+#include <errno.h>
+#include <i2c.h>
+#include <asm/io.h>
+#include <asm/mach-imx/iomux-v3.h>
+#include <asm/arch/imx8mm_pins.h>
+#include <asm/arch/sys_proto.h>
+#include <power/pmic.h>
+#include <power/bd71837.h>
+#include <asm/arch/clock.h>
+#include <asm/mach-imx/gpio.h>
+#include <asm/mach-imx/mxc_i2c.h>
+#include <fsl_esdhc_imx.h>
+#include <mmc.h>
+#include <asm/arch/ddr.h>
+#include "seco_imx8mm_c61_setup.h"
+
+#include <asm/mach-imx/boot_mode.h>
+#include <linux/delay.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+
+int spl_board_boot_device(enum boot_device boot_dev_spl)
+{
+	switch (boot_dev_spl) {
+	case SD2_BOOT:
+	case MMC2_BOOT:
+		return BOOT_DEVICE_MMC1;
+	case SD3_BOOT:
+	case MMC3_BOOT:
+		return BOOT_DEVICE_MMC2;
+	case QSPI_BOOT:
+		return BOOT_DEVICE_NOR;
+	case NAND_BOOT:
+		return BOOT_DEVICE_NAND;
+	case USB_BOOT:
+		return BOOT_DEVICE_BOARD;
+	default:
+		return BOOT_DEVICE_NONE;
+	}
+}
+
+void spl_dram_init(void)
+{
+	if(C61_IS_1GB) {
+		printf("C61 is 1GB\n");
+		 /* DDR Parameter */
+                dram_timing.ddrc_cfg[5].val = 0x5b0087;
+                dram_timing.ddrc_cfg[21].val = 0x8d;
+                dram_timing.ddrc_cfg[34].val = 0x1;
+                dram_timing.ddrc_cfg[42].val = 0xf070707;
+                dram_timing.ddrc_cfg[57].val = 0xc0012;
+                dram_timing.ddrc_cfg[72].val = 0x13;
+                dram_timing.ddrc_cfg[81].val = 0x30005;
+                dram_timing.ddrc_cfg[96].val = 0x5;
+		
+	}
+	if(C61_IS_2GB) {
+		printf("C61 is 2GB\n");
+		 /* DDR Parameter */
+                dram_timing.ddrc_cfg[2].val = 0xa1080020;
+		dram_timing.ddrc_cfg[34].val = 0x1;
+                dram_timing.ddrc_cfg[37].val = 0x00000017;
+		/* Training */
+		dram_timing.fsp_msg[0].fsp_cfg[9].val = 0x110;
+		dram_timing.fsp_msg[1].fsp_cfg[10].val = 0x110;
+		dram_timing.fsp_msg[2].fsp_cfg[10].val = 0x110;
+		dram_timing.fsp_msg[3].fsp_cfg[10].val = 0x110;
+		dram_timing.fsp_msg[0].fsp_cfg[21].val = 0x1;
+		dram_timing.fsp_msg[1].fsp_cfg[22].val = 0x1;
+		dram_timing.fsp_msg[2].fsp_cfg[22].val = 0x1;
+		dram_timing.fsp_msg[3].fsp_cfg[22].val = 0x1;
+	}
+	if(C61_IS_4GB) {
+		printf("C61 is 4GB\n");
+		/* DDR Parameter */
+		dram_timing.ddrc_cfg[2].val = 0xa3080020;
+		dram_timing.ddrc_cfg[34].val = 0x1;
+		dram_timing.ddrc_cfg[37].val = 0x00000017;
+		/* Training */
+		dram_timing.fsp_msg[0].fsp_cfg[9].val = 0x310;
+		dram_timing.fsp_msg[1].fsp_cfg[10].val = 0x310;
+		dram_timing.fsp_msg[2].fsp_cfg[10].val = 0x310;
+		dram_timing.fsp_msg[3].fsp_cfg[10].val = 0x310;
+		dram_timing.fsp_msg[0].fsp_cfg[21].val = 0x3;
+		dram_timing.fsp_msg[1].fsp_cfg[22].val = 0x3;
+		dram_timing.fsp_msg[2].fsp_cfg[22].val = 0x3;
+		dram_timing.fsp_msg[3].fsp_cfg[22].val = 0x3;
+	}
+	ddr_init(&dram_timing);
+}
+
+#define I2C_PAD_CTRL	(PAD_CTL_DSE6 | PAD_CTL_HYS | PAD_CTL_PUE | PAD_CTL_PE)
+#define PC MUX_PAD_CTRL(I2C_PAD_CTRL)
+struct i2c_pads_info i2c_pad_info1 = {
+	.scl = {
+		.i2c_mode = IMX8MM_PAD_I2C1_SCL_I2C1_SCL | PC,
+		.gpio_mode = IMX8MM_PAD_I2C1_SCL_GPIO5_IO14 | PC,
+		.gp = IMX_GPIO_NR(5, 14),
+	},
+	.sda = {
+		.i2c_mode = IMX8MM_PAD_I2C1_SDA_I2C1_SDA | PC,
+		.gpio_mode = IMX8MM_PAD_I2C1_SDA_GPIO5_IO15 | PC,
+		.gp = IMX_GPIO_NR(5, 15),
+	},
+};
+
+#define USDHC2_CD_GPIO	IMX_GPIO_NR(2, 18)
+#define USDHC2_PWR_GPIO IMX_GPIO_NR(2, 19)
+
+#define USDHC_PAD_CTRL	(PAD_CTL_DSE6 | PAD_CTL_HYS | PAD_CTL_PUE |PAD_CTL_PE | \
+			 PAD_CTL_FSEL2)
+#define USDHC_GPIO_PAD_CTRL (PAD_CTL_HYS | PAD_CTL_DSE1)
+
+static iomux_v3_cfg_t const usdhc3_pads[] = {
+	IMX8MM_PAD_NAND_WE_B_USDHC3_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	IMX8MM_PAD_NAND_WP_B_USDHC3_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	IMX8MM_PAD_NAND_DATA04_USDHC3_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	IMX8MM_PAD_NAND_DATA05_USDHC3_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	IMX8MM_PAD_NAND_DATA06_USDHC3_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	IMX8MM_PAD_NAND_DATA07_USDHC3_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	IMX8MM_PAD_NAND_RE_B_USDHC3_DATA4 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	IMX8MM_PAD_NAND_CE2_B_USDHC3_DATA5 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	IMX8MM_PAD_NAND_CE3_B_USDHC3_DATA6 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	IMX8MM_PAD_NAND_CLE_USDHC3_DATA7 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const usdhc2_pads[] = {
+	IMX8MM_PAD_SD2_CLK_USDHC2_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	IMX8MM_PAD_SD2_CMD_USDHC2_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	IMX8MM_PAD_SD2_DATA0_USDHC2_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	IMX8MM_PAD_SD2_DATA1_USDHC2_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	IMX8MM_PAD_SD2_DATA2_USDHC2_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	IMX8MM_PAD_SD2_DATA3_USDHC2_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	IMX8MM_PAD_SD2_RESET_B_GPIO2_IO19 | MUX_PAD_CTRL(USDHC_GPIO_PAD_CTRL),
+};
+
+/*
+ * The evk board uses DAT3 to detect CD card plugin,
+ * in u-boot we mux the pin to GPIO when doing board_mmc_getcd.
+ */
+static iomux_v3_cfg_t const usdhc2_cd_pad =
+	IMX8MM_PAD_SD2_DATA3_GPIO2_IO18 | MUX_PAD_CTRL(USDHC_GPIO_PAD_CTRL);
+
+static iomux_v3_cfg_t const usdhc2_dat3_pad =
+	IMX8MM_PAD_SD2_DATA3_USDHC2_DATA3 |
+	MUX_PAD_CTRL(USDHC_PAD_CTRL);
+
+
+static struct fsl_esdhc_cfg usdhc_cfg[2] = {
+	{USDHC2_BASE_ADDR, 0, 1},
+	{USDHC3_BASE_ADDR, 0, 1},
+};
+
+int board_mmc_init(struct bd_info *bis)
+{
+	int i, ret;
+	/*
+	 * According to the board_mmc_init() the following map is done:
+	 * (U-Boot device node)    (Physical Port)
+	 * mmc0                    USDHC3
+	 * mmc1                    USDHC2
+	 */
+	for (i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++) {
+		switch (i) {
+		case 0:
+			init_clk_usdhc(1);
+			usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC2_CLK);
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc2_pads, ARRAY_SIZE(usdhc2_pads));
+			gpio_request(USDHC2_PWR_GPIO, "usdhc2_reset");
+			gpio_direction_output(USDHC2_PWR_GPIO, 0);
+			udelay(500);
+			gpio_direction_output(USDHC2_PWR_GPIO, 1);
+			break;
+		case 1:
+			init_clk_usdhc(2);
+			usdhc_cfg[1].sdhc_clk = mxc_get_clock(MXC_ESDHC3_CLK);
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc3_pads, ARRAY_SIZE(usdhc3_pads));
+			break;
+		default:
+			printf("Warning: you configured more USDHC controllers"
+				"(%d) than supported by the board\n", i + 1);
+			return -EINVAL;
+		}
+
+		ret = fsl_esdhc_initialize(bis, &usdhc_cfg[i]);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
+	int ret = 0;
+
+	switch (cfg->esdhc_base) {
+	case USDHC3_BASE_ADDR:
+		ret = 1;
+		break;
+	case USDHC2_BASE_ADDR:
+		imx_iomux_v3_setup_pad(usdhc2_cd_pad);
+		gpio_request(USDHC2_CD_GPIO, "usdhc2 cd");
+		gpio_direction_input(USDHC2_CD_GPIO);
+
+		/*
+		 * Since it is the DAT3 pin, this pin is pulled to
+		 * low voltage if no card
+		 */
+		ret = gpio_get_value(USDHC2_CD_GPIO);
+
+		imx_iomux_v3_setup_pad(usdhc2_dat3_pad);
+		return ret;
+	}
+
+	return 1;
+}
+
+static int power_init_board(void)
+{
+	struct udevice *dev;
+	int ret;
+
+	ret = pmic_get("pmic@4b", &dev);
+	if (ret == -ENODEV) {
+		puts("No pmic\n");
+		return 0;
+	}
+	if (ret != 0)
+		return ret;
+
+	/* decrease RESET key long push time from the default 10s to 10ms */
+	pmic_reg_write(dev, BD718XX_PWRONCONFIG1, 0x0);
+
+	/* unlock the PMIC regs */
+	pmic_reg_write(dev, BD718XX_REGLOCK, 0x1);
+
+	/* increase VDD_SOC to typical value 0.85v before first DRAM access */
+	pmic_reg_write(dev, BD718XX_BUCK1_VOLT_RUN, 0x0f);
+
+	/* increase VDD_DRAM to 0.975v for 3Ghz DDR */
+	pmic_reg_write(dev, BD718XX_1ST_NODVS_BUCK_VOLT, 0x83);
+
+#ifndef CONFIG_IMX8M_LPDDR4
+	/* increase NVCC_DRAM_1V2 to 1.2v for DDR4 */
+	pmic_reg_write(dev, BD718XX_4TH_NODVS_BUCK_VOLT, 0x28);
+#endif
+
+	/* lock the PMIC regs */
+	pmic_reg_write(dev, BD718XX_REGLOCK, 0x11);
+
+	return 0;
+}
+
+void spl_board_init(void)
+{
+#ifndef CONFIG_SPL_USB_SDP_SUPPORT
+	/* Serial download mode */
+	if (is_usb_boot()) {
+		puts("Back to ROM, SDP\n");
+		restore_boot_params();
+	}
+#endif
+	puts("Normal Boot\n");
+}
+
+#ifdef CONFIG_SPL_LOAD_FIT
+int board_fit_config_name_match(const char *name)
+{
+	/* Just empty function now - can't decide what to choose */
+	debug("%s: %s\n", __func__, name);
+
+	return 0;
+}
+#endif
+
+void board_init_f(ulong dummy)
+{
+	int ret;
+
+	/* Clear the BSS. */
+	memset(__bss_start, 0, __bss_end - __bss_start);
+
+	arch_cpu_init();
+
+	board_early_init_f();
+
+	timer_init();
+
+	preloader_console_init();
+
+	ret = spl_init();
+	if (ret) {
+		debug("spl_init() failed: %d\n", ret);
+		hang();
+	}
+
+	enable_tzc380();
+
+	/* Adjust pmic voltage to 1.0V for 800M */
+	setup_i2c(0, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info1);
+
+	power_init_board();
+
+	/* DDR initialization */
+	spl_dram_init();
+
+	board_init_r(NULL, 0);
+}
diff --git a/board/seco/seco_imx8mm_c61/tcpc.c b/board/seco/seco_imx8mm_c61/tcpc.c
new file mode 100644
index 0000000000..bf3e371994
--- /dev/null
+++ b/board/seco/seco_imx8mm_c61/tcpc.c
@@ -0,0 +1,1012 @@
+/*
+ * Copyright 2017,2019 NXP
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#include <common.h>
+#include <i2c.h>
+#include <time.h>
+#include "tcpc.h"
+
+#ifdef DEBUG
+#define tcpc_debug_log(port, fmt, args...) tcpc_log(port, fmt, ##args)
+#else
+#define tcpc_debug_log(port, fmt, args...)
+#endif
+
+static int tcpc_log(struct tcpc_port *port, const char *fmt, ...)
+{
+	va_list args;
+	int i;
+
+	va_start(args, fmt);
+	i = vscnprintf(port->log_p, port->log_size, fmt, args);
+	va_end(args);
+
+	port->log_size -= i;
+	port->log_p += i;
+
+	return i;
+}
+
+int tcpc_set_cc_to_source(struct tcpc_port *port)
+{
+	uint8_t valb;
+	int err;
+
+	if (port == NULL)
+		return -EINVAL;
+
+	valb = (TCPC_ROLE_CTRL_CC_RP << TCPC_ROLE_CTRL_CC1_SHIFT) |
+			(TCPC_ROLE_CTRL_CC_RP << TCPC_ROLE_CTRL_CC2_SHIFT) |
+			(TCPC_ROLE_CTRL_RP_VAL_DEF <<
+			 TCPC_ROLE_CTRL_RP_VAL_SHIFT) | TCPC_ROLE_CTRL_DRP;
+
+	err = dm_i2c_write(port->i2c_dev, TCPC_ROLE_CTRL, &valb, 1);
+	if (err)
+		tcpc_log(port, "%s dm_i2c_write failed, err %d\n", __func__, err);
+	return err;
+}
+
+int tcpc_set_cc_to_sink(struct tcpc_port *port)
+{
+	uint8_t valb;
+	int err;
+
+	if (port == NULL)
+		return -EINVAL;
+
+	valb = (TCPC_ROLE_CTRL_CC_RD << TCPC_ROLE_CTRL_CC1_SHIFT) |
+			(TCPC_ROLE_CTRL_CC_RD << TCPC_ROLE_CTRL_CC2_SHIFT) | TCPC_ROLE_CTRL_DRP;
+
+	err = dm_i2c_write(port->i2c_dev, TCPC_ROLE_CTRL, &valb, 1);
+	if (err)
+		tcpc_log(port, "%s dm_i2c_write failed, err %d\n", __func__, err);
+	return err;
+}
+
+
+int tcpc_set_plug_orientation(struct tcpc_port *port, enum typec_cc_polarity polarity)
+{
+	uint8_t valb;
+	int err;
+
+	if (port == NULL)
+		return -EINVAL;
+
+	err = dm_i2c_read(port->i2c_dev, TCPC_TCPC_CTRL, &valb, 1);
+	if (err) {
+		tcpc_log(port, "%s dm_i2c_read failed, err %d\n", __func__, err);
+		return -EIO;
+	}
+
+	if (polarity == TYPEC_POLARITY_CC2)
+		valb |= TCPC_TCPC_CTRL_ORIENTATION;
+	else
+		valb &= ~TCPC_TCPC_CTRL_ORIENTATION;
+
+	err = dm_i2c_write(port->i2c_dev, TCPC_TCPC_CTRL, &valb, 1);
+	if (err) {
+		tcpc_log(port, "%s dm_i2c_write failed, err %d\n", __func__, err);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+int tcpc_get_cc_status(struct tcpc_port *port, enum typec_cc_polarity *polarity, enum typec_cc_state *state)
+{
+
+	uint8_t valb_cc, cc2, cc1;
+	int err;
+
+	if (port == NULL || polarity == NULL || state == NULL)
+		return -EINVAL;
+
+	err = dm_i2c_read(port->i2c_dev, TCPC_CC_STATUS, (uint8_t *)&valb_cc, 1);
+	if (err) {
+		tcpc_log(port, "%s dm_i2c_read failed, err %d\n", __func__, err);
+		return -EIO;
+	}
+
+	tcpc_debug_log(port, "cc status 0x%x\n", valb_cc);
+
+	cc2 = (valb_cc >> TCPC_CC_STATUS_CC2_SHIFT) & TCPC_CC_STATUS_CC2_MASK;
+	cc1 = (valb_cc >> TCPC_CC_STATUS_CC1_SHIFT) & TCPC_CC_STATUS_CC1_MASK;
+
+	if (valb_cc & TCPC_CC_STATUS_LOOK4CONN)
+		return -EFAULT;
+
+	*state = TYPEC_STATE_OPEN;
+
+	if (valb_cc & TCPC_CC_STATUS_TERM) {
+		if (cc2) {
+			*polarity = TYPEC_POLARITY_CC2;
+
+			switch (cc2) {
+			case 0x1:
+				*state = TYPEC_STATE_SNK_DEFAULT;
+				tcpc_log(port, "SNK.Default on CC2\n");
+				break;
+			case 0x2:
+				*state = TYPEC_STATE_SNK_POWER15;
+				tcpc_log(port, "SNK.Power1.5 on CC2\n");
+				break;
+			case 0x3:
+				*state = TYPEC_STATE_SNK_POWER30;
+				tcpc_log(port, "SNK.Power3.0 on CC2\n");
+				break;
+			}
+		} else if (cc1) {
+			*polarity = TYPEC_POLARITY_CC1;
+
+			switch (cc1) {
+			case 0x1:
+				*state = TYPEC_STATE_SNK_DEFAULT;
+				tcpc_log(port, "SNK.Default on CC1\n");
+				break;
+			case 0x2:
+				*state = TYPEC_STATE_SNK_POWER15;
+				tcpc_log(port, "SNK.Power1.5 on CC1\n");
+				break;
+			case 0x3:
+				*state = TYPEC_STATE_SNK_POWER30;
+				tcpc_log(port, "SNK.Power3.0 on CC1\n");
+				break;
+			}
+		} else {
+			*state = TYPEC_STATE_OPEN;
+			return -EPERM;
+		}
+
+	} else {
+		if (cc2) {
+			*polarity = TYPEC_POLARITY_CC2;
+
+			switch (cc2) {
+			case 0x1:
+				if (cc1 == 0x1) {
+					*state = TYPEC_STATE_SRC_BOTH_RA;
+					tcpc_log(port, "SRC.Ra on both CC1 and CC2\n");
+				} else if (cc1 == 0x2) {
+					*state = TYPEC_STATE_SRC_RD_RA;
+					tcpc_log(port, "SRC.Ra on CC2, SRC.Rd on CC1\n");
+				} else if (cc1 == 0x0) {
+					tcpc_log(port, "SRC.Ra only on CC2\n");
+					return -EFAULT;
+				} else
+					return -EFAULT;
+				break;
+			case 0x2:
+				if (cc1 == 0x1) {
+					*state = TYPEC_STATE_SRC_RD_RA;
+					tcpc_log(port, "SRC.Ra on CC1, SRC.Rd on CC2\n");
+				} else if (cc1 == 0x0) {
+					*state = TYPEC_STATE_SRC_RD;
+					tcpc_log(port, "SRC.Rd on CC2\n");
+				} else
+					return -EFAULT;
+				break;
+			case 0x3:
+				*state = TYPEC_STATE_SRC_RESERVED;
+				return -EFAULT;
+			}
+		} else if (cc1) {
+			*polarity = TYPEC_POLARITY_CC1;
+
+			switch (cc1) {
+			case 0x1:
+				tcpc_log(port, "SRC.Ra only on CC1\n");
+				return -EFAULT;
+			case 0x2:
+				*state = TYPEC_STATE_SRC_RD;
+				tcpc_log(port, "SRC.Rd on CC1\n");
+				break;
+			case 0x3:
+				*state = TYPEC_STATE_SRC_RESERVED;
+				return -EFAULT;
+			}
+		} else {
+			*state = TYPEC_STATE_OPEN;
+			return -EPERM;
+		}
+	}
+
+	return 0;
+}
+
+int tcpc_clear_alert(struct tcpc_port *port, uint16_t clear_mask)
+{
+	int err;
+
+	if (port == NULL)
+		return -EINVAL;
+
+	err = dm_i2c_write(port->i2c_dev, TCPC_ALERT, (const uint8_t *)&clear_mask, 2);
+	if (err) {
+		tcpc_log(port, "%s dm_i2c_write failed, err %d\n", __func__, err);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+int tcpc_send_command(struct tcpc_port *port, uint8_t command)
+{
+	int err;
+
+	if (port == NULL)
+		return -EINVAL;
+
+	err = dm_i2c_write(port->i2c_dev, TCPC_COMMAND, (const uint8_t *)&command, 1);
+	if (err) {
+		tcpc_log(port, "%s dm_i2c_write failed, err %d\n", __func__, err);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+int tcpc_polling_reg(struct tcpc_port *port, uint8_t reg,
+	uint8_t reg_width, uint16_t mask, uint16_t value, ulong timeout_ms)
+{
+	uint16_t val = 0;
+	int err;
+	ulong start;
+
+	if (port == NULL)
+		return -EINVAL;
+
+	tcpc_debug_log(port, "%s reg 0x%x, mask 0x%x, value 0x%x\n", __func__, reg, mask, value);
+
+	/* TCPC registers is 8 bits or 16 bits */
+	if (reg_width != 1 && reg_width != 2)
+		return -EINVAL;
+
+	start = get_timer(0);	/* Get current timestamp */
+	do {
+		err = dm_i2c_read(port->i2c_dev, reg, (uint8_t *)&val, reg_width);
+		if (err)
+			return -EIO;
+
+		if ((val & mask) == value)
+			return 0;
+	} while (get_timer(0) < (start + timeout_ms));
+
+	return -ETIME;
+}
+
+void tcpc_print_log(struct tcpc_port *port)
+{
+	if (port == NULL)
+		return;
+
+	if (port->log_print == port->log_p) /*nothing to output*/
+		return;
+
+	printf("%s", port->log_print);
+
+	port->log_print = port->log_p;
+}
+
+int tcpc_setup_dfp_mode(struct tcpc_port *port)
+{
+	enum typec_cc_polarity pol;
+	enum typec_cc_state state;
+	int ret;
+
+	if (port == NULL)
+		return -EINVAL;
+
+	if (tcpc_pd_sink_check_charging(port)) {
+		tcpc_log(port, "%s: Can't apply DFP mode when PD is charging\n",
+			__func__);
+		return -EPERM;
+	}
+
+	tcpc_set_cc_to_source(port);
+
+	ret = tcpc_send_command(port, TCPC_CMD_LOOK4CONNECTION);
+	if (ret)
+		return ret;
+
+	/* At least wait tCcStatusDelay + tTCPCFilter + tCcTCPCSampleRate (max) = 200us + 500us + ?ms
+	 * PTN5110 datasheet does not contain the sample rate value, according other productions,
+	 * the sample rate is at ms level, about 2 ms -10ms. So wait 100ms should be enough.
+	 */
+	mdelay(100);
+
+	ret = tcpc_polling_reg(port, TCPC_ALERT, 2, TCPC_ALERT_CC_STATUS, TCPC_ALERT_CC_STATUS, 100);
+	if (ret) {
+		tcpc_log(port, "%s: Polling ALERT register, TCPC_ALERT_CC_STATUS bit failed, ret = %d\n",
+			__func__, ret);
+		return ret;
+	}
+
+	ret = tcpc_get_cc_status(port, &pol, &state);
+	tcpc_clear_alert(port, TCPC_ALERT_CC_STATUS);
+
+	if (!ret) {
+		/* If presenting as Rd/audio mode/open, return */
+		if (state != TYPEC_STATE_SRC_RD_RA && state != TYPEC_STATE_SRC_RD)
+			return -EPERM;
+
+		if (pol == TYPEC_POLARITY_CC1)
+			tcpc_debug_log(port, "polarity cc1\n");
+		else
+			tcpc_debug_log(port, "polarity cc2\n");
+
+		if (port->ss_sel_func)
+			port->ss_sel_func(pol);
+
+		ret = tcpc_set_plug_orientation(port, pol);
+		if (ret)
+			return ret;
+
+		/* Enable source vbus default voltage */
+		ret = tcpc_send_command(port, TCPC_CMD_SRC_VBUS_DEFAULT);
+		if (ret)
+			return ret;
+
+		/* The max vbus on time is 200ms, we add margin 100ms */
+		mdelay(300);
+
+	}
+
+	return 0;
+}
+
+int tcpc_setup_ufp_mode(struct tcpc_port *port)
+{
+	enum typec_cc_polarity pol;
+	enum typec_cc_state state;
+	int ret;
+
+	if (port == NULL)
+		return -EINVAL;
+
+	/* Check if the PD charge is working. If not, need to configure CC role for UFP */
+	if (!tcpc_pd_sink_check_charging(port)) {
+
+		/* Disable the source vbus once it is enabled by DFP mode */
+		tcpc_disable_src_vbus(port);
+
+		tcpc_set_cc_to_sink(port);
+
+		ret = tcpc_send_command(port, TCPC_CMD_LOOK4CONNECTION);
+		if (ret)
+			return ret;
+
+		/* At least wait tCcStatusDelay + tTCPCFilter + tCcTCPCSampleRate (max) = 200us + 500us + ?ms
+		 * PTN5110 datasheet does not contain the sample rate value, according other productions,
+		 * the sample rate is at ms level, about 2 ms -10ms. So wait 100ms should be enough.
+		 */
+		mdelay(100);
+
+		ret = tcpc_polling_reg(port, TCPC_ALERT, 2, TCPC_ALERT_CC_STATUS, TCPC_ALERT_CC_STATUS, 100);
+		if (ret) {
+			tcpc_log(port, "%s: Polling ALERT register, TCPC_ALERT_CC_STATUS bit failed, ret = %d\n",
+				__func__, ret);
+			return ret;
+		}
+
+		ret = tcpc_get_cc_status(port, &pol, &state);
+		tcpc_clear_alert(port, TCPC_ALERT_CC_STATUS);
+
+	} else {
+		ret = tcpc_get_cc_status(port, &pol, &state);
+	}
+
+	if (!ret) {
+		/* If presenting not as sink, then return */
+		if (state != TYPEC_STATE_SNK_DEFAULT && state != TYPEC_STATE_SNK_POWER15 &&
+			state != TYPEC_STATE_SNK_POWER30)
+			return -EPERM;
+
+		if (pol == TYPEC_POLARITY_CC1)
+			tcpc_debug_log(port, "polarity cc1\n");
+		else
+			tcpc_debug_log(port, "polarity cc2\n");
+
+		if (port->ss_sel_func)
+			port->ss_sel_func(pol);
+
+		ret = tcpc_set_plug_orientation(port, pol);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+int tcpc_disable_src_vbus(struct tcpc_port *port)
+{
+	int ret;
+
+	if (port == NULL)
+		return -EINVAL;
+
+	/* Disable VBUS*/
+	ret = tcpc_send_command(port, TCPC_CMD_DISABLE_SRC_VBUS);
+	if (ret)
+		return ret;
+
+	/* The max vbus off time is 0.5ms, we add margin 0.5 ms */
+	mdelay(1);
+
+	return 0;
+}
+
+int tcpc_disable_sink_vbus(struct tcpc_port *port)
+{
+	int ret;
+
+	if (port == NULL)
+		return -EINVAL;
+
+	/* Disable SINK VBUS*/
+	ret = tcpc_send_command(port, TCPC_CMD_DISABLE_SINK_VBUS);
+	if (ret)
+		return ret;
+
+	/* The max vbus off time is 0.5ms, we add margin 0.5 ms */
+	mdelay(1);
+
+	return 0;
+}
+
+
+static int tcpc_pd_receive_message(struct tcpc_port *port, struct pd_message *msg)
+{
+	int ret;
+	uint8_t cnt;
+	uint16_t val;
+
+	if (port == NULL)
+		return -EINVAL;
+
+	/* Generally the max tSenderResponse is 30ms, max tTypeCSendSourceCap is 200ms, we set the timeout to 500ms */
+	ret = tcpc_polling_reg(port, TCPC_ALERT, 2, TCPC_ALERT_RX_STATUS, TCPC_ALERT_RX_STATUS, 500);
+	if (ret) {
+		tcpc_log(port, "%s: Polling ALERT register, TCPC_ALERT_RX_STATUS bit failed, ret = %d\n",
+			__func__, ret);
+		return ret;
+	}
+
+	cnt = 0;
+	ret = dm_i2c_read(port->i2c_dev, TCPC_RX_BYTE_CNT, (uint8_t *)&cnt, 1);
+	if (ret)
+		return -EIO;
+
+	if (cnt > 0) {
+		ret = dm_i2c_read(port->i2c_dev, TCPC_RX_BUF_FRAME_TYPE, (uint8_t *)msg, cnt);
+		if (ret)
+			return -EIO;
+
+		/* Clear RX status alert bit */
+		val = TCPC_ALERT_RX_STATUS;
+		ret = dm_i2c_write(port->i2c_dev, TCPC_ALERT, (const uint8_t *)&val, 2);
+		if (ret)
+			return -EIO;
+	}
+
+	return cnt;
+}
+
+static int tcpc_pd_transmit_message(struct tcpc_port *port, struct pd_message *msg_p, uint8_t bytes)
+{
+	int ret;
+	uint8_t valb;
+	uint16_t val;
+
+	if (port == NULL)
+		return -EINVAL;
+
+	if (msg_p == NULL || bytes <= 0)
+		return -EINVAL;
+
+	ret = dm_i2c_write(port->i2c_dev, TCPC_TX_BYTE_CNT, (const uint8_t *)&bytes, 1);
+	if (ret)
+		return -EIO;
+
+	ret = dm_i2c_write(port->i2c_dev, TCPC_TX_HDR, (const uint8_t *)&(msg_p->header), bytes);
+	if (ret)
+		return -EIO;
+
+	valb = (3 << TCPC_TRANSMIT_RETRY_SHIFT) | (TCPC_TX_SOP << TCPC_TRANSMIT_TYPE_SHIFT);
+	ret = dm_i2c_write(port->i2c_dev, TCPC_TRANSMIT, (const uint8_t *)&valb, 1);
+	if (ret)
+		return -EIO;
+
+	/* Max tReceive is 1.1ms, we set to 5ms timeout */
+	ret = tcpc_polling_reg(port, TCPC_ALERT, 2, TCPC_ALERT_TX_SUCCESS, TCPC_ALERT_TX_SUCCESS, 5);
+	if (ret) {
+		if (ret == -ETIME) {
+			ret = dm_i2c_read(port->i2c_dev, TCPC_ALERT, (uint8_t *)&val, 2);
+			if (ret)
+				return -EIO;
+
+			if (val & TCPC_ALERT_TX_FAILED)
+				tcpc_log(port, "%s: PD TX FAILED, ALERT = 0x%x\n", __func__, val);
+
+			if (val & TCPC_ALERT_TX_DISCARDED)
+				tcpc_log(port, "%s: PD TX DISCARDED, ALERT = 0x%x\n", __func__, val);
+
+		} else {
+			tcpc_log(port, "%s: Polling ALERT register, TCPC_ALERT_TX_SUCCESS bit failed, ret = %d\n",
+				__func__, ret);
+		}
+	} else {
+		port->tx_msg_id = (port->tx_msg_id + 1) & PD_HEADER_ID_MASK;
+	}
+
+	/* Clear ALERT status */
+	val &= (TCPC_ALERT_TX_FAILED | TCPC_ALERT_TX_DISCARDED | TCPC_ALERT_TX_SUCCESS);
+	ret = dm_i2c_write(port->i2c_dev, TCPC_ALERT, (const uint8_t *)&val, 2);
+	if (ret)
+		return -EIO;
+
+	return ret;
+}
+
+static void tcpc_log_source_caps(struct tcpc_port *port, uint32_t *caps, unsigned int capcount)
+{
+	int i;
+
+	for (i = 0; i < capcount; i++) {
+		u32 pdo = caps[i];
+		enum pd_pdo_type type = pdo_type(pdo);
+
+		tcpc_log(port, "PDO %d: type %d, ",
+			 i, type);
+
+		switch (type) {
+		case PDO_TYPE_FIXED:
+			tcpc_log(port, "%u mV, %u mA [%s%s%s%s%s%s]\n",
+				  pdo_fixed_voltage(pdo),
+				  pdo_max_current(pdo),
+				  (pdo & PDO_FIXED_DUAL_ROLE) ?
+							"R" : "",
+				  (pdo & PDO_FIXED_SUSPEND) ?
+							"S" : "",
+				  (pdo & PDO_FIXED_HIGHER_CAP) ?
+							"H" : "",
+				  (pdo & PDO_FIXED_USB_COMM) ?
+							"U" : "",
+				  (pdo & PDO_FIXED_DATA_SWAP) ?
+							"D" : "",
+				  (pdo & PDO_FIXED_EXTPOWER) ?
+							"E" : "");
+			break;
+		case PDO_TYPE_VAR:
+			tcpc_log(port, "%u-%u mV, %u mA\n",
+				  pdo_min_voltage(pdo),
+				  pdo_max_voltage(pdo),
+				  pdo_max_current(pdo));
+			break;
+		case PDO_TYPE_BATT:
+			tcpc_log(port, "%u-%u mV, %u mW\n",
+				  pdo_min_voltage(pdo),
+				  pdo_max_voltage(pdo),
+				  pdo_max_power(pdo));
+			break;
+		default:
+			tcpc_log(port, "undefined\n");
+			break;
+		}
+	}
+}
+
+static int tcpc_pd_select_pdo(uint32_t *caps, uint32_t capcount, uint32_t max_snk_mv, uint32_t max_snk_ma)
+{
+	unsigned int i, max_mw = 0, max_mv = 0;
+	int ret = -EINVAL;
+
+	/*
+	 * Select the source PDO providing the most power while staying within
+	 * the board's voltage limits. Prefer PDO providing exp
+	 */
+	for (i = 0; i < capcount; i++) {
+		u32 pdo = caps[i];
+		enum pd_pdo_type type = pdo_type(pdo);
+		unsigned int mv, ma, mw;
+
+		if (type == PDO_TYPE_FIXED)
+			mv = pdo_fixed_voltage(pdo);
+		else
+			mv = pdo_min_voltage(pdo);
+
+		if (type == PDO_TYPE_BATT) {
+			mw = pdo_max_power(pdo);
+		} else {
+			ma = min(pdo_max_current(pdo),
+				 max_snk_ma);
+			mw = ma * mv / 1000;
+		}
+
+		/* Perfer higher voltages if available */
+		if ((mw > max_mw || (mw == max_mw && mv > max_mv)) &&
+		    mv <= max_snk_mv) {
+			ret = i;
+			max_mw = mw;
+			max_mv = mv;
+		}
+	}
+
+	return ret;
+}
+
+static int tcpc_pd_build_request(struct tcpc_port *port,
+										uint32_t *caps,
+										uint32_t capcount,
+										uint32_t max_snk_mv,
+										uint32_t max_snk_ma,
+										uint32_t max_snk_mw,
+										uint32_t operating_snk_mw,
+										uint32_t *rdo)
+{
+	unsigned int mv, ma, mw, flags;
+	unsigned int max_ma, max_mw;
+	enum pd_pdo_type type;
+	int index;
+	u32 pdo;
+
+	index = tcpc_pd_select_pdo(caps, capcount, max_snk_mv, max_snk_ma);
+	if (index < 0)
+		return -EINVAL;
+
+	pdo = caps[index];
+	type = pdo_type(pdo);
+
+	if (type == PDO_TYPE_FIXED)
+		mv = pdo_fixed_voltage(pdo);
+	else
+		mv = pdo_min_voltage(pdo);
+
+	/* Select maximum available current within the board's power limit */
+	if (type == PDO_TYPE_BATT) {
+		mw = pdo_max_power(pdo);
+		ma = 1000 * min(mw, max_snk_mw) / mv;
+	} else {
+		ma = min(pdo_max_current(pdo),
+			 1000 * max_snk_mw / mv);
+	}
+	ma = min(ma, max_snk_ma);
+
+	/* XXX: Any other flags need to be set? */
+	flags = 0;
+
+	/* Set mismatch bit if offered power is less than operating power */
+	mw = ma * mv / 1000;
+	max_ma = ma;
+	max_mw = mw;
+	if (mw < operating_snk_mw) {
+		flags |= RDO_CAP_MISMATCH;
+		max_mw = operating_snk_mw;
+		max_ma = max_mw * 1000 / mv;
+	}
+
+	if (type == PDO_TYPE_BATT) {
+		*rdo = RDO_BATT(index + 1, mw, max_mw, flags);
+
+		tcpc_log(port, "Requesting PDO %d: %u mV, %u mW%s\n",
+			 index, mv, mw,
+			 flags & RDO_CAP_MISMATCH ? " [mismatch]" : "");
+	} else {
+		*rdo = RDO_FIXED(index + 1, ma, max_ma, flags);
+
+		tcpc_log(port, "Requesting PDO %d: %u mV, %u mA%s\n",
+			 index, mv, ma,
+			 flags & RDO_CAP_MISMATCH ? " [mismatch]" : "");
+	}
+
+	return 0;
+}
+
+static void tcpc_pd_sink_process(struct tcpc_port *port)
+{
+	int ret;
+	uint8_t msgtype;
+	uint32_t objcnt;
+	struct pd_message msg;
+	enum pd_sink_state pd_state = WAIT_SOURCE_CAP;
+
+	while (tcpc_pd_receive_message(port, &msg) > 0) {
+
+		msgtype = pd_header_type(msg.header);
+		objcnt = pd_header_cnt_le(msg.header);
+
+		tcpc_debug_log(port, "get msg, type %d, cnt %d\n", msgtype, objcnt);
+
+		switch (pd_state) {
+		case WAIT_SOURCE_CAP:
+		case SINK_READY:
+			if (msgtype != PD_DATA_SOURCE_CAP)
+				continue;
+
+			uint32_t *caps = (uint32_t *)&msg.payload;
+			uint32_t rdo = 0;
+
+			tcpc_log_source_caps(port, caps, objcnt);
+
+			tcpc_pd_build_request(port, caps, objcnt,
+				port->cfg.max_snk_mv, port->cfg.max_snk_ma,
+				port->cfg.max_snk_mw, port->cfg.op_snk_mv,
+				&rdo);
+
+			memset(&msg, 0, sizeof(msg));
+			msg.header = PD_HEADER(PD_DATA_REQUEST, 0, 0, port->tx_msg_id, 1);  /* power sink, data device, id 0, len 1 */
+			msg.payload[0] = rdo;
+
+			ret = tcpc_pd_transmit_message(port, &msg, 6);
+			if (ret)
+				tcpc_log(port, "send request failed\n");
+			else
+				pd_state = WAIT_SOURCE_ACCEPT;
+
+			break;
+		case WAIT_SOURCE_ACCEPT:
+			if (objcnt > 0) /* Should be ctrl message */
+				continue;
+
+			if (msgtype == PD_CTRL_ACCEPT) {
+				pd_state = WAIT_SOURCE_READY;
+				tcpc_log(port, "Source accept request\n");
+			} else if (msgtype == PD_CTRL_REJECT) {
+				tcpc_log(port, "Source reject request\n");
+				return;
+			}
+
+			break;
+		case WAIT_SOURCE_READY:
+			if (objcnt > 0) /* Should be ctrl message */
+				continue;
+
+			if (msgtype == PD_CTRL_PS_RDY) {
+				tcpc_log(port, "PD source ready!\n");
+				pd_state = SINK_READY;
+			}
+
+			break;
+		default:
+			tcpc_log(port, "unexpect status: %u\n", pd_state);
+			break;
+		}
+	}
+}
+
+bool tcpc_pd_sink_check_charging(struct tcpc_port *port)
+{
+	uint8_t valb;
+	int err;
+	enum typec_cc_polarity pol;
+	enum typec_cc_state state;
+
+	if (port == NULL)
+		return false;
+
+	/* Check the CC status, must be sink */
+	err = tcpc_get_cc_status(port, &pol, &state);
+	if (err || (state != TYPEC_STATE_SNK_POWER15
+		&& state != TYPEC_STATE_SNK_POWER30
+		&& state != TYPEC_STATE_SNK_DEFAULT)) {
+		tcpc_debug_log(port, "TCPC wrong state for PD charging, err = %d, CC = 0x%x\n",
+			err, state);
+		return false;
+	}
+
+	/* Check the VBUS PRES and SINK VBUS for dead battery */
+	err = dm_i2c_read(port->i2c_dev, TCPC_POWER_STATUS, &valb, 1);
+	if (err) {
+		tcpc_debug_log(port, "%s dm_i2c_read failed, err %d\n", __func__, err);
+		return false;
+	}
+
+	if (!(valb & TCPC_POWER_STATUS_VBUS_PRES)) {
+		tcpc_debug_log(port, "VBUS NOT PRES \n");
+		return false;
+	}
+
+	if (!(valb & TCPC_POWER_STATUS_SINKING_VBUS)) {
+		tcpc_debug_log(port, "SINK VBUS is not enabled for dead battery\n");
+		return false;
+	}
+
+	return true;
+}
+
+static int tcpc_pd_sink_disable(struct tcpc_port *port)
+{
+	uint8_t valb;
+	int err;
+
+	if (port == NULL)
+		return -EINVAL;
+
+	port->pd_state = UNATTACH;
+
+	/* Check the VBUS PRES and SINK VBUS for dead battery */
+	err = dm_i2c_read(port->i2c_dev, TCPC_POWER_STATUS, &valb, 1);
+	if (err) {
+		tcpc_log(port, "%s dm_i2c_read failed, err %d\n", __func__, err);
+		return -EIO;
+	}
+
+	if ((valb & TCPC_POWER_STATUS_VBUS_PRES) && (valb & TCPC_POWER_STATUS_SINKING_VBUS)) {
+		dm_i2c_read(port->i2c_dev, TCPC_POWER_CTRL, (uint8_t *)&valb, 1);
+		valb &= ~TCPC_POWER_CTRL_AUTO_DISCH_DISCO; /* disable AutoDischargeDisconnect */
+		dm_i2c_write(port->i2c_dev, TCPC_POWER_CTRL, (const uint8_t *)&valb, 1);
+
+		tcpc_disable_sink_vbus(port);
+	}
+
+	if (port->cfg.switch_setup_func)
+		port->cfg.switch_setup_func(port);
+
+	return 0;
+}
+
+static int tcpc_pd_sink_init(struct tcpc_port *port)
+{
+	uint8_t valb;
+	uint16_t val;
+	int err;
+	enum typec_cc_polarity pol;
+	enum typec_cc_state state;
+
+	if (port == NULL)
+		return -EINVAL;
+
+	port->pd_state = UNATTACH;
+
+	/* Check the VBUS PRES and SINK VBUS for dead battery */
+	err = dm_i2c_read(port->i2c_dev, TCPC_POWER_STATUS, &valb, 1);
+	if (err) {
+		tcpc_log(port, "%s dm_i2c_read failed, err %d\n", __func__, err);
+		return -EIO;
+	}
+
+	if (!(valb & TCPC_POWER_STATUS_VBUS_PRES)) {
+		tcpc_debug_log(port, "VBUS NOT PRES \n");
+		return -EPERM;
+	}
+
+	if (!(valb & TCPC_POWER_STATUS_SINKING_VBUS)) {
+		tcpc_debug_log(port, "SINK VBUS is not enabled for dead battery\n");
+		return -EPERM;
+	}
+
+	err = dm_i2c_read(port->i2c_dev, TCPC_ALERT, (uint8_t *)&val, 2);
+	if (err) {
+		tcpc_log(port, "%s dm_i2c_read failed, err %d\n", __func__, err);
+		return -EIO;
+	}
+
+	if (!(val & TCPC_ALERT_CC_STATUS)) {
+		tcpc_debug_log(port, "CC STATUS not detected for dead battery\n");
+		return -EPERM;
+	}
+
+	err = tcpc_get_cc_status(port, &pol, &state);
+	if (err || (state != TYPEC_STATE_SNK_POWER15
+		&& state != TYPEC_STATE_SNK_POWER30
+		&& state != TYPEC_STATE_SNK_DEFAULT)) {
+		tcpc_log(port, "TCPC wrong state for dead battery, err = %d, CC = 0x%x\n",
+			err, state);
+		return -EPERM;
+	} else
+		port->pd_state = ATTACHED;
+
+	dm_i2c_read(port->i2c_dev, TCPC_POWER_CTRL, (uint8_t *)&valb, 1);
+	valb &= ~TCPC_POWER_CTRL_AUTO_DISCH_DISCO; /* disable AutoDischargeDisconnect */
+	dm_i2c_write(port->i2c_dev, TCPC_POWER_CTRL, (const uint8_t *)&valb, 1);
+
+	if (port->cfg.switch_setup_func)
+		port->cfg.switch_setup_func(port);
+
+	/* As sink role */
+	valb = 0x00;
+	err = dm_i2c_write(port->i2c_dev, TCPC_MSG_HDR_INFO, (const uint8_t *)&valb, 1);
+	if (err) {
+		tcpc_log(port, "%s dm_i2c_read failed, err %d\n", __func__, err);
+		return -EIO;
+	}
+
+	/* Enable rx */
+	valb = TCPC_RX_DETECT_SOP | TCPC_RX_DETECT_HARD_RESET;
+	err = dm_i2c_write(port->i2c_dev, TCPC_RX_DETECT, (const uint8_t *)&valb, 1);
+	if (err) {
+		tcpc_log(port, "%s dm_i2c_read failed, err %d\n", __func__, err);
+		return -EIO;
+	}
+
+	tcpc_pd_sink_process(port);
+
+	return 0;
+}
+
+int tcpc_init(struct tcpc_port *port, struct tcpc_port_config config, ss_mux_sel ss_sel_func)
+{
+	int ret;
+	uint8_t valb;
+	uint16_t vid, pid;
+	struct udevice *bus;
+	struct udevice *i2c_dev = NULL;
+
+	memset(port, 0, sizeof(struct tcpc_port));
+
+	if (port == NULL)
+		return -EINVAL;
+
+	port->cfg = config;
+	port->tx_msg_id = 0;
+	port->ss_sel_func = ss_sel_func;
+	port->log_p = (char *)&(port->logbuffer);
+	port->log_size = TCPC_LOG_BUFFER_SIZE;
+	port->log_print = port->log_p;
+	memset(&(port->logbuffer), 0, TCPC_LOG_BUFFER_SIZE);
+
+	ret = uclass_get_device_by_seq(UCLASS_I2C, port->cfg.i2c_bus, &bus);
+	if (ret) {
+		printf("%s: Can't find bus\n", __func__);
+		return -EINVAL;
+	}
+
+	ret = dm_i2c_probe(bus, port->cfg.addr, 0, &i2c_dev);
+	if (ret) {
+		printf("%s: Can't find device id=0x%x\n",
+			__func__, config.addr);
+		return -ENODEV;
+	}
+
+	port->i2c_dev = i2c_dev;
+
+	/* Check the Initialization Status bit in 1s */
+	ret = tcpc_polling_reg(port, TCPC_POWER_STATUS, 1, TCPC_POWER_STATUS_UNINIT, 0, 1000);
+	if (ret) {
+		tcpc_log(port, "%s: Polling TCPC POWER STATUS Initialization Status bit failed, ret = %d\n",
+			__func__, ret);
+		return ret;
+	}
+
+	dm_i2c_read(port->i2c_dev, TCPC_POWER_STATUS, &valb, 1);
+	tcpc_debug_log(port, "POWER STATUS: 0x%x\n", valb);
+
+	/* Clear AllRegistersResetToDefault */
+	valb = 0x80;
+	ret = dm_i2c_write(port->i2c_dev, TCPC_FAULT_STATUS, (const uint8_t *)&valb, 1);
+	if (ret) {
+		tcpc_log(port, "%s dm_i2c_read failed, err %d\n", __func__, ret);
+		return -EIO;
+	}
+
+	/* Read Vendor ID and Product ID */
+	ret = dm_i2c_read(port->i2c_dev, TCPC_VENDOR_ID, (uint8_t *)&vid, 2);
+	if (ret) {
+		tcpc_log(port, "%s dm_i2c_read failed, err %d\n", __func__, ret);
+		return -EIO;
+	}
+
+	ret = dm_i2c_read(port->i2c_dev, TCPC_PRODUCT_ID, (uint8_t *)&pid, 2);
+	if (ret) {
+		tcpc_log(port, "%s dm_i2c_read failed, err %d\n", __func__, ret);
+		return -EIO;
+	}
+
+	tcpc_log(port, "TCPC:  Vendor ID [0x%x], Product ID [0x%x], Addr [I2C%u 0x%x]\n",
+		vid, pid, port->cfg.i2c_bus, port->cfg.addr);
+
+	if (!port->cfg.disable_pd) {
+		if  (port->cfg.port_type == TYPEC_PORT_UFP
+			|| port->cfg.port_type == TYPEC_PORT_DRP)
+			tcpc_pd_sink_init(port);
+	} else {
+		tcpc_pd_sink_disable(port);
+	}
+
+	tcpc_clear_alert(port, 0xffff);
+
+	tcpc_print_log(port);
+
+	return 0;
+}
diff --git a/board/seco/seco_imx8mm_c61/tcpc.h b/board/seco/seco_imx8mm_c61/tcpc.h
new file mode 100644
index 0000000000..ff749518a8
--- /dev/null
+++ b/board/seco/seco_imx8mm_c61/tcpc.h
@@ -0,0 +1,469 @@
+/*
+ * Copyright 2017 NXP
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __TCPCI_H
+#define __TCPCI_H
+
+#include <dm.h>
+
+#define TCPC_VENDOR_ID			0x0
+#define TCPC_PRODUCT_ID			0x2
+
+#define TCPC_ALERT					0x10
+#define TCPC_ALERT_VBUS_DISCNCT		BIT(11)
+#define TCPC_ALERT_RX_BUF_OVF		BIT(10)
+#define TCPC_ALERT_FAULT			BIT(9)
+#define TCPC_ALERT_V_ALARM_LO		BIT(8)
+#define TCPC_ALERT_V_ALARM_HI		BIT(7)
+#define TCPC_ALERT_TX_SUCCESS		BIT(6)
+#define TCPC_ALERT_TX_DISCARDED		BIT(5)
+#define TCPC_ALERT_TX_FAILED		BIT(4)
+#define TCPC_ALERT_RX_HARD_RST		BIT(3)
+#define TCPC_ALERT_RX_STATUS		BIT(2)
+#define TCPC_ALERT_POWER_STATUS		BIT(1)
+#define TCPC_ALERT_CC_STATUS		BIT(0)
+
+#define TCPC_TCPC_CTRL				0x19
+#define TCPC_TCPC_CTRL_BIST_MODE	BIT(1)
+#define TCPC_TCPC_CTRL_ORIENTATION	BIT(0)
+
+#define TCPC_ROLE_CTRL				0x1a
+#define TCPC_ROLE_CTRL_DRP			BIT(6)
+#define TCPC_ROLE_CTRL_RP_VAL_SHIFT	4
+#define TCPC_ROLE_CTRL_RP_VAL_MASK	0x3
+#define TCPC_ROLE_CTRL_RP_VAL_DEF	0x0
+#define TCPC_ROLE_CTRL_RP_VAL_1_5	0x1
+#define TCPC_ROLE_CTRL_RP_VAL_3_0	0x2
+#define TCPC_ROLE_CTRL_CC2_SHIFT	2
+#define TCPC_ROLE_CTRL_CC2_MASK		0x3
+#define TCPC_ROLE_CTRL_CC1_SHIFT	0
+#define TCPC_ROLE_CTRL_CC1_MASK		0x3
+#define TCPC_ROLE_CTRL_CC_RA		0x0
+#define TCPC_ROLE_CTRL_CC_RP		0x1
+#define TCPC_ROLE_CTRL_CC_RD		0x2
+#define TCPC_ROLE_CTRL_CC_OPEN		0x3
+
+#define TCPC_POWER_CTRL						0x1c
+#define TCPC_POWER_CTRL_EN_VCONN			BIT(0)
+#define TCPC_POWER_CTRL_VCONN_POWER			BIT(1)
+#define TCPC_POWER_CTRL_FORCE_DISCH			BIT(2)
+#define TCPC_POWER_CTRL_EN_BLEED_CH			BIT(3)
+#define TCPC_POWER_CTRL_AUTO_DISCH_DISCO	BIT(4)
+#define TCPC_POWER_CTRL_DIS_V_ALARMS		BIT(5)
+#define TCPC_POWER_CTRL_VBUS_V_MONITOR		BIT(6)
+
+#define TCPC_CC_STATUS					0x1d
+#define TCPC_CC_STATUS_LOOK4CONN		BIT(5)
+#define TCPC_CC_STATUS_TERM				BIT(4)
+#define TCPC_CC_STATUS_CC2_SHIFT		2
+#define TCPC_CC_STATUS_CC2_MASK			0x3
+#define TCPC_CC_STATUS_CC1_SHIFT		0
+#define TCPC_CC_STATUS_CC1_MASK			0x3
+
+#define TCPC_POWER_STATUS				0x1e
+#define TCPC_POWER_STATUS_UNINIT		BIT(6)
+#define TCPC_POWER_STATUS_VBUS_DET		BIT(3)
+#define TCPC_POWER_STATUS_VBUS_PRES		BIT(2)
+#define TCPC_POWER_STATUS_SINKING_VBUS	BIT(0)
+
+#define TCPC_FAULT_STATUS               0x1f
+
+#define TCPC_COMMAND					0x23
+#define TCPC_CMD_WAKE_I2C				0x11
+#define TCPC_CMD_DISABLE_VBUS_DETECT	0x22
+#define TCPC_CMD_ENABLE_VBUS_DETECT		0x33
+#define TCPC_CMD_DISABLE_SINK_VBUS		0x44
+#define TCPC_CMD_SINK_VBUS				0x55
+#define TCPC_CMD_DISABLE_SRC_VBUS		0x66
+#define TCPC_CMD_SRC_VBUS_DEFAULT		0x77
+#define TCPC_CMD_SRC_VBUS_HIGH			0x88
+#define TCPC_CMD_LOOK4CONNECTION		0x99
+#define TCPC_CMD_RXONEMORE				0xAA
+#define TCPC_CMD_I2C_IDLE				0xFF
+
+#define TCPC_DEV_CAP_1					0x24
+#define TCPC_DEV_CAP_2					0x26
+#define TCPC_STD_INPUT_CAP				0x28
+#define TCPC_STD_OUTPUT_CAP				0x29
+
+#define TCPC_MSG_HDR_INFO				0x2e
+#define TCPC_MSG_HDR_INFO_DATA_ROLE		BIT(3)
+#define TCPC_MSG_HDR_INFO_PWR_ROLE		BIT(0)
+#define TCPC_MSG_HDR_INFO_REV_SHIFT		1
+#define TCPC_MSG_HDR_INFO_REV_MASK		0x3
+
+#define TCPC_RX_DETECT					0x2f
+#define TCPC_RX_DETECT_HARD_RESET		BIT(5)
+#define TCPC_RX_DETECT_SOP				BIT(0)
+
+#define TCPC_RX_BYTE_CNT				0x30
+#define TCPC_RX_BUF_FRAME_TYPE			0x31
+#define TCPC_RX_HDR						0x32
+#define TCPC_RX_DATA					0x34 /* through 0x4f */
+
+#define TCPC_TRANSMIT					0x50
+#define TCPC_TRANSMIT_RETRY_SHIFT		4
+#define TCPC_TRANSMIT_RETRY_MASK		0x3
+#define TCPC_TRANSMIT_TYPE_SHIFT		0
+#define TCPC_TRANSMIT_TYPE_MASK			0x7
+
+#define TCPC_TX_BYTE_CNT				0x51
+#define TCPC_TX_HDR						0x52
+#define TCPC_TX_DATA					0x54 /* through 0x6f */
+
+#define TCPC_VBUS_VOLTAGE					0x70
+#define TCPC_VBUS_VOL_MASK					0x3ff
+#define TCPC_VBUS_VOL_SCALE_FACTOR_MASK		0xc00
+#define TCPC_VBUS_VOL_SCALE_FACTOR_SHIFT	10
+#define TCPC_VBUS_VOL_MV_UNIT				25
+
+#define TCPC_VBUS_SINK_DISCONNECT_THRESH	0x72
+#define TCPC_VBUS_STOP_DISCHARGE_THRESH		0x74
+#define TCPC_VBUS_VOLTAGE_ALARM_HI_CFG		0x76
+#define TCPC_VBUS_VOLTAGE_ALARM_LO_CFG		0x78
+
+enum typec_role {
+	TYPEC_SINK,
+	TYPEC_SOURCE,
+	TYPEC_ROLE_UNKNOWN,
+};
+
+enum typec_data_role {
+	TYPEC_DEVICE,
+	TYPEC_HOST,
+};
+
+enum typec_cc_polarity {
+	TYPEC_POLARITY_CC1,
+	TYPEC_POLARITY_CC2,
+};
+
+enum typec_cc_state {
+	TYPEC_STATE_OPEN,
+	TYPEC_STATE_SRC_BOTH_RA,
+	TYPEC_STATE_SRC_RD_RA,
+	TYPEC_STATE_SRC_RD,
+	TYPEC_STATE_SRC_RESERVED,
+	TYPEC_STATE_SNK_DEFAULT,
+	TYPEC_STATE_SNK_POWER15,
+	TYPEC_STATE_SNK_POWER30,
+};
+
+
+/* USB PD Messages */
+enum pd_ctrl_msg_type {
+	/* 0 Reserved */
+	PD_CTRL_GOOD_CRC = 1,
+	PD_CTRL_GOTO_MIN = 2,
+	PD_CTRL_ACCEPT = 3,
+	PD_CTRL_REJECT = 4,
+	PD_CTRL_PING = 5,
+	PD_CTRL_PS_RDY = 6,
+	PD_CTRL_GET_SOURCE_CAP = 7,
+	PD_CTRL_GET_SINK_CAP = 8,
+	PD_CTRL_DR_SWAP = 9,
+	PD_CTRL_PR_SWAP = 10,
+	PD_CTRL_VCONN_SWAP = 11,
+	PD_CTRL_WAIT = 12,
+	PD_CTRL_SOFT_RESET = 13,
+	/* 14-15 Reserved */
+};
+
+enum pd_data_msg_type {
+	/* 0 Reserved */
+	PD_DATA_SOURCE_CAP = 1,
+	PD_DATA_REQUEST = 2,
+	PD_DATA_BIST = 3,
+	PD_DATA_SINK_CAP = 4,
+	/* 5-14 Reserved */
+	PD_DATA_VENDOR_DEF = 15,
+};
+
+enum tcpc_transmit_type {
+	TCPC_TX_SOP = 0,
+	TCPC_TX_SOP_PRIME = 1,
+	TCPC_TX_SOP_PRIME_PRIME = 2,
+	TCPC_TX_SOP_DEBUG_PRIME = 3,
+	TCPC_TX_SOP_DEBUG_PRIME_PRIME = 4,
+	TCPC_TX_HARD_RESET = 5,
+	TCPC_TX_CABLE_RESET = 6,
+	TCPC_TX_BIST_MODE_2 = 7
+};
+
+enum pd_sink_state{
+	UNATTACH = 0,
+	ATTACHED,
+	WAIT_SOURCE_CAP,
+	WAIT_SOURCE_ACCEPT,
+	WAIT_SOURCE_READY,
+	SINK_READY,
+};
+
+
+#define PD_REV10        0x0
+#define PD_REV20        0x1
+
+#define PD_HEADER_CNT_SHIFT     12
+#define PD_HEADER_CNT_MASK      0x7
+#define PD_HEADER_ID_SHIFT      9
+#define PD_HEADER_ID_MASK       0x7
+#define PD_HEADER_PWR_ROLE      BIT(8)
+#define PD_HEADER_REV_SHIFT     6
+#define PD_HEADER_REV_MASK      0x3
+#define PD_HEADER_DATA_ROLE     BIT(5)
+#define PD_HEADER_TYPE_SHIFT    0
+#define PD_HEADER_TYPE_MASK     0xf
+
+#define PD_HEADER(type, pwr, data, id, cnt)                             \
+	((((type) & PD_HEADER_TYPE_MASK) << PD_HEADER_TYPE_SHIFT) |     \
+	 ((pwr) == TYPEC_SOURCE ? PD_HEADER_PWR_ROLE : 0) |             \
+	 ((data) == TYPEC_HOST ? PD_HEADER_DATA_ROLE : 0) |             \
+	 (PD_REV20 << PD_HEADER_REV_SHIFT) |                            \
+	 (((id) & PD_HEADER_ID_MASK) << PD_HEADER_ID_SHIFT) |           \
+	 (((cnt) & PD_HEADER_CNT_MASK) << PD_HEADER_CNT_SHIFT))
+
+
+static inline unsigned int pd_header_cnt(uint16_t header)
+{
+	return (header >> PD_HEADER_CNT_SHIFT) & PD_HEADER_CNT_MASK;
+}
+
+static inline unsigned int pd_header_cnt_le(__le16 header)
+{
+	return pd_header_cnt(le16_to_cpu(header));
+}
+
+static inline unsigned int pd_header_type(uint16_t header)
+{
+	return (header >> PD_HEADER_TYPE_SHIFT) & PD_HEADER_TYPE_MASK;
+}
+
+static inline unsigned int pd_header_type_le(__le16 header)
+{
+	return pd_header_type(le16_to_cpu(header));
+}
+
+#define PD_MAX_PAYLOAD          7
+
+struct pd_message {
+	uint8_t   frametype;
+	uint16_t  header;
+	uint32_t  payload[PD_MAX_PAYLOAD];
+} __packed;
+
+enum pd_pdo_type {
+	PDO_TYPE_FIXED = 0,
+	PDO_TYPE_BATT = 1,
+	PDO_TYPE_VAR = 2,
+};
+
+
+#define PDO_TYPE_SHIFT          30
+#define PDO_TYPE_MASK           0x3
+
+#define PDO_TYPE(t)     ((t) << PDO_TYPE_SHIFT)
+
+#define PDO_VOLT_MASK           0x3ff
+#define PDO_CURR_MASK           0x3ff
+#define PDO_PWR_MASK            0x3ff
+
+#define PDO_FIXED_DUAL_ROLE     BIT(29) /* Power role swap supported */
+#define PDO_FIXED_SUSPEND       BIT(28) /* USB Suspend supported (Source) */
+#define PDO_FIXED_HIGHER_CAP    BIT(28) /* Requires more than vSafe5V (Sink) */
+#define PDO_FIXED_EXTPOWER      BIT(27) /* Externally powered */
+#define PDO_FIXED_USB_COMM      BIT(26) /* USB communications capable */
+#define PDO_FIXED_DATA_SWAP     BIT(25) /* Data role swap supported */
+#define PDO_FIXED_VOLT_SHIFT    10      /* 50mV units */
+#define PDO_FIXED_CURR_SHIFT    0       /* 10mA units */
+
+#define PDO_FIXED_VOLT(mv)      ((((mv) / 50) & PDO_VOLT_MASK) << PDO_FIXED_VOLT_SHIFT)
+#define PDO_FIXED_CURR(ma)      ((((ma) / 10) & PDO_CURR_MASK) << PDO_FIXED_CURR_SHIFT)
+
+#define PDO_FIXED(mv, ma, flags)                        \
+	(PDO_TYPE(PDO_TYPE_FIXED) | (flags) |           \
+	 PDO_FIXED_VOLT(mv) | PDO_FIXED_CURR(ma))
+
+#define PDO_BATT_MAX_VOLT_SHIFT 20      /* 50mV units */
+#define PDO_BATT_MIN_VOLT_SHIFT 10      /* 50mV units */
+#define PDO_BATT_MAX_PWR_SHIFT  0       /* 250mW units */
+
+#define PDO_BATT_MIN_VOLT(mv) ((((mv) / 50) & PDO_VOLT_MASK) << PDO_BATT_MIN_VOLT_SHIFT)
+#define PDO_BATT_MAX_VOLT(mv) ((((mv) / 50) & PDO_VOLT_MASK) << PDO_BATT_MAX_VOLT_SHIFT)
+#define PDO_BATT_MAX_POWER(mw) ((((mw) / 250) & PDO_PWR_MASK) << PDO_BATT_MAX_PWR_SHIFT)
+
+#define PDO_BATT(min_mv, max_mv, max_mw)                        \
+	(PDO_TYPE(PDO_TYPE_BATT) | PDO_BATT_MIN_VOLT(min_mv) |  \
+	 PDO_BATT_MAX_VOLT(max_mv) | PDO_BATT_MAX_POWER(max_mw))
+
+#define PDO_VAR_MAX_VOLT_SHIFT  20      /* 50mV units */
+#define PDO_VAR_MIN_VOLT_SHIFT  10      /* 50mV units */
+#define PDO_VAR_MAX_CURR_SHIFT  0       /* 10mA units */
+
+#define PDO_VAR_MIN_VOLT(mv) ((((mv) / 50) & PDO_VOLT_MASK) << PDO_VAR_MIN_VOLT_SHIFT)
+#define PDO_VAR_MAX_VOLT(mv) ((((mv) / 50) & PDO_VOLT_MASK) << PDO_VAR_MAX_VOLT_SHIFT)
+#define PDO_VAR_MAX_CURR(ma) ((((ma) / 10) & PDO_CURR_MASK) << PDO_VAR_MAX_CURR_SHIFT)
+
+#define PDO_VAR(min_mv, max_mv, max_ma)                         \
+	(PDO_TYPE(PDO_TYPE_VAR) | PDO_VAR_MIN_VOLT(min_mv) |    \
+	 PDO_VAR_MAX_VOLT(max_mv) | PDO_VAR_MAX_CURR(max_ma))
+
+static inline enum pd_pdo_type pdo_type(uint32_t pdo)
+{
+	return (pdo >> PDO_TYPE_SHIFT) & PDO_TYPE_MASK;
+}
+
+static inline unsigned int pdo_fixed_voltage(uint32_t pdo)
+{
+	return ((pdo >> PDO_FIXED_VOLT_SHIFT) & PDO_VOLT_MASK) * 50;
+}
+
+static inline unsigned int pdo_min_voltage(uint32_t pdo)
+{
+	return ((pdo >> PDO_VAR_MIN_VOLT_SHIFT) & PDO_VOLT_MASK) * 50;
+}
+
+static inline unsigned int pdo_max_voltage(uint32_t pdo)
+{
+	return ((pdo >> PDO_VAR_MAX_VOLT_SHIFT) & PDO_VOLT_MASK) * 50;
+}
+
+static inline unsigned int pdo_max_current(uint32_t pdo)
+{
+	return ((pdo >> PDO_VAR_MAX_CURR_SHIFT) & PDO_CURR_MASK) * 10;
+}
+
+static inline unsigned int pdo_max_power(uint32_t pdo)
+{
+	return ((pdo >> PDO_BATT_MAX_PWR_SHIFT) & PDO_PWR_MASK) * 250;
+}
+
+/* RDO: Request Data Object */
+#define RDO_OBJ_POS_SHIFT       28
+#define RDO_OBJ_POS_MASK        0x7
+#define RDO_GIVE_BACK           BIT(27) /* Supports reduced operating current */
+#define RDO_CAP_MISMATCH        BIT(26) /* Not satisfied by source caps */
+#define RDO_USB_COMM            BIT(25) /* USB communications capable */
+#define RDO_NO_SUSPEND          BIT(24) /* USB Suspend not supported */
+
+#define RDO_PWR_MASK                    0x3ff
+#define RDO_CURR_MASK                   0x3ff
+
+#define RDO_FIXED_OP_CURR_SHIFT         10
+#define RDO_FIXED_MAX_CURR_SHIFT        0
+
+#define RDO_OBJ(idx) (((idx) & RDO_OBJ_POS_MASK) << RDO_OBJ_POS_SHIFT)
+
+#define PDO_FIXED_OP_CURR(ma) ((((ma) / 10) & RDO_CURR_MASK) << RDO_FIXED_OP_CURR_SHIFT)
+#define PDO_FIXED_MAX_CURR(ma) ((((ma) / 10) & RDO_CURR_MASK) << RDO_FIXED_MAX_CURR_SHIFT)
+
+#define RDO_FIXED(idx, op_ma, max_ma, flags)                    \
+	(RDO_OBJ(idx) | (flags) |                               \
+	 PDO_FIXED_OP_CURR(op_ma) | PDO_FIXED_MAX_CURR(max_ma))
+
+#define RDO_BATT_OP_PWR_SHIFT           10      /* 250mW units */
+#define RDO_BATT_MAX_PWR_SHIFT          0       /* 250mW units */
+
+#define RDO_BATT_OP_PWR(mw) ((((mw) / 250) & RDO_PWR_MASK) << RDO_BATT_OP_PWR_SHIFT)
+#define RDO_BATT_MAX_PWR(mw) ((((mw) / 250) & RDO_PWR_MASK) << RDO_BATT_MAX_PWR_SHIFT)
+
+#define RDO_BATT(idx, op_mw, max_mw, flags)                     \
+	(RDO_OBJ(idx) | (flags) |                               \
+	 RDO_BATT_OP_PWR(op_mw) | RDO_BATT_MAX_PWR(max_mw))
+
+static inline unsigned int rdo_index(u32 rdo)
+{
+	return (rdo >> RDO_OBJ_POS_SHIFT) & RDO_OBJ_POS_MASK;
+}
+
+static inline unsigned int rdo_op_current(u32 rdo)
+{
+	return ((rdo >> RDO_FIXED_OP_CURR_SHIFT) & RDO_CURR_MASK) * 10;
+}
+
+static inline unsigned int rdo_max_current(u32 rdo)
+{
+	return ((rdo >> RDO_FIXED_MAX_CURR_SHIFT) &
+			RDO_CURR_MASK) * 10;
+}
+
+static inline unsigned int rdo_op_power(u32 rdo)
+{
+	return ((rdo >> RDO_BATT_OP_PWR_SHIFT) & RDO_PWR_MASK) * 250;
+}
+
+static inline unsigned int rdo_max_power(u32 rdo)
+{
+	return ((rdo >> RDO_BATT_MAX_PWR_SHIFT) & RDO_PWR_MASK) * 250;
+}
+
+#define TCPC_LOG_BUFFER_SIZE 1024
+
+struct tcpc_port;
+
+typedef void (*ss_mux_sel)(enum typec_cc_polarity pol);
+typedef int (*ext_pd_switch_setup)(struct tcpc_port *port_p);
+
+enum tcpc_port_type {
+	TYPEC_PORT_DFP,
+	TYPEC_PORT_UFP,
+	TYPEC_PORT_DRP,
+};
+
+struct tcpc_port_config {
+	uint8_t i2c_bus;
+	uint8_t addr;
+	enum tcpc_port_type port_type;
+	uint32_t max_snk_mv;
+	uint32_t max_snk_ma;
+	uint32_t max_snk_mw;
+	uint32_t op_snk_mv;
+	bool disable_pd;
+	ext_pd_switch_setup switch_setup_func;
+};
+
+struct tcpc_port {
+	struct tcpc_port_config cfg;
+	struct udevice *i2c_dev;
+	ss_mux_sel ss_sel_func;
+	enum pd_sink_state pd_state;
+	uint32_t tx_msg_id;
+	uint32_t log_size;
+	char logbuffer[TCPC_LOG_BUFFER_SIZE];
+	char *log_p;
+	char *log_print;
+};
+
+int tcpc_set_cc_to_source(struct tcpc_port *port);
+int tcpc_set_cc_to_sink(struct tcpc_port *port);
+int tcpc_set_plug_orientation(struct tcpc_port *port, enum typec_cc_polarity polarity);
+int tcpc_get_cc_status(struct tcpc_port *port, enum typec_cc_polarity *polarity, enum typec_cc_state *state);
+int tcpc_clear_alert(struct tcpc_port *port, uint16_t clear_mask);
+int tcpc_send_command(struct tcpc_port *port, uint8_t command);
+int tcpc_polling_reg(struct tcpc_port *port, uint8_t reg,
+	uint8_t reg_width, uint16_t mask, uint16_t value, ulong timeout_ms);
+int tcpc_setup_dfp_mode(struct tcpc_port *port);
+int tcpc_setup_ufp_mode(struct tcpc_port *port);
+int tcpc_disable_src_vbus(struct tcpc_port *port);
+int tcpc_init(struct tcpc_port *port, struct tcpc_port_config config, ss_mux_sel ss_sel_func);
+bool tcpc_pd_sink_check_charging(struct tcpc_port *port);
+void tcpc_print_log(struct tcpc_port *port);
+
+#ifdef CONFIG_SPL_BUILD
+int tcpc_setup_ufp_mode(struct tcpc_port *port)
+{
+	return 0;
+}
+int tcpc_setup_dfp_mode(struct tcpc_port *port)
+{
+	return 0;
+}
+
+int tcpc_disable_src_vbus(struct tcpc_port *port)
+{
+	return 0;
+}
+#endif
+#endif /* __TCPCI_H */
diff --git a/board/seco/seco_imx8mm_c61/wdt.h b/board/seco/seco_imx8mm_c61/wdt.h
new file mode 100644
index 0000000000..a0ad859dd5
--- /dev/null
+++ b/board/seco/seco_imx8mm_c61/wdt.h
@@ -0,0 +1,34 @@
+
+#ifndef __SECO_WDT_H
+#define __SECO_WDT_H
+
+#include <common.h>
+#include <asm/io.h>
+#include <watchdog.h>
+#include <asm/arch/imx-regs.h>
+
+
+#ifdef CONFIG_APX_WATCHDOG
+
+#define WDT_IOMUX_REG(x)        ((x))
+#define WDT_PADCTRL_REG(x)      ((x))
+#define WDT_GDIR_REG(x)         ((x) + 0x4) 
+#define WDT_DR_REG(x)           ((x))
+
+
+ 
+#define WDT_PAD_MUX_GPIO(x)     writel(readl(WDT_IOMUX_REG((x))) | 0x5, WDT_IOMUX_REG((x)))
+
+#define WDT_PAD_CTRL_GPIO(x)    writel(0x06028, WDT_PADCTRL_REG((x)))
+
+#define WDT_DIR_OUT_GPIO(x,n)   writel(readl(WDT_GDIR_REG((x))) | ( 1 << (n)), WDT_GDIR_REG((x)))
+
+#define WDT_SET_H_GPIO(x,n)     writel(readl(WDT_DR_REG((x))) | (1 << (n)) , WDT_DR_REG((x)))
+
+#define WDT_SET_L_GPIO(x,n)     writel(readl(WDT_DR_REG((x))) & ~(1 << (n)) , WDT_DR_REG((x)))
+
+
+
+#endif /* __SECO_WDT_H */
+#endif
+
diff --git a/arch/arm/dts/Makefile b/arch/arm/dts/Makefile
index 960f1a9fd4..5ef10b4eeb 100644
--- a/arch/arm/dts/Makefile
+++ b/arch/arm/dts/Makefile
@@ -926,7 +926,9 @@ dtb-$(CONFIG_ARCH_IMX8M) += \
 	imx8mp-phyboard-pollux-rdk.dtb \
 	imx8mp-verdin.dtb \
 	imx8mq-pico-pi.dtb \
-	imx8mq-kontron-pitx-imx8m.dtb
+	imx8mq-kontron-pitx-imx8m.dtb \
+	seco-imx8mm-c61.dtb
+
 
 dtb-$(CONFIG_ARCH_IMXRT) += imxrt1050-evk.dtb \
 	imxrt1020-evk.dtb
diff --git a/arch/arm/dts/seco-imx8mm-c61-u-boot.dtsi b/arch/arm/dts/seco-imx8mm-c61-u-boot.dtsi
new file mode 100644
index 0000000000..b46f109324
--- /dev/null
+++ b/arch/arm/dts/seco-imx8mm-c61-u-boot.dtsi
@@ -0,0 +1,167 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2019 NXP
+ */
+
+#include "imx8mm-u-boot.dtsi"
+
+/ {
+
+	aliases {
+		usbgadget0 = &usbg1;
+		usbgadget1 = &usbg2;
+	};
+
+	usbg1: usbg1 {
+		compatible = "fsl,imx27-usb-gadget";
+		dr_mode = "peripheral";
+		chipidea,usb = <&usbotg1>;
+		status = "okay";
+	};
+
+	usbg2: usbg2 {
+		compatible = "fsl,imx27-usb-gadget";
+		dr_mode = "peripheral";
+		chipidea,usb = <&usbotg2>;
+		status = "okay";
+	};
+
+	firmware {
+		optee {
+			compatible = "linaro,optee-tz";
+			method = "smc";
+		};
+	};
+};
+
+//&binman_fip {
+//	arch = "arm64";
+//	compression = "none";
+//	description = "Trusted Firmware FIP";
+//	load = <0x40310000>;
+//	type = "firmware";
+//
+//	fip_blob {
+//		filename = "fip.bin";
+//		type = "blob-ext";
+//	};
+//};
+
+//&binman_configuration {
+//	loadables = "atf", "fip";
+//};
+
+&binman {
+	itb {
+		fit {
+			images {
+				bl32 {
+					description = "OP-TEE Trusted OS (bl32)";
+					type = "firmware";
+					arch = "arm";
+					os = "tee";
+					compression = "none";
+					load = <CONFIG_BL32_ENTRY_ADDR>;
+					entry = <CONFIG_BL32_ENTRY_ADDR>;
+
+					blob-ext {
+						filename = "tee.bin";
+					};
+				};
+			};
+		};
+	};
+};
+&binman_configuration {
+	loadables = "atf", "bl32";
+};
+
+&reg_usdhc2_vmmc {
+	u-boot,dm-spl;
+};
+
+&pinctrl_reg_usdhc2_vmmc {
+	u-boot,dm-spl;
+};
+
+&pinctrl_uart2 {
+	u-boot,dm-spl;
+};
+
+&pinctrl_usdhc2_gpio {
+	u-boot,dm-spl;
+};
+
+&pinctrl_usdhc2 {
+	u-boot,dm-spl;
+};
+
+&pinctrl_usdhc3 {
+	u-boot,dm-spl;
+};
+
+&gpio1 {
+	u-boot,dm-spl;
+};
+
+&gpio2 {
+	u-boot,dm-spl;
+};
+
+&gpio3 {
+	u-boot,dm-spl;
+};
+
+&gpio4 {
+	u-boot,dm-spl;
+};
+
+&gpio5 {
+	u-boot,dm-spl;
+};
+
+&uart2 {
+	u-boot,dm-spl;
+};
+
+&usdhc1 {
+	u-boot,dm-spl;
+};
+
+&usdhc2 {
+	u-boot,dm-spl;
+	sd-uhs-sdr104;
+	sd-uhs-ddr50;
+};
+
+&usdhc3 {
+	u-boot,dm-spl;
+	mmc-hs400-1_8v;
+	mmc-hs400-enhanced-strobe;
+};
+
+&i2c1 {
+	u-boot,dm-spl;
+};
+
+&{/soc@0/bus@30800000/i2c@30a20000/pmic@4b} {
+	u-boot,dm-spl;
+};
+
+&{/soc@0/bus@30800000/i2c@30a20000/pmic@4b/regulators} {
+	u-boot,dm-spl;
+};
+
+&pinctrl_i2c1 {
+	u-boot,dm-spl;
+};
+
+&pinctrl_pmic {
+	u-boot,dm-spl;
+};
+
+&flexspi {
+	assigned-clock-rates = <100000000>;
+	assigned-clocks = <&clk IMX8MM_CLK_QSPI>;
+	assigned-clock-parents = <&clk IMX8MM_SYS_PLL1_100M>;
+};
diff --git a/arch/arm/dts/seco-imx8mm-c61.dts b/arch/arm/dts/seco-imx8mm-c61.dts
new file mode 100644
index 0000000000..1a52e8b883
--- /dev/null
+++ b/arch/arm/dts/seco-imx8mm-c61.dts
@@ -0,0 +1,640 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright 2019 NXP
+ */
+
+/dts-v1/;
+
+#include <dt-bindings/usb/pd.h>
+#include "imx8mm.dtsi"
+#include "dt-bindings/net/ti-dp83867.h"
+
+/ {
+	model = "SECO i.MX8MM C61 board";
+	compatible = "fsl,imx8mm-evk", "seco,seco-imx8mm-c61", "fsl,imx8mm";
+
+	chosen {
+		bootargs = "console=ttymxc1,115200 earlycon=ec_imx6q,0x30890000,115200";
+		stdout-path = &uart2;
+	};
+
+	aliases {
+		usbgadget0 = &usbg1;
+		usbgadget1 = &usbg2;
+		mmc0 = &usdhc3;
+		mmc1 = &usdhc2;
+	};
+
+	firmware {
+		optee {
+			compatible = "linaro,optee-tz";
+			method = "smc";
+		};
+	};
+
+	leds {
+		compatible = "gpio-leds";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_gpio_led>;
+
+		status {
+			label = "status";
+			gpios = <&gpio3 16 GPIO_ACTIVE_HIGH>;
+			default-state = "on";
+		};
+	};
+
+	reg_usdhc2_vmmc: regulator-usdhc2 {
+		compatible = "regulator-fixed";
+		regulator-name = "VSD_3V3";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		gpio = <&gpio2 19 GPIO_ACTIVE_HIGH>;
+		u-boot,off-on-delay-us = <20000>;
+		enable-active-high;
+	};
+
+	wm8524: audio-codec {
+		#sound-dai-cells = <0>;
+		compatible = "wlf,wm8524";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_gpio_wlf>;
+		wlf,mute-gpios = <&gpio5 21 GPIO_ACTIVE_LOW>;
+	};
+
+	usbg1: usbg1 {
+		compatible = "fsl,imx27-usb-gadget";
+		dr_mode = "peripheral";
+		chipidea,usb = <&usbotg1>;
+		status = "okay";
+	};
+
+	usbg2: usbg2 {
+		compatible = "fsl,imx27-usb-gadget";
+		dr_mode = "peripheral";
+		chipidea,usb = <&usbotg2>;
+		status = "okay";
+	};
+
+	sound-wm8524 {
+		compatible = "simple-audio-card";
+		simple-audio-card,name = "wm8524-audio";
+		simple-audio-card,format = "i2s";
+		simple-audio-card,frame-master = <&cpudai>;
+		simple-audio-card,bitclock-master = <&cpudai>;
+		simple-audio-card,widgets =
+			"Line", "Left Line Out Jack",
+			"Line", "Right Line Out Jack";
+		simple-audio-card,routing =
+			"Left Line Out Jack", "LINEVOUTL",
+			"Right Line Out Jack", "LINEVOUTR";
+
+		cpudai: simple-audio-card,cpu {
+			sound-dai = <&sai3>;
+		};
+
+		simple-audio-card,codec {
+			sound-dai = <&wm8524>;
+			clocks = <&clk IMX8MM_CLK_SAI3_ROOT>;
+		};
+	};
+
+	dsi_host: dsi-host {
+		compatible = "samsung,sec-mipi-dsi";
+		status = "okay";
+	};
+};
+
+&A53_0 {
+	cpu-supply = <&buck2_reg>;
+};
+
+&clk {
+	/delete-property/ assigned-clocks;
+	/delete-property/ assigned-clock-parents;
+	/delete-property/ assigned-clock-rates;
+};
+
+&fec1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_fec1>;
+	phy-mode = "rgmii-id";
+	phy-handle = <&ethphy0>;
+	fsl,magic-packet;
+	phy-reset-gpios = <&tca6416_20 12 GPIO_ACTIVE_LOW>;
+	phy-reset-duration = <1>;
+	phy-reset-post-delay = <1>;
+	status = "okay";
+
+	mdio {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		ethphy0: ethernet-phy@9 {
+			compatible = "ethernet-phy-ieee802.3-c22";
+			reg = <9>;
+			ti,rx-internal-delay = <DP83867_RGMIIDCTL_2_00_NS>;
+			ti,tx-internal-delay = <DP83867_RGMIIDCTL_2_00_NS>;
+			ti,fifo-depth = <DP83867_PHYCR_FIFO_DEPTH_8_B_NIB>;
+		};
+	};
+};
+
+&flexspi {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_flexspi0>;
+	status = "okay";
+
+	flash0: mt25qu256aba@0 {
+		reg = <0>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "jedec,spi-nor";
+		spi-max-frequency = <80000000>;
+		spi-tx-bus-width = <4>;
+		spi-rx-bus-width = <4>;
+	};
+};
+
+&i2c1 {
+	clock-frequency = <400000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c1>;
+	status = "okay";
+
+	pmic@4b {
+		compatible = "rohm,bd71847";
+		reg = <0x4b>;
+		pinctrl-0 = <&pinctrl_pmic>;
+		gpio_intr = <&gpio1 3 GPIO_ACTIVE_LOW>;
+		interrupt-parent = <&gpio1>;
+		interrupts = <3 GPIO_ACTIVE_LOW>;
+
+		gpo {
+			rohm,drv = <0x0C>;      /* 0b0000_1100 all gpos with cmos output mode */
+		};
+
+		regulators {
+			bd71837,pmic-buck2-uses-i2c-dvs;
+			bd71837,pmic-buck2-dvs-voltage = <1000000>,
+				<900000>,
+				<0>; /* VDD_ARM: Run-Idle */
+			buck1_reg: BUCK1 {
+				regulator-name = "BUCK1";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <1300000>;
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-ramp-delay = <1250>;
+			};
+
+			buck2_reg: BUCK2 {
+				regulator-name = "BUCK2";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <1300000>;
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-ramp-delay = <1250>;
+			};
+
+			buck3_reg: BUCK3 {
+				regulator-name = "BUCK3";
+				regulator-min-microvolt = <700000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			buck4_reg: BUCK4 {
+				regulator-name = "BUCK4";
+				regulator-min-microvolt = <3000000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			buck5_reg: BUCK5 {
+				regulator-name = "BUCK5";
+				regulator-min-microvolt = <1605000>;
+				regulator-max-microvolt = <1995000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			buck6_reg: BUCK6 {
+				regulator-name = "BUCK6";
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <1400000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo1_reg: LDO1 {
+				regulator-name = "LDO1";
+				regulator-min-microvolt = <1600000>;
+				regulator-max-microvolt = <1900000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo2_reg: LDO2 {
+				regulator-name = "LDO2";
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <900000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo3_reg: LDO3 {
+				regulator-name = "LDO3";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo4_reg: LDO4 {
+				regulator-name = "LDO4";
+				regulator-min-microvolt = <900000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo6_reg: LDO6 {
+				regulator-name = "LDO6";
+				regulator-min-microvolt = <900000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+		};
+	};
+};
+
+&i2c2 {
+	clock-frequency = <400000>;
+	pinctrl-names = "default", "gpio";
+	pinctrl-0 = <&pinctrl_i2c2>;
+	pinctrl-1 = <&pinctrl_i2c2_gpio>;
+	scl-gpios = <&gpio5 16 GPIO_ACTIVE_HIGH>;
+	sda-gpios = <&gpio5 17 GPIO_ACTIVE_HIGH>;
+	status = "okay";
+
+	ptn5110: tcpc@50 {
+		compatible = "nxp,ptn5110";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_typec1>;
+		reg = <0x50>;
+		interrupt-parent = <&gpio2>;
+		interrupts = <11 8>;
+		status = "okay";
+
+		typec1_con: connector {
+			compatible = "usb-c-connector";
+			label = "USB-C";
+			power-role = "dual";
+			data-role = "dual";
+			try-power-role = "sink";
+			source-pdos = <PDO_FIXED(5000, 3000, PDO_FIXED_USB_COMM)>;
+			sink-pdos = <PDO_FIXED(5000, 3000, PDO_FIXED_USB_COMM)
+				     PDO_VAR(5000, 20000, 3000)>;
+			op-sink-microwatt = <15000000>;
+			self-powered;
+		};
+	};
+
+	ptn5110_2: tcpc@52 {
+		compatible = "nxp,ptn5110";
+		reg = <0x52>;
+		status = "okay";
+
+		typec2_con: connector {
+			compatible = "usb-c-connector";
+			label = "USB-C";
+			power-role = "dual";
+			data-role = "dual";
+			try-power-role = "sink";
+			source-pdos = <PDO_FIXED(5000, 3000, PDO_FIXED_USB_COMM)>;
+			sink-pdos = <PDO_FIXED(5000, 3000, PDO_FIXED_USB_COMM)
+				     PDO_VAR(5000, 20000, 3000)>;
+			op-sink-microwatt = <15000000>;
+			self-powered;
+		};
+	};
+};
+
+&i2c3 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default", "gpio";
+	pinctrl-0 = <&pinctrl_i2c3>;
+	pinctrl-1 = <&pinctrl_i2c3_gpio>;
+	scl-gpios = <&gpio5 18 GPIO_ACTIVE_HIGH>;
+	sda-gpios = <&gpio5 19 GPIO_ACTIVE_HIGH>;
+	status = "okay";
+};
+
+&i2c4 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c4>;
+	status = "okay";
+
+	tca6416_20: gpio@20 {
+		compatible = "ti,tca6416";
+		reg = <0x20>;
+		gpio-controller;
+		#gpio-cells = <2>;
+		pinctrl-0 = <&pinctrl_tca6416_20>;
+		interrupt-parent = <&gpio4>;
+		interrupts = <22 IRQ_TYPE_LEVEL_LOW>;
+	};
+
+	tca6416_21: gpio@21 {
+		compatible = "ti,tca6416";
+		reg = <0x21>;
+		gpio-controller;
+		#gpio-cells = <2>;
+	};
+
+};
+
+&sai3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_sai3>;
+	assigned-clocks = <&clk IMX8MM_CLK_SAI3>;
+	assigned-clock-parents = <&clk IMX8MM_AUDIO_PLL1_OUT>;
+	assigned-clock-rates = <24576000>;
+	status = "okay";
+};
+
+&snvs_pwrkey {
+	status = "okay";
+};
+
+&uart2 { /* console */
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart2>;
+	status = "okay";
+};
+
+&usbotg1 {
+	status = "okay";
+};
+
+&usbotg2 {
+	status = "okay";
+	dr_mode = "host";
+};
+
+&usdhc2 {
+	pinctrl-names = "default", "state_100mhz", "state_200mhz";
+	pinctrl-0 = <&pinctrl_usdhc2>, <&pinctrl_usdhc2_gpio>;
+	pinctrl-1 = <&pinctrl_usdhc2_100mhz>, <&pinctrl_usdhc2_gpio>;
+	pinctrl-2 = <&pinctrl_usdhc2_200mhz>, <&pinctrl_usdhc2_gpio>;
+	bus-width = <4>;
+	non-removable;
+	vmmc-supply = <&reg_usdhc2_vmmc>;
+	status = "okay";
+};
+
+&usdhc3 {
+	pinctrl-names = "default", "state_100mhz", "state_200mhz";
+	pinctrl-0 = <&pinctrl_usdhc3>;
+	pinctrl-1 = <&pinctrl_usdhc3_100mhz>;
+	pinctrl-2 = <&pinctrl_usdhc3_200mhz>;
+	bus-width = <8>;
+	non-removable;
+	status = "okay";
+};
+
+&wdog1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_wdog>;
+	fsl,ext-reset-output;
+	status = "disabled";
+};
+
+&iomuxc {
+	pinctrl-names = "default";
+
+	pinctrl_fec1: fec1grp {
+		fsl,pins = <
+			MX8MM_IOMUXC_ENET_MDC_ENET1_MDC			0x3
+			MX8MM_IOMUXC_ENET_MDIO_ENET1_MDIO		0x3
+			MX8MM_IOMUXC_ENET_TD3_ENET1_RGMII_TD3		0x1f
+			MX8MM_IOMUXC_ENET_TD2_ENET1_RGMII_TD2		0x1f
+			MX8MM_IOMUXC_ENET_TD1_ENET1_RGMII_TD1		0x1f
+			MX8MM_IOMUXC_ENET_TD0_ENET1_RGMII_TD0		0x1f
+			MX8MM_IOMUXC_ENET_RD3_ENET1_RGMII_RD3		0x91
+			MX8MM_IOMUXC_ENET_RD2_ENET1_RGMII_RD2		0x91
+			MX8MM_IOMUXC_ENET_RD1_ENET1_RGMII_RD1		0x91
+			MX8MM_IOMUXC_ENET_RD0_ENET1_RGMII_RD0		0x91
+			MX8MM_IOMUXC_ENET_TXC_ENET1_RGMII_TXC		0x1f
+			MX8MM_IOMUXC_ENET_RXC_ENET1_RGMII_RXC		0x91
+			MX8MM_IOMUXC_ENET_RX_CTL_ENET1_RGMII_RX_CTL	0x91
+			MX8MM_IOMUXC_ENET_TX_CTL_ENET1_RGMII_TX_CTL	0x1f
+		>;
+	};
+
+	pinctrl_flexspi0: flexspi0grp {
+		fsl,pins = <
+			MX8MM_IOMUXC_NAND_ALE_QSPI_A_SCLK               0x1c2
+			MX8MM_IOMUXC_NAND_CE0_B_QSPI_A_SS0_B            0x82
+			MX8MM_IOMUXC_NAND_DATA00_QSPI_A_DATA0           0x82
+			MX8MM_IOMUXC_NAND_DATA01_QSPI_A_DATA1           0x82
+			MX8MM_IOMUXC_NAND_DATA02_QSPI_A_DATA2           0x82
+			MX8MM_IOMUXC_NAND_DATA03_QSPI_A_DATA3           0x82
+		>;
+	};
+
+	pinctrl_gpio_led: gpioledgrp {
+		fsl,pins = <
+			MX8MM_IOMUXC_NAND_READY_B_GPIO3_IO16	0x19
+		>;
+	};
+
+	pinctrl_gpio_wlf: gpiowlfgrp {
+		fsl,pins = <
+			MX8MM_IOMUXC_I2C4_SDA_GPIO5_IO21	0xd6
+		>;
+	};
+
+	pinctrl_i2c1: i2c1grp {
+		fsl,pins = <
+			MX8MM_IOMUXC_I2C1_SCL_I2C1_SCL			0x400001c3
+			MX8MM_IOMUXC_I2C1_SDA_I2C1_SDA			0x400001c3
+		>;
+	};
+
+	pinctrl_i2c2: i2c2grp {
+		fsl,pins = <
+			MX8MM_IOMUXC_I2C2_SCL_I2C2_SCL			0x400001c3
+			MX8MM_IOMUXC_I2C2_SDA_I2C2_SDA			0x400001c3
+		>;
+	};
+
+	pinctrl_i2c3: i2c3grp {
+		fsl,pins = <
+			MX8MM_IOMUXC_I2C3_SCL_I2C3_SCL			0x400001c3
+			MX8MM_IOMUXC_I2C3_SDA_I2C3_SDA			0x400001c3
+		>;
+	};
+
+	pinctrl_i2c4: i2c4grp {
+		fsl,pins = <
+			MX8MM_IOMUXC_I2C4_SCL_I2C4_SCL			0x400001c3
+			MX8MM_IOMUXC_I2C4_SDA_I2C4_SDA			0x400001c3
+		>;
+	};
+
+	pinctrl_i2c2_gpio: i2c2grp-gpio {
+		fsl,pins = <
+			MX8MM_IOMUXC_I2C2_SCL_GPIO5_IO16        		0x1c3
+			MX8MM_IOMUXC_I2C2_SDA_GPIO5_IO17        	0x1c3
+		>;
+	};
+
+	pinctrl_i2c3_gpio: i2c3grp-gpio {
+		fsl,pins = <
+			MX8MM_IOMUXC_I2C3_SCL_GPIO5_IO18        		0x1c3
+			MX8MM_IOMUXC_I2C3_SDA_GPIO5_IO19        	0x1c3
+		>;
+	};
+
+	pinctrl_pmic: pmicirq {
+		fsl,pins = <
+			MX8MM_IOMUXC_GPIO1_IO03_GPIO1_IO3		0x41
+		>;
+	};
+
+	pinctrl_reg_usdhc2_vmmc: regusdhc2vmmc {
+		fsl,pins = <
+			MX8MM_IOMUXC_SD2_RESET_B_GPIO2_IO19	0x41
+		>;
+	};
+
+	pinctrl_sai3: sai3grp {
+		fsl,pins = <
+			MX8MM_IOMUXC_SAI3_TXFS_SAI3_TX_SYNC     0xd6
+			MX8MM_IOMUXC_SAI3_TXC_SAI3_TX_BCLK      0xd6
+			MX8MM_IOMUXC_SAI3_MCLK_SAI3_MCLK        0xd6
+			MX8MM_IOMUXC_SAI3_TXD_SAI3_TX_DATA0     0xd6
+		>;
+	};
+
+	pinctrl_typec1: typec1grp {
+		fsl,pins = <
+			MX8MM_IOMUXC_SD1_STROBE_GPIO2_IO11	0x159
+		>;
+	};
+
+	pinctrl_uart2: uart2grp {
+		fsl,pins = <
+			MX8MM_IOMUXC_UART2_RXD_UART2_DCE_RX	0x140
+			MX8MM_IOMUXC_UART2_TXD_UART2_DCE_TX	0x140
+		>;
+	};
+
+	pinctrl_usdhc2_gpio: usdhc2grpgpio {
+		fsl,pins = <
+			MX8MM_IOMUXC_GPIO1_IO15_GPIO1_IO15	0x1c4
+		>;
+	};
+
+	pinctrl_usdhc2: usdhc2grp {
+		fsl,pins = <
+			MX8MM_IOMUXC_SD2_CLK_USDHC2_CLK		0x190
+			MX8MM_IOMUXC_SD2_CMD_USDHC2_CMD		0x1d0
+			MX8MM_IOMUXC_SD2_DATA0_USDHC2_DATA0	0x1d0
+			MX8MM_IOMUXC_SD2_DATA1_USDHC2_DATA1	0x1d0
+			MX8MM_IOMUXC_SD2_DATA2_USDHC2_DATA2	0x1d0
+			MX8MM_IOMUXC_SD2_DATA3_USDHC2_DATA3	0x1d0
+			MX8MM_IOMUXC_GPIO1_IO04_USDHC2_VSELECT	0x1d0
+		>;
+	};
+
+	pinctrl_usdhc2_100mhz: usdhc2grp100mhz {
+		fsl,pins = <
+			MX8MM_IOMUXC_SD2_CLK_USDHC2_CLK		0x194
+			MX8MM_IOMUXC_SD2_CMD_USDHC2_CMD		0x1d4
+			MX8MM_IOMUXC_SD2_DATA0_USDHC2_DATA0	0x1d4
+			MX8MM_IOMUXC_SD2_DATA1_USDHC2_DATA1	0x1d4
+			MX8MM_IOMUXC_SD2_DATA2_USDHC2_DATA2	0x1d4
+			MX8MM_IOMUXC_SD2_DATA3_USDHC2_DATA3	0x1d4
+			MX8MM_IOMUXC_GPIO1_IO04_USDHC2_VSELECT	0x1d0
+		>;
+	};
+
+	pinctrl_usdhc2_200mhz: usdhc2grp200mhz {
+		fsl,pins = <
+			MX8MM_IOMUXC_SD2_CLK_USDHC2_CLK		0x196
+			MX8MM_IOMUXC_SD2_CMD_USDHC2_CMD		0x1d6
+			MX8MM_IOMUXC_SD2_DATA0_USDHC2_DATA0	0x1d6
+			MX8MM_IOMUXC_SD2_DATA1_USDHC2_DATA1	0x1d6
+			MX8MM_IOMUXC_SD2_DATA2_USDHC2_DATA2	0x1d6
+			MX8MM_IOMUXC_SD2_DATA3_USDHC2_DATA3	0x1d6
+			MX8MM_IOMUXC_GPIO1_IO04_USDHC2_VSELECT	0x1d0
+		>;
+	};
+
+	pinctrl_usdhc3: usdhc3grp {
+		fsl,pins = <
+			MX8MM_IOMUXC_NAND_WE_B_USDHC3_CLK		0x190
+			MX8MM_IOMUXC_NAND_WP_B_USDHC3_CMD		0x1d0
+			MX8MM_IOMUXC_NAND_DATA04_USDHC3_DATA0		0x1d0
+			MX8MM_IOMUXC_NAND_DATA05_USDHC3_DATA1		0x1d0
+			MX8MM_IOMUXC_NAND_DATA06_USDHC3_DATA2		0x1d0
+			MX8MM_IOMUXC_NAND_DATA07_USDHC3_DATA3		0x1d0
+			MX8MM_IOMUXC_NAND_RE_B_USDHC3_DATA4		0x1d0
+			MX8MM_IOMUXC_NAND_CE2_B_USDHC3_DATA5		0x1d0
+			MX8MM_IOMUXC_NAND_CE3_B_USDHC3_DATA6		0x1d0
+			MX8MM_IOMUXC_NAND_CLE_USDHC3_DATA7		0x1d0
+			MX8MM_IOMUXC_NAND_CE1_B_USDHC3_STROBE		0x190
+		>;
+	};
+
+	pinctrl_usdhc3_100mhz: usdhc3grp100mhz {
+		fsl,pins = <
+			MX8MM_IOMUXC_NAND_WE_B_USDHC3_CLK		0x194
+			MX8MM_IOMUXC_NAND_WP_B_USDHC3_CMD		0x1d4
+			MX8MM_IOMUXC_NAND_DATA04_USDHC3_DATA0		0x1d4
+			MX8MM_IOMUXC_NAND_DATA05_USDHC3_DATA1		0x1d4
+			MX8MM_IOMUXC_NAND_DATA06_USDHC3_DATA2		0x1d4
+			MX8MM_IOMUXC_NAND_DATA07_USDHC3_DATA3		0x1d4
+			MX8MM_IOMUXC_NAND_RE_B_USDHC3_DATA4		0x1d4
+			MX8MM_IOMUXC_NAND_CE2_B_USDHC3_DATA5		0x1d4
+			MX8MM_IOMUXC_NAND_CE3_B_USDHC3_DATA6		0x1d4
+			MX8MM_IOMUXC_NAND_CLE_USDHC3_DATA7		0x1d4
+			MX8MM_IOMUXC_NAND_CE1_B_USDHC3_STROBE		0x194
+		>;
+	};
+
+	pinctrl_usdhc3_200mhz: usdhc3grp200mhz {
+		fsl,pins = <
+			MX8MM_IOMUXC_NAND_WE_B_USDHC3_CLK		0x196
+			MX8MM_IOMUXC_NAND_WP_B_USDHC3_CMD		0x1d6
+			MX8MM_IOMUXC_NAND_DATA04_USDHC3_DATA0		0x1d6
+			MX8MM_IOMUXC_NAND_DATA05_USDHC3_DATA1		0x1d6
+			MX8MM_IOMUXC_NAND_DATA06_USDHC3_DATA2		0x1d6
+			MX8MM_IOMUXC_NAND_DATA07_USDHC3_DATA3		0x1d6
+			MX8MM_IOMUXC_NAND_RE_B_USDHC3_DATA4		0x1d6
+			MX8MM_IOMUXC_NAND_CE2_B_USDHC3_DATA5		0x1d6
+			MX8MM_IOMUXC_NAND_CE3_B_USDHC3_DATA6		0x1d6
+			MX8MM_IOMUXC_NAND_CLE_USDHC3_DATA7		0x1d6
+			MX8MM_IOMUXC_NAND_CE1_B_USDHC3_STROBE		0x196
+		>;
+	};
+
+	pinctrl_wdog: wdoggrp {
+		fsl,pins = <
+			MX8MM_IOMUXC_GPIO1_IO02_WDOG1_WDOG_B	0xc6
+		>;
+	};
+
+	pinctrl_tca6416_20: tca6416_20grp {
+                        fsl,pins = <
+                                MX8MM_IOMUXC_SAI2_RXC_GPIO4_IO22     0x19
+                        >;
+        };
+};
diff --git a/configs/seco_imx8mm_c61_defconfig b/configs/seco_imx8mm_c61_defconfig
new file mode 100644
index 0000000000..5de32b74a0
--- /dev/null
+++ b/configs/seco_imx8mm_c61_defconfig
@@ -0,0 +1,204 @@
+CONFIG_ARM=y
+CONFIG_SPL_SYS_ICACHE_OFF=y
+CONFIG_SPL_SYS_DCACHE_OFF=y
+CONFIG_ARCH_IMX8M=y
+CONFIG_SYS_TEXT_BASE=0x40200000
+CONFIG_SYS_MALLOC_LEN=0x2000000
+CONFIG_SYS_MEMTEST_START=0x40000000
+CONFIG_SYS_MEMTEST_END=0xA0000000
+CONFIG_SPL_GPIO=y
+CONFIG_SPL_LIBCOMMON_SUPPORT=y
+CONFIG_SPL_LIBGENERIC_SUPPORT=y
+CONFIG_SYS_MALLOC_F_LEN=0x10000
+CONFIG_ENV_SIZE=0x3000
+CONFIG_ENV_OFFSET=0x3FD000
+CONFIG_DM_GPIO=y
+CONFIG_TARGET_SECO_IMX8MM_C61=y
+CONFIG_ARCH_MISC_INIT=y
+CONFIG_SPL_MMC=y
+CONFIG_SPL_SERIAL=y
+CONFIG_SPL_DRIVERS_MISC=y
+CONFIG_SPL=y
+CONFIG_DISTRO_DEFAULTS=y
+CONFIG_SYS_LOAD_ADDR=0x40280000
+CONFIG_BOOTCOMMAND="run usbsetup;run distro_bootcmd;run bsp_bootcmd"
+CONFIG_CSF_SIZE=0x2000
+CONFIG_SPL_TEXT_BASE=0x7E1000
+CONFIG_FIT=y
+CONFIG_FIT_EXTERNAL_OFFSET=0x3000
+CONFIG_SPL_LOAD_FIT=y
+# CONFIG_SPL_FIT_GENERATOR="arch/arm/mach-imx/mkimage_fit_atf.sh"
+CONFIG_FIT_SIGNATURE=y
+CONFIG_OF_SYSTEM_SETUP=y
+CONFIG_TEE=y
+CONFIG_OPTEE=y
+CONFIG_BOARD_LATE_INIT=y
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_SPL_BOARD_INIT=y
+CONFIG_SPL_SEPARATE_BSS=y
+CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_USE_SECTOR=y
+CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR=0x300
+CONFIG_SPL_ENV_SUPPORT=y
+CONFIG_SPL_I2C=y
+CONFIG_SPL_POWER=y
+CONFIG_NR_DRAM_BANKS=2
+CONFIG_HUSH_PARSER=y
+CONFIG_SYS_PROMPT="u-boot=> "
+CONFIG_CMD_BOOTEFI_SELFTEST=y
+CONFIG_CMD_NVEDIT_EFI=y
+# CONFIG_CMD_EXPORTENV is not set
+# CONFIG_CMD_IMPORTENV is not set
+# CONFIG_CMD_CRC32 is not set
+# CONFIG_BOOTM_NETBSD is not set
+CONFIG_CMD_CLK=y
+CONFIG_CMD_DFU=y
+CONFIG_CMD_FUSE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_GPT=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_CACHE=y
+#CONFIG_CMD_PMIC is not set
+CONFIG_CMD_EFIDEBUG=y
+CONFIG_CMD_RTC=y
+CONFIG_CMD_REGULATOR=y
+CONFIG_CMD_MEMTEST=y
+CONFIG_OF_LIBFDT_OVERLAY=y
+CONFIG_HW_WATCHDOG=y
+CONFIG_APX_WATCHDOG=y
+CONFIG_SPL_WATCHDOG=y
+CONFIG_PANIC_HANG=y
+
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_USB=y
+CONFIG_OF_CONTROL=y
+CONFIG_SPL_OF_CONTROL=y
+CONFIG_DEFAULT_DEVICE_TREE="seco-imx8mm-c61"
+CONFIG_DEFAULT_FDT_FILE="seco-imx8mm-c61.dtb"
+CONFIG_ENV_IS_IN_MMC=y
+CONFIG_SYS_RELOC_GD_ENV_ADDR=y
+CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG=y
+CONFIG_SPL_DM=y
+CONFIG_CLK_COMPOSITE_CCF=y
+CONFIG_CLK_IMX8MM=y
+CONFIG_DFU_MMC=y
+CONFIG_DFU_MTD=y
+CONFIG_DFU_NAND=y
+CONFIG_DFU_SF=y
+CONFIG_DFU_OVER_TFTP=y
+CONFIG_DFU_OVER_USB=y
+CONFIG_MXC_GPIO=y
+CONFIG_FASTBOOT=y
+CONFIG_USB_FUNCTION_FASTBOOT=y
+CONFIG_CMD_FASTBOOT=y
+CONFIG_ANDROID_BOOT_IMAGE=y
+CONFIG_FASTBOOT_UUU_SUPPORT=y
+CONFIG_FASTBOOT_BUF_ADDR=0x42800000
+CONFIG_FASTBOOT_BUF_SIZE=0x40000000
+CONFIG_FASTBOOT_FLASH=y
+CONFIG_FASTBOOT_FLASH_MMC_DEV=0
+CONFIG_DM_PCA953X=y
+CONFIG_DM_I2C=y
+#CONFIG_SYS_I2C_LEGACY is not set
+#CONFIG_SPL_SYS_I2C_LEGACY is not set
+#CONFIG_SYS_I2C_EARLY_INIT is not set
+CONFIG_SYS_I2C_MXC=y
+CONFIG_MMC_IO_VOLTAGE=y
+CONFIG_MMC_UHS_SUPPORT=y
+CONFIG_MMC_HS400_SUPPORT=y
+CONFIG_MMC_HS400_ES_SUPPORT=y
+CONFIG_EFI_PARTITION=y
+CONFIG_SUPPORT_EMMC_RPMB=y
+CONFIG_SUPPORT_EMMC_BOOT=y
+CONFIG_FSL_USDHC=y
+CONFIG_DM_SPI_FLASH=y
+CONFIG_DM_SPI=y
+CONFIG_FSL_FSPI=y
+CONFIG_SPI=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_BAR=y
+CONFIG_SPI_FLASH_STMICRO=y
+CONFIG_SF_DEFAULT_BUS=0
+CONFIG_SF_DEFAULT_CS=0
+CONFIG_SF_DEFAULT_SPEED=40000000
+CONFIG_SF_DEFAULT_MODE=0
+CONFIG_PHY=y
+CONFIG_NOP_PHY=y
+CONFIG_PHYLIB=y
+CONFIG_PHY_TI_DP83867=y
+CONFIG_PHY_ATHEROS=y
+CONFIG_DM_ETH=y
+CONFIG_PHY_GIGE=y
+CONFIG_FEC_MXC=y
+CONFIG_MII=y
+CONFIG_SPL_PHY=y
+CONFIG_PINCTRL=y
+CONFIG_PINCTRL_IMX8M=y
+CONFIG_POWER=y
+CONFIG_POWER_DOMAIN=y
+CONFIG_IMX8M_POWER_DOMAIN=y
+#CONFIG_POWER_LEGACY is not set
+#CONFIG_POWER_I2C is not set
+CONFIG_DM_PMIC=y
+CONFIG_DM_PMIC_BD71837=y
+CONFIG_SPL_DM_PMIC_BD71837=y
+CONFIG_DM_REGULATOR=y
+CONFIG_DM_REGULATOR_BD71837=y
+CONFIG_DM_REGULATOR_FIXED=y
+CONFIG_DM_REGULATOR_GPIO=y
+CONFIG_DM_RTC=y
+CONFIG_RTC_EMULATION=y
+CONFIG_MXC_UART=y
+CONFIG_SYSRESET=y
+CONFIG_SYSRESET_PSCI=y
+CONFIG_DM_THERMAL=y
+CONFIG_NXP_TMU=y
+CONFIG_USB=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_STORAGE=y
+CONFIG_DM_USB=y
+# CONFIG_SPL_DM_USB is not set
+CONFIG_DM_USB_GADGET=y
+CONFIG_SPL_DM_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_GADGET_MANUFACTURER="FSL"
+CONFIG_USB_GADGET_VENDOR_NUM=0x0525
+CONFIG_USB_GADGET_PRODUCT_NUM=0xa4a5
+
+CONFIG_SPL_USB_HOST=y
+CONFIG_SPL_USB_GADGET=y
+CONFIG_SPL_USB_SDP_SUPPORT=y
+CONFIG_SDP_LOADADDR=0x40400000
+CONFIG_OF_LIBFDT_OVERLAY=y
+CONFIG_REGMAP=y
+CONFIG_SYSCON=y
+CONFIG_DM_RESET=y
+CONFIG_RESET_DISPMIX=y
+CONFIG_SYS_WHITE_ON_BLACK=y
+CONFIG_NET_RANDOM_ETHADDR=y
+
+CONFIG_USB_FUNCTION_SDP=y
+CONFIG_OF_LIBFDT=y
+CONFIG_EFI_GET_TIME=y
+CONFIG_EFI_SET_TIME=y
+#CONFIG_FLASH_CFI_DRIVER is not set
+#CONFIG_FLASH_CFI_MTD is not set
+CONFIG_EFI_VARIABLE_FILE_STORE=y
+CONFIG_EFI_VAR_BUF_SIZE=32768
+CONFIG_CMD_BOOTEFI_HELLO_COMPILE=y
+CONFIG_EFI_RUNTIME_UPDATE_CAPSULE=y
+CONFIG_EFI_CAPSULE_ON_DISK=y
+CONFIG_EFI_CAPSULE_FIRMWARE_FIT=y
+CONFIG_EFI_CAPSULE_FIRMWARE_MANAGEMENT=y
+CONFIG_EFI_CAPSULE_FIRMWARE_RAW=y
+CONFIG_DFU=y
+CONFIG_EFI_SECURE_BOOT=y
+#CONFIG_EFI_MM_COMM_TEE is not set
diff --git a/include/configs/seco_environment.h b/include/configs/seco_environment.h
new file mode 100644
index 0000000000..e7735e05be
--- /dev/null
+++ b/include/configs/seco_environment.h
@@ -0,0 +1,386 @@
+#ifndef __SECO_ENVIRONMENT_H
+#define __SECO_ENVIRONMENT_H
+
+
+/*
+ *
+ * Variable              Scope                 Description
+ * --------------------------------------------------------------------------------------------------------
+ *
+ * kernel_device_id      eMMC/SD/              numeric id of device
+ * kernel_partition      eMMC/SD/USB/SATA      numeric id of device's partition
+ * kernel_file           eMMC/SD/USB/SATA      absolute path (folder+name) of file to load
+ * kernel_load2ram       all                   u-boot command to exec in order to load file to memory
+ *
+ * fdt_autodetect        all                   automatic detect the corret dtb file name (cpu type based)
+ * fdt_device_id         eMMC/SD/              numeric id of device
+ * fdt_partition         eMMC/SD/USB/SATA      numeric id of device's partition
+ * fdt_file              eMMC/SD/USB/SATA      absolute path (folder+name) of file to load
+ * fdt_load              all                   u-boot command to exec in order to load file to memory
+ *
+ * ramfs_use             all                   0 = do not use ramfs ; 1 = use ramfs
+ * ramfs_device_id       eMMC/SD/              numeric id of device
+ * ramfs_partition       eMMC/SD/USB/SATA      numeric id of device's partition
+ * ramfs_file            eMMC/SD/USB/SATA      absolute path (folder+name) of file to load
+ * ramfs_load2ram        all                   u-boot command to exec in order to load file to memory
+ *
+ * root_device_id        eMMC/SD/              numeric id of device
+ * root_partition        eMMC/SD/USB/SATA      numeric id of device's partition
+ * root_mount            all                   u-boot command to generate bootargs about FS mount point
+ *
+ * ipaddr                TFTP                  target ip
+ * netmask               TFTP                  target netmask
+ * nfs_ip_client         NFS                   static IP of client
+ * nfs_netmask           NFS                   netmask for client
+ * nfs_ip_server         NFS                   static IP of server
+ * nfs_path              NFS                   remote path of FS folder
+ * eth_if                NFS                   id of the eth inteface to use for network Filesystem
+ *
+ */
+
+
+
+/* ____________________________________________________________________________
+  |                                                                            |
+  |                                 ENV MACROS                                 |
+  |____________________________________________________________________________|
+*/
+
+/* -------------------- BOOTSCRIPT -------------------- */
+#define MACRO_ENV_BOOTSCRIPT_SRC_USDHCI  \
+	load mmc ${bootscript_device_id}:${bootscript_partition} ${bootscript_loadaddr} ${script}
+
+#define MACRO_ENV_BOOTENV_SRC_USDHCI \
+	load mmc ${bootscript_device_id}:${bootenv_partition} ${bootenv_loadaddr} ${envtxt}
+
+
+/* -------------------- KERNEL -------------------- */
+
+#define MACRO_ENV_KERNEL_SRC_USDHCI     \
+	mmc dev ${kernel_device_id}; load mmc ${kernel_device_id}:${kernel_partition}  ${kernel_loadaddr} ${kernel_file}
+
+#define MACRO_ENV_KERNEL_SRC_USB     \
+	usb start; load usb ${kernel_device_id}:${kernel_partition} ${kernel_loadaddr} ${kernel_file}
+
+#define MACRO_ENV_KERNEL_SRC_SATA    \
+	sata init; load sata 0:${kernel_partition} ${kernel_loadaddr} ${kernel_file}
+
+#define MACRO_ENV_KERNEL_SRC_SPI     \
+	sf probe 0; sf ${kernel_loadaddr} ${kernel_spi_addr} ${kernel_spi_len}
+
+#define MACRO_ENV_KERNEL_SRC_TFTP   \
+	if test "${tftp_use_dhcp}" = "0"; then tftpboot ${kernel_loadaddr} ${kernel_file}; else dhcp ${kernel_loadaddr} ${kernel_file}; fi
+
+
+/* -------------------- FDT -------------------- */
+#define MACRO_ENV_FDT_SRC_USDHCI     \
+	load mmc ${fdt_device_id}:${fdt_partition}  ${fdt_loadaddr} ${fdt_file}
+
+#define MACRO_ENV_FDT_SRC_USB     \
+	usb start; load usb ${fdt_device_id}:${fdt_partition} ${fdt_loadaddr} ${fdt_file}
+
+#define MACRO_ENV_FDT_SRC_SATA    \
+	sata init; load sata 0:${fdt_partition} ${fdt_loadaddr} ${fdt_file}
+
+#define MACRO_ENV_FDT_SRC_SPI     \
+	sf probe 0; sf ${fdt_loadaddr} ${fdt_spi_addr} ${fdt_spi_len}
+
+#define MACRO_ENV_FDT_SRC_TFTP   \
+	if test "${tftp_use_dhcp}" = "0"; then tftpboot ${fdt_loadaddr} ${fdt_file}; else dhcp ${fdt_loadaddr} ${fdt_file}; fi
+
+#ifdef CONFIG_OF_LIBFDT_OVERLAY
+#define MACRO_ENV_FDT_LOAD_OVERLAY_BASE \
+	fdt addr ${fdt_loadaddr}; fdt resize ${fdt_resize}; \
+	seco_config fdtoverlay ; \
+	if test -n "${fdt_overlay_per_cmd}"; then run fdt_overlay_per_cmd; fi; \
+	if test -n "${fdt_overlay_video_cmd}"; then run fdt_overlay_video_cmd; fi;
+
+
+#define MACRO_ENV_FDT_OVERLAY_SRC_USDHCI     \
+	load mmc ${fdt_device_id}:${fdt_partition}
+
+#define MACRO_ENV_FDT_OVERLAY_SRC_USB     \
+	usb start; load usb ${fdt_device_id}:${fdt_partition}
+
+#define MACRO_ENV_FDT_OVERLAY_SRC_SATA    \
+	sata init; load sata 0:${fdt_partition}
+
+#define MACRO_ENV_FDT_OVERLAY_SRC_SPI     \
+	sf probe 0; sf ${fdt_loadaddr} ${fdt_spi_addr} ${fdt_spi_len}
+
+#define MACRO_ENV_FDT_OVERLAY_SRC_TFTP   \
+	tftpboot
+
+#define MACRO_ENV_FDT_OVERLAY_APPLY   \
+	fdt apply
+#else
+#define MACRO_ENV_FDT_LOAD_OVERLAY_BASE "\0"
+#endif    /* CONFIG_OF_LIBFDT_OVERLAY */
+
+
+/* -------------------- RAMFS -------------------- */
+
+#define MACRO_ENV_RAMFS_SRC_USDHCI     \
+	load mmc ${ramfs_device_id}:${ramfs_partition}  ${ramfs_loadaddr} ${ramfs_file}
+
+#define MACRO_ENV_RAMFS_SRC_USB     \
+	usb start; load usb ${ramfs_device_id}:${ramfs_partition} ${ramfs_loadaddr} ${ramfs_file}
+
+#define MACRO_ENV_RAMFS_SRC_SATA    \
+	sata init; load sata 0:${ramfs_partition} ${ramfs_loadaddr} ${ramfs_file}
+
+#define MACRO_ENV_RAMFS_SRC_SPI     \
+	sf probe 0; sf ${ramfs_loadaddr} ${ramfs_spi_addr} ${ramfs_spi_len}
+
+#define MACRO_ENV_RAMFS_SRC_TFTP   \
+	tftpboot ${ramfs_loadaddr} ${ramfs_file}
+
+
+
+/* -------------------- FILESYSTEM -------------------- */
+
+#define MACRO_ENV_FS_COMMON  rootwait rw
+
+#define MACRO_ENV_FS_SRC_USDHCI   \
+	setenv root_dev root=/dev/mmcblk${root_device_id}p${root_partition} rootwait rw
+
+#define MACRO_ENV_FS_SRC_USB      \
+	setenv root_dev setenv root_dev root=/dev/sda${root_partition} rootwait rw
+
+#define MACRO_ENV_FS_SRC_SATA     \
+	setenv root_dev setenv root=/dev/sda${root_partition} rootwait rw
+
+#define MACRO_ENV_FS_SRC_NFS      \
+	run set_ip; run set_remote_rootfs; setenv root_dev ${remote_fs} ip=${ip} 
+
+#define MACRO_SET_IP \
+	if test "${nfs_use_dhcp}" = "0"; then \
+		run ipsetup; \
+		setenv ip "${nfs_ip_client}:::${nfs_netmask}::eth0:off"; \
+	else \
+		setenv ip ":::::eth0:dhcp"; \
+	fi; \
+
+#define MACRO_SET_REMOTE_ROOTFS \
+	if test "${nfs_use_dhcp}" = "0"; then \
+		setenv remote_fs "root=/dev/nfs rootfstype=nfs nfsroot=${nfs_ip_server}:/${nfs_path},wsize=1024,rsize=1024,nfsvers=3 rootwait rw"; \
+	else \
+		if test "${nfs_use_dhcp_autopath}" = "0"; then \
+			setenv remote_fs "root=/dev/nfs rootfstype=nfs nfsroot=/${nfs_path},wsize=1024,rsize=1024,nfsvers=3 rootwait rw"; \
+		else \
+			setenv remote_fs "root=/dev/nfs rootfstype=nfs rootwait rw"; \
+		fi; \
+	fi
+
+
+
+
+/* ____________________________________________________________________________
+  |                                                                            |
+  |                                 ENVIRONMENT                                |
+  |____________________________________________________________________________|
+*/
+
+#define CONFIG_SERVERIP                          13.0.0.1
+#define CONFIG_IPADDR                            13.0.0.10
+#define CONFIG_NETMASK                           255.255.255.0
+#define DEF_NFS_PATH                             "targetfs/"
+
+
+#define ENV_BOOTARGS_BASE  setenv bootargs ${console_interface} ${memory} ${cpu_freq} ${videomode} vt.global_cursor_default=0 ${root_dev}
+
+
+
+#define ENV_COMMON                                                    \
+	"bootdelay="__stringify(CONFIG_BOOTDELAY)"\0"                     \
+	"stdin=serial\0"                                                  \
+	"stdout=serial\0"                                                 \
+	"stderr=serial\0"                                                 \
+	"mmcautodetect="ENV_MMCAUTODETECT"\0"                             \
+	"fdt_autodetect="ENV_FDTAUTODETECT"\0"                            \
+	"mem_autodetect="ENV_MEMAUTODETECT"\0"                            \
+	"run_from_tftp=0\0"                                               \
+	"tftp_use_dhcp=0\0"
+
+
+#define ENV_ARGS_BASE                                                                          \
+	"console_interface='console=" __stringify(ENV_CONSOLE_DEV) "," __stringify(CONFIG_BAUDRATE)"'\0"    \
+	"bootargs_base="__stringify(ENV_BOOTARGS_BASE)"\0"
+
+
+#define ENV_BOOTSCRIPT                                                        \
+	"script=seco_boot.scr\0"                                                  \
+	"envtxt=/loader/uEnv.txt\0"                                                       \
+	"bootscript_device_id="__stringify(ENV_SYS_MMC_ENV_DEV)"\0"               \
+	"bootscript_partition="__stringify(ENV_SYS_MMC_BOOSCRIPT_PART)"\0"         \
+	"bootenv_partition="__stringify(ENV_SYS_MMC_BOOATENV_PART)"\0"            \
+	"bootscript_loadaddr="__stringify(ENV_BOOTSCRIPT_LOADADDR)"\0"                       \
+	"bootenv_loadaddr="__stringify(ENV_RAMFS_LOADADDR)"\0"                    \
+	"bootscript_load_usdhci2ram="__stringify(MACRO_ENV_BOOTSCRIPT_SRC_USDHCI)"\0"     \
+	"bootenv_load_usdhci2ram="__stringify(MACRO_ENV_BOOTENV_SRC_USDHCI)"\0"
+
+
+#define ENV_KERNEL                                                    \
+	"kernel_device_id="__stringify(ENV_SYS_MMC_ENV_DEV)"\0"           \
+	"kernel_partition="__stringify(ENV_SYS_MMC_KERNEL_PART)"\0"     \
+	"kernel_loadaddr="__stringify(ENV_KERNEL_LOADADDR)"\0"                   \
+	"kernel_file="__stringify(ENV_KERNEL_FILENAME)"\0"                  \
+	"kernel_load_usdhci2ram="__stringify(MACRO_ENV_KERNEL_SRC_USDHCI)"\0"     \
+	"kernel_load_usb2ram="__stringify(MACRO_ENV_KERNEL_SRC_USB)"\0"           \
+	"kernel_load_eth2ram="__stringify(MACRO_ENV_KERNEL_SRC_TFTP)"\0"          \
+	"kernel_load2ram="__stringify(MACRO_ENV_KERNEL_SRC_USDHCI)"\0"
+
+
+#ifndef CONFIG_OF_LIBFDT_OVERLAY
+
+#define ENV_FDT                                                       \
+	"fdt_device_id="__stringify(ENV_SYS_MMC_ENV_DEV)"\0"              \
+	"fdt_partition="__stringify(ENV_SYS_MMC_FDT_PART)"\0"        \
+	"fdt_loadaddr="__stringify(ENV_FDT_LOADADDR)"\0"                  \
+	"fdt_file="__stringify(ENV_DEFAULT_FDT_FILE)"\0"                  \
+	"fdt_high=0xffffffff\0"	                                          \
+	"fdt_load_usdhci2ram="__stringify(MACRO_ENV_FDT_SRC_USDHCI)"\0"           \
+	"fdt_load_usb2ram="__stringify(MACRO_ENV_FDT_SRC_USB)"\0"                 \
+	"fdt_load_eth2ram="__stringify(MACRO_ENV_FDT_SRC_TFTP)"\0"                \
+	"fdt_load2ram="__stringify(MACRO_ENV_FDT_SRC_USDHCI)"\0"
+
+#else
+
+#define ENV_FDT                                                       \
+	"fdt_device_id="__stringify(ENV_SYS_MMC_ENV_DEV)"\0"              \
+	"fdt_partition="__stringify(ENV_SYS_MMC_FDT_PART)"\0"        \
+	"fdt_loadaddr="__stringify(ENV_FDT_LOADADDR)"\0"                  \
+	"fdt_file="__stringify(ENV_DEFAULT_FDT_FILE)"\0"                  \
+	"fdt_high=0xffffffff\0"	                                          \
+	"fdt_resize="__stringify(ENV_FDT_RESIZE)"\0"                      \
+	"fdt_load_usdhci2ram="__stringify(MACRO_ENV_FDT_SRC_USDHCI)"\0"           \
+	"fdt_load_usb2ram="__stringify(MACRO_ENV_FDT_SRC_USB)"\0"                 \
+	"fdt_load_eth2ram="__stringify(MACRO_ENV_FDT_SRC_TFTP)"\0"                \
+	"fdt_load2ram="__stringify(MACRO_ENV_FDT_SRC_USDHCI)"\0"                  \
+	"fdt_overlay_load2ram="__stringify(MACRO_ENV_FDT_LOAD_OVERLAY_BASE)"\0"
+
+#endif  /* CONFIG_OF_LIBFDT_OVERLAY */
+
+
+
+#define ENV_RAMFS                                                     \
+	"ramfs_use=0\0"                                                   \
+	"ramfs_device_id="__stringify(ENV_SYS_MMC_ENV_DEV)"\0"            \
+	"ramfs_partition="__stringify(ENV_SYS_MMC_RAMFS_PART)"\0"      \
+	"ramfs_loadaddr="__stringify(ENV_RAMFS_LOADADDR)"\0"              \
+	"ramfs_file="__stringify(ENV_RAMFS_FILENAME)"\0"                                          \
+	"ramfs_load_usdhci2ram="__stringify(MACRO_ENV_RAMFS_SRC_USDHCI)"\0"       \
+	"ramfs_load_usb2ram="__stringify(MACRO_ENV_RAMFS_SRC_USB)"\0"             \
+	"ramfs_load_eth2ram="__stringify(MACRO_ENV_RAMFS_SRC_TFTP)"\0"            \
+	"ramfs_load2ram="__stringify(MACRO_ENV_RAMFS_SRC_USDHCI)"\0"
+
+
+#define ENV_ROOT                                                      \
+	"root_device_id="__stringify(ENV_ROOT_DEV_ID)"\0"                 \
+	"root_partition="__stringify(ENV_SYS_MMC_ROOTFS_PART)"\0"              \
+	"root_load_usdhci="__stringify(MACRO_ENV_FS_SRC_USDHCI)"\0"               \
+	"root_load_usb="__stringify(MACRO_ENV_FS_SRC_USB)"\0"                     \
+	"root_load_eth="__stringify(MACRO_ENV_FS_SRC_NFS)"\0"                     \
+	"run_from_nfs=0\0"  \
+	"root_mount="__stringify(MACRO_ENV_FS_SRC_USDHCI)"\0"
+
+
+#define ENV_NETWORK                                                   \
+	"ipaddr="__stringify(CONFIG_IPADDR)"\0"                           \
+	"netmask=255.255.255.0\0"                                         \
+	"eth_if=0\0"                                                      \
+	"nfs_use_dhcp=0\0"                                                \
+	"nfs_use_dhcp_autopath=0\0"                                       \
+	"ipsetup=setenv ipaddr ${ipaddr}; setenv serverip ${serverip};\0" \
+	"set_remote_rootfs="__stringify(MACRO_SET_REMOTE_ROOTFS)"\0"      \
+	"set_ip="__stringify(MACRO_SET_IP)"\0"                            \
+	"nfs_ip_client="__stringify(CONFIG_IPADDR)"\0"                    \
+	"nfs_ip_server="__stringify(CONFIG_SERVERIP)"\0"                  \
+	"nfs_netmask="__stringify(CONFIG_NETMASK)"\0"                     \
+	"nfs_path="__stringify(DEF_NFS_PATH)"\0"
+
+
+
+#ifndef CONFIG_OF_LIBFDT_OVERLAY
+
+#define ENV_CMD_SET_BOOT                                              \
+  	"if test \"${bootusb}\" = \"true\"; then " \
+  	"  for fstype in fat ext2; do " \
+  	"   if ${fstype}load usb 0:1 0x00500000" __stringify(ENV_UENV_FILE_NAME)"; then " \
+  	"     env import -t 0x00500000 600; run usb_boot; fi; " \
+  	"  done; " \
+  	"fi; " \
+	"mmc dev ${bootscript_device_id}; "                               \
+	"if mmc rescan; then "                                            \
+		"if run bootscript_load_usdhci2ram; then "                    \
+			"echo ==> Running bootscript mode... ; "			      \
+			" source "__stringify(ENV_BOOTSCRIPT_LOADADDR)"; "                                              \
+		"fi; "                                                        \
+	"fi; "                                                            \
+	"echo ==> Running in Normal Mode... ; "							  \
+	"run bootargs_base; "                                          	  \
+	"run kernel_load2ram; "                                           \
+	"run fdt_load2ram; "                                              \
+	"run root_mount; "                                                \
+	"run bootargs_base; "                                             \
+	"if test ${ramfs_use} = 1; then "                                 \
+		" run ramfs_load2ram; "                                       \
+		__stringify(DEF_NFS_PATH)" ${kernel_loadaddr} ${ramfs_loadaddr} ${fdt_loadaddr}; "\
+	"else "                                                           \
+		__stringify(DEF_NFS_PATH)" ${kernel_loadaddr} - ${fdt_loadaddr}; "               \
+	"fi\0"
+
+#else
+
+#define ENV_CMD_SET_BOOT                                              \
+  	"if test \"${bootusb}\" = \"true\"; then " \
+  	"  for fstype in fat ext2; do " \
+  	"   if ${fstype}load usb 0:1 0x00500000" __stringify(ENV_UENV_FILE_NAME)"; then " \
+  	"     env import -t 0x00500000 600; run usb_boot; fi; " \
+  	"  done; " \
+  	"fi; " \
+	"mmc dev ${bootscript_device_id}; "                               \
+	"if mmc rescan; then "                                            \
+		"if run bootscript_load_usdhci2ram; then "                    \
+			"echo ==> Running bootscript mode... ; "			      \
+			" source "__stringify(ENV_BOOTSCRIPT_LOADADDR)"; "                                              \
+		"fi; "                                                        \
+	"fi; "                                                            \
+	"echo ==> Running in Normal Mode... ; "							  \
+	"run bootargs_base; "                                          	  \
+	"run kernel_load2ram; "                                           \
+	"run fdt_load2ram; "                                              \
+	"run fdt_overlay_load2ram; "                                      \
+	"run root_mount; "                                                \
+	"run bootargs_base; "                                             \
+	"if test ${ramfs_use} = 1; then "                                 \
+		" run ramfs_load2ram; "                                       \
+		__stringify(ENV_BOOT_TYPE)" ${kernel_loadaddr} ${ramfs_loadaddr} ${fdt_loadaddr}; "\
+	"else "                                                           \
+		__stringify(ENV_BOOT_TYPE)" ${kernel_loadaddr} - ${fdt_loadaddr}; "                  \
+	"fi\0"
+
+#endif  /* CONFIG_OF_LIBFDT_OVERLAY */
+
+#ifndef CONFIG_PREBOOT
+#define CONFIG_PREBOOT
+#endif
+
+
+#define ENV_PREBOOT "preboot=echo Start boot...\0"
+
+#undef CONFIG_EXTRA_ENV_SETTINGS
+#define CONFIG_EXTRA_ENV_SETTINGS                                     \
+	ENV_COMMON                                                        \
+	ENV_ARGS_BASE                                                     \
+	ENV_NETWORK                                                       \
+	ENV_BOOTSCRIPT                                                    \
+	ENV_KERNEL                                                        \
+	ENV_FDT                                                           \
+	ENV_RAMFS                                                         \
+	ENV_ROOT                                                          \
+	ENV_PREBOOT                                                       \
+	"bootcmd=" ENV_CMD_SET_BOOT "\0"
+
+
+#endif     /*  __SECO_ENVIRONMENT_H  */
diff --git a/include/configs/seco_imx8m_common.h b/include/configs/seco_imx8m_common.h
new file mode 100755
index 0000000000..c5964e7e6d
--- /dev/null
+++ b/include/configs/seco_imx8m_common.h
@@ -0,0 +1,127 @@
+/*
+ * (C) Copyright 2015 Seco
+ *
+ * Author: Davide Cardillo <davide.cardillo@seco.com>
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+
+#ifndef __MX8MQSECO_COMMON_CONFIG_H
+#define __MX8MQSECO_COMMON_CONFIG_H
+
+
+/* ____________________________________________________________________________
+  |                                                                            |
+  |                                   ENVIRONMENT                              |
+  |____________________________________________________________________________|
+*/
+
+#define SYS_MMC_IMG_LOAD_PART   1
+
+#define ROOT_DEV_ID		0
+#define ROOT_PARTITION		3
+#define KERNEL_LOADADDR		 CONFIG_SYS_LOAD_ADDR /* 0x40280000 */
+#define FDT_LOADADDR	 	         0x43000000
+#define FDT_OVERLAY_LOADADDR_BASE	 0x44000000
+#define FDT_OVERLAY_LOADADDR_OFFSET     0x01000000
+#define FDT_RESIZE                      0x60000
+
+#define BOOTARGS_BASE  "setenv bootargs ${console_interface} ${memory} ${cpu_freq} ${videomode} ${options} ${root_dev}"
+
+#define ENV_COMMON                                        \
+	"bootdelay="__stringify(CONFIG_BOOTDELAY)"\0"            \
+	"stdin=serial\0"                                         \
+	"stdout=serial\0"                                        \
+	"stderr=serial\0"			
+
+#define ENV_BOOTARG_BASE                                                                               \
+	"console_interface='console="CONSOLE_DEV"," __stringify(CONFIG_BAUDRATE)",earlycon=ec_imx6q,0x30890000,115200'\0"                \
+	"bootargs_base="BOOTARGS_BASE"\0"	\
+	"options=drm_kms_helper.edid_firmware=edid/1920x1080.bin\0"
+
+#define ENV_KERNEL                                                                                                                   \
+	"kernel_device_id="__stringify(CONFIG_SYS_MMC_ENV_DEV)"\0"                                                                          \
+        "kernel_partition="__stringify(SYS_MMC_IMG_LOAD_PART)"\0"                                                                    \
+        "kernel_loadaddr="__stringify(KERNEL_LOADADDR)"\0"                                                                                  \
+	"kernel_file=Image\0"                                                                                                              \
+	"kernel_load=mmc dev ${kernel_device_id}; fatload mmc ${kernel_device_id}:${kernel_partition} ${kernel_loadaddr} ${kernel_file}\0"
+
+
+#define ENV_FDT \
+	"fdt_device_id="__stringify(CONFIG_SYS_MMC_ENV_DEV)"\0" \
+	"fdt_partition="__stringify(SYS_MMC_IMG_LOAD_PART)"\0" \
+	"fdt_loadaddr="__stringify(FDT_LOADADDR)"\0" \
+	"fdt_file=" DEFAULT_FDT_FILE "\0" \
+	"fdt_high=0xffffffff\0" \
+	"fdt_resize="__stringify(FDT_RESIZE)"\0" \
+	"fdt_load=mmc dev ${fdt_device_id}; fatload mmc ${fdt_device_id}:${fdt_partition} ${fdt_loadaddr} ${fdt_file}\0"
+
+#ifdef CONFIG_OF_LIBFDT_OVERLAY
+
+#define ENV_FDT_OVERLAY \
+	"fdt_overlay_device_id="__stringify(CONFIG_SYS_MMC_ENV_DEV)"\0" \
+	"fdt_overlay_partition="__stringify(SYS_MMC_IMG_LOAD_PART)"\0" \
+	"fdt_overlay_file=" DEFAULT_FDT_OVERLAY_FILE "\0" \
+	"fdt_overlay_loadaddr="__stringify(FDT_OVERLAY_LOADADDR_BASE)"\0" \
+	"fdt_overlay_load=mmc dev ${fdt_overlay_device_id}; fatload mmc ${fdt_overlay_device_id}:${fdt_overlay_partition} ${fdt_overlay_loadaddr} ${fdt_overlay_file}\0"
+
+#define FDT_OVERLAY_APPLY \
+	"run fdt_overlay_load; " \
+	"fdt addr ${fdt_loadaddr}; fdt resize ${fdt_resize}; " \
+	"fdt apply ${fdt_overlay_loadaddr}; "
+
+#else
+#define FDT_OVERLAY_APPLY
+#define ENV_FDT_OVERLAY
+
+#endif  /* CONFIG_OF_LIBFDT_OVERLAY */
+
+#define ENV_ROOT                                                                               \
+	"root_device_id="__stringify(ROOT_DEV_ID)"\0"                                              \
+	"root_partition="__stringify(ROOT_PARTITION)"\0"                                           \
+	"root_set_dev=setenv root_dev root=/dev/mmcblk${root_device_id}p${root_partition} rootwait rw\0"  \
+	"root_add_env=setenv bootargs ${bootargs} ${root_dev}\0"
+
+
+#define ENV_VIDEO                                          \
+	"video_lvds1=video=mxcfb1:dev=ldb,LDB-WVGA,if=RGB666\0"       \
+	"video_lvds2=video=mxcfb2:dev=ldb,LDB-WVGA,if=RGB666\0"       \
+	"video_hdmi=video=mxcfb0:dev=hdmi,1920x1080M@60,if=RGB24\0"   \
+	"videomode=video=mxcfb0:dev=hdmi,1920x1080M@60\0"
+
+
+#define CMD_SET_BOOT                                         \
+	"run bootargs_base; "                                           \
+	"if test \"${run_from_tftp}\" = \"1\"; then "                    \
+		"run ipsetup;"  \
+	"fi;"                                                           \
+	"if test \"${run_from_nfs}\" = \"0\"; then "                    \
+		"echo Running in Normal Mode... ; "                         \
+	"else "                                                         \
+		"echo Running in Remote... ; "                              \
+		"run set_ip; "                                              \
+	"fi;"                                                           \
+	"run root_set_dev; "                                            \
+	"run root_add_env; "                                            \
+	"run kernel_load; "                                             \
+	"run fdt_load; "                                                \
+	"if test \"${run_overlay}\" = \"0\"; then "                    \
+                "echo Running in Normal Mode... ; "                         \
+        "else "                                                         \
+                "echo Apply overlay... ; "                              \
+                "run overlay_setup;"   \
+        "fi;"				\
+	"booti ${kernel_loadaddr} - ${fdt_loadaddr}"
+
+
+#define CONFIG_EXTRA_ENV_SETTINGS        \
+	ENV_COMMON                       \
+	ENV_BOOTARG_BASE                 \
+	ENV_KERNEL                       \
+	ENV_FDT                          \
+	ENV_FDT_OVERLAY                  \
+	ENV_ROOT                         \
+	"bootcmd=" CMD_SET_BOOT "\0"
+
+#endif /* SECOCONFIG COMMON */
diff --git a/include/configs/seco_imx8mm_c61.h b/include/configs/seco_imx8mm_c61.h
new file mode 100644
index 0000000000..da04db0e46
--- /dev/null
+++ b/include/configs/seco_imx8mm_c61.h
@@ -0,0 +1,353 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright 2019 NXP
+ */
+
+#ifndef __IMX8MM_EVK_H
+#define __IMX8MM_EVK_H
+
+#include <linux/sizes.h>
+#include <asm/arch/imx-regs.h>
+#include "imx_env.h"
+#include "seco_imx8m_common.h"
+
+#define CONFIG_SPL_MAX_SIZE		       (148 * 1024)
+#define CONFIG_SYS_MONITOR_LEN		SZ_512K
+#define CONFIG_SYS_MMCSD_FS_BOOT_PARTITION	1
+#define CONFIG_SYS_UBOOT_BASE	\
+	(QSPI0_AMBA_BASE + CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR * 512)
+
+#define APX_WDT_TRIGGER_BASE                  GPIO3_BASE_ADDR
+#define APX_WDT_TRIGGER_NUM                   21
+
+#define APX_WDT_ENABLE_BASE                   GPIO3_BASE_ADDR
+#define APX_WDT_ENABLE_NUM                    22
+
+
+/* eMMC uSD Configuration */
+#define BOOT_ID_EMMC 0
+#define ROOT_ID_EMMC 0
+#define BOOT_ID_USD  1
+#define ROOT_ID_USD  1
+
+#ifdef CONFIG_SPL_BUILD
+#define CONFIG_SPL_STACK		0x920000
+#define CONFIG_SPL_BSS_START_ADDR	0x910000
+#define CONFIG_SPL_BSS_MAX_SIZE	SZ_8K	/* 8 KB */
+#define CONFIG_SYS_SPL_MALLOC_START	0x42200000
+#define CONFIG_SYS_SPL_MALLOC_SIZE	SZ_512K	/* 512 KB */
+
+/* malloc f used before GD_FLG_FULL_MALLOC_INIT set */
+#define CONFIG_MALLOC_F_ADDR		0x912000
+/* For RAW image gives a error info not panic */
+#define CONFIG_SPL_ABORT_ON_RAW_IMAGE
+
+#if defined(CONFIG_NAND_BOOT)
+#define CONFIG_SPL_NAND_SUPPORT
+#define CONFIG_SPL_DMA
+#define CONFIG_SPL_NAND_MXS
+#define CONFIG_SPL_NAND_BASE
+#define CONFIG_SPL_NAND_IDENT
+#define CONFIG_SYS_NAND_U_BOOT_OFFS 	0x4000000 /* Put the FIT out of first 64MB boot area */
+
+/* Set a redundant offset in nand FIT mtdpart. The new uuu will burn full boot image (not only FIT part) to the mtdpart, so we check both two offsets */
+#define CONFIG_SYS_NAND_U_BOOT_OFFS_REDUND \
+	(CONFIG_SYS_NAND_U_BOOT_OFFS + CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR * 512 - 0x8400)
+#endif
+
+#endif
+
+#define CONFIG_CMD_READ
+#define CONFIG_SERIAL_TAG
+#define CONFIG_FASTBOOT_USB_DEV 0
+
+#define CONFIG_REMAKE_ELF
+/* ENET Config */
+/* ENET1 */
+#if defined(CONFIG_FEC_MXC)
+#define CONFIG_ETHPRIME                 "FEC"
+#define PHY_ANEG_TIMEOUT 20000
+
+#define CONFIG_FEC_XCV_TYPE             RGMII
+#define CONFIG_FEC_MXC_PHYADDR          9
+#define FEC_QUIRK_ENET_MAC
+
+#define IMX_FEC_BASE			 0x30BE0000
+#endif
+
+#ifdef CONFIG_NAND_BOOT
+#define MFG_NAND_PARTITION "mtdparts=gpmi-nand:64m(nandboot),16m(nandfit),32m(nandkernel),16m(nanddtb),8m(nandtee),-(nandrootfs)"
+#endif
+
+/* Link Definitions */
+
+#define CONFIG_SYS_INIT_RAM_ADDR        0x40000000
+#define CONFIG_SYS_INIT_RAM_SIZE        0x200000
+#define CONFIG_SYS_INIT_SP_OFFSET \
+	(CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_ADDR \
+	(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)
+
+#define CONFIG_ENV_OVERWRITE
+#if defined(CONFIG_ENV_IS_IN_SPI_FLASH)
+#define CONFIG_ENV_SPI_BUS		CONFIG_SF_DEFAULT_BUS
+#define CONFIG_ENV_SPI_CS		CONFIG_SF_DEFAULT_CS
+#define CONFIG_ENV_SPI_MODE		CONFIG_SF_DEFAULT_MODE
+#define CONFIG_ENV_SPI_MAX_HZ		CONFIG_SF_DEFAULT_SPEED
+#endif
+#define CONFIG_SYS_MMC_ENV_DEV          0   /* USDHC3 */
+#define CONFIG_MMCROOT			"/dev/mmcblk0p3"  /* USDHC3 */
+
+#define CONFIG_SYS_SDRAM_BASE           0x40000000
+#define PHYS_SDRAM                      0x40000000
+#define PHYS_SDRAM_SIZE                 PHYS_DRAM_IS_3GB /* 2GB DDR */
+#define PHYS_DRAM_IS_1GB                0x40000000
+#define PHYS_DRAM_IS_2GB                0x80000000
+#define PHYS_DRAM_IS_3GB                0xc0000000
+#define PHYS_DRAM_IS_4GB                0x100000000
+#define PHYS_SDRAM_2                    0x100000000
+
+#ifdef CONFIG_DRAM_BANKS_2
+#define PHYS_SDRAM_2_SIZE               0x40000000 /* 1GB */
+#endif
+
+
+#define CONSOLE_DEV			"ttymxc1"
+#define DEFAULT_FDT_FILE	 	"seco-imx8mm-c61.dtb"
+
+/* Overlay Support */
+#define DEFAULT_FDT_OVERLAY_FILE	"seco-imx8mm-c61-video-sn65dsi84.dtbo"
+
+#define CONFIG_MXC_UART_BASE		UART2_BASE_ADDR
+
+/* Monitor Command Prompt */
+#define CONFIG_SYS_PROMPT_HUSH_PS2	"> "
+#define CONFIG_SYS_CBSIZE		2048
+#define CONFIG_SYS_MAXARGS		64
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE
+#define CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE + \
+					sizeof(CONFIG_SYS_PROMPT) + 16)
+
+#define CONFIG_IMX_BOOTAUX
+
+/* USDHC */
+#ifdef CONFIG_TARGET_SECO_IMX8MM_DDR4
+#define CONFIG_SYS_FSL_USDHC_NUM       1
+#else
+#define CONFIG_SYS_FSL_USDHC_NUM       2
+#endif
+#define CONFIG_SYS_FSL_ESDHC_ADDR      0
+
+#define SYS_MMC_IMG_LOAD_PART	        1
+
+#ifdef CONFIG_FSL_FSPI
+#define FSL_FSPI_FLASH_SIZE            SZ_32M
+#define FSL_FSPI_FLASH_NUM             1
+#define FSPI0_BASE_ADDR                0x30bb0000
+#define FSPI0_AMBA_BASE                0x0
+#define CONFIG_FSPI_QUAD_SUPPORT
+
+#define CONFIG_SYS_FSL_FSPI_AHB
+#endif
+
+#ifdef CONFIG_NAND_MXS
+#define CONFIG_CMD_NAND_TRIMFFS
+
+/* NAND stuff */
+#define CONFIG_SYS_MAX_NAND_DEVICE     1
+#define CONFIG_SYS_NAND_BASE           0x20000000
+#define CONFIG_SYS_NAND_5_ADDR_CYCLE
+#define CONFIG_SYS_NAND_ONFI_DETECTION
+#define CONFIG_SYS_NAND_USE_FLASH_BBT
+#endif /* CONFIG_NAND_MXS */
+
+#define CONFIG_SYS_I2C_SPEED		100000
+
+/* USB configs */
+#ifndef CONFIG_SPL_BUILD
+#define CONFIG_USBD_HS
+
+#define CONFIG_CMD_USB_MASS_STORAGE
+#define CONFIG_USB_FUNCTION_MASS_STORAGE
+
+#endif
+
+#define CONFIG_USB_GADGET_VBUS_DRAW 2
+
+#define CONFIG_MXC_USB_PORTSC  (PORT_PTS_UTMI | PORT_PTS_PTW)
+#define CONFIG_USB_MAX_CONTROLLER_COUNT         2
+
+#ifdef CONFIG_DM_VIDEO
+#define CONFIG_VIDEO_MXS
+#define CONFIG_VIDEO_LOGO
+#define CONFIG_SPLASH_SCREEN
+#define CONFIG_SPLASH_SCREEN_ALIGN
+#define CONFIG_CMD_BMP
+#define CONFIG_BMP_16BPP
+#define CONFIG_BMP_24BPP
+#define CONFIG_BMP_32BPP
+#define CONFIG_VIDEO_BMP_RLE8
+#define CONFIG_VIDEO_BMP_LOGO
+#endif
+
+/*DISTRO support*/
+#ifdef CONFIG_DISTRO_DEFAULTS
+
+#if CONFIG_IS_ENABLED(CMD_MMC)
+# define BOOT_TARGET_MMC(func) \
+	func(MMC, mmc, 0)      \
+	func(MMC, mmc, 1)
+#else
+# define BOOT_TARGET_MMC(func)
+#endif
+
+#if CONFIG_IS_ENABLED(CMD_USB)
+# define BOOT_TARGET_USB(func) func(USB, usb, 0)
+#else
+# define BOOT_TARGET_USB(func)
+#endif
+
+#if CONFIG_IS_ENABLED(CMD_PXE)
+# define BOOT_TARGET_PXE(func) func(PXE, pxe, na)
+#else
+# define BOOT_TARGET_PXE(func)
+#endif
+
+#if CONFIG_IS_ENABLED(CMD_DHCP)
+# define BOOT_TARGET_DHCP(func) func(DHCP, dhcp, na)
+#else
+# define BOOT_TARGET_DHCP(func)
+#endif
+
+#define BOOT_TARGET_DEVICES(func) \
+	BOOT_TARGET_USB(func) \
+	BOOT_TARGET_MMC(func) \
+	BOOT_TARGET_PXE(func) \
+	BOOT_TARGET_DHCP(func)
+
+#include <config_distro_bootcmd.h>
+#ifdef BOOTEFI_NAME
+#undef BOOTENV_SHARED_EFI
+#define BOOTENV_SHARED_EFI                                                 \
+	BOOTENV_EFI_BOOTMGR                                               \
+	\
+	"boot_efi_binary="                                                \
+		"load ${devtype} ${devnum}:${distro_bootpart} "           \
+			"${kernel_addr_r} efi/boot/"BOOTEFI_NAME"; "      \
+		"if fdt addr ${fdt_addr_r}; then "                        \
+			"bootefi ${kernel_addr_r} ${fdt_addr_r};"         \
+		"else "                                                   \
+			"bootefi ${kernel_addr_r} ${fdtcontroladdr};"     \
+		"fi\0"                                                    \
+	\
+	"load_efi_dtb="                                                   \
+		"load ${devtype} ${devnum}:${distro_bootpart} "           \
+			"${fdt_addr_r} ${prefix}${efi_fdtfile}\0"         \
+	\
+	"apply_dtb_overlay="                                              \
+		"load ${devtype} ${devnum}:${distro_bootpart} "           \
+			"${fdt_overlay_loadaddr} ${prefix}${fdt_overlay_file}; " \
+		"fdt addr ${fdt_addr_r}; fdt resize ${fdt_resize}; "      \
+		"fdt apply ${fdt_overlay_loadaddr}\0"                     \
+	\
+	"efi_dtb_prefixes=/ /dtb/ /dtb/current/\0"                        \
+	"scan_dev_for_efi="                                               \
+		"setenv efi_fdtfile ${fdtfile}; "                         \
+		BOOTENV_EFI_SET_FDTFILE_FALLBACK                          \
+		"for prefix in ${efi_dtb_prefixes}; do "                  \
+			"if test -e ${devtype} "                          \
+					"${devnum}:${distro_bootpart} "   \
+					"${prefix}${efi_fdtfile}; then "  \
+				"run load_efi_dtb; "                      \
+			"fi;"                                             \
+		"done;"                                                   \
+		"usb start; "                                             \
+		"if test -n \"${fdt_overlay_file}\"; then "               \
+			"for prefix in ${efi_dtb_prefixes}; do "          \
+				"if test -e ${devtype} "                  \
+					"${devnum}:${distro_bootpart} "   \
+					"${prefix}${fdt_overlay_file}; then " \
+		                                                         \
+					"run apply_dtb_overlay; "         \
+				"fi;"                                     \
+			"done;"                                           \
+		"fi;"                                                     \
+		"run boot_efi_bootmgr;"                                   \
+		"if test -e ${devtype} ${devnum}:${distro_bootpart} "     \
+					"efi/boot/"BOOTEFI_NAME"; then "  \
+				"echo Found EFI removable media binary "  \
+					"efi/boot/"BOOTEFI_NAME"; "       \
+				"run boot_efi_binary; "                   \
+				"echo EFI LOAD FAILED: continuing...; "   \
+		"fi; "                                                    \
+		"setenv efi_fdtfile\0"
+#endif  /* BOOTEFI_NAME */
+#else
+#define BOOTENV
+#endif /* CONFIG_DISTRO_DEFAULTS */
+
+#define CONFIG_MFG_ENV_SETTINGS \
+	MFG_ENV_SETTINGS_DEFAULT \
+	"initrd_addr=0x43800000\0" \
+	"initrd_high=0xffffffffffffffff\0" \
+	"emmc_dev=0\0"\
+	"sd_dev=1\0" \
+
+#ifdef CONFIG_EFI_LOADER
+#define EFI_SYSTEM_PARTITION          2
+#define ENV_EFI \
+	"efi_partition="__stringify(EFI_SYSTEM_PARTITION)"\0" \
+	"efi_file=EFI/BOOT/bootaa64.efi\0" \
+	"efi_device_id="__stringify(CONFIG_SYS_MMC_ENV_DEV)"\0" \
+	"efi_load=mmc dev ${efi_device_id}; fatload mmc ${efi_device_id}:${efi_partition} ${kernel_loadaddr} ${efi_file}\0"
+
+#undef CMD_SET_BOOT
+#define CMD_SET_BOOT \
+	"run bootargs_base; " \
+	"run fdt_load; " \
+	FDT_OVERLAY_APPLY \
+	"echo Trying to boot via UEFI variables Boot####, BootOrder, and BootNext... ; " \
+	"bootefi bootmgr ${fdt_loadaddr}; " \
+	"if test $? -ne 0; then "           \
+		"echo No entries from ubootefi.var or they are all invalid...Running directly via UEFI binary... ; "  \
+		"run efi_load; " \
+		"bootefi ${kernel_loadaddr} ${fdt_loadaddr}; " \
+	"fi;"
+
+#undef CONFIG_EXTRA_ENV_SETTINGS
+#define CONFIG_EXTRA_ENV_SETTINGS       \
+	CONFIG_MFG_ENV_SETTINGS \
+	BOOTENV \
+	ENV_COMMON                      \
+	ENV_BOOTARG_BASE                \
+	ENV_KERNEL                      \
+	ENV_FDT                         \
+	ENV_FDT_OVERLAY                 \
+	ENV_ROOT                        \
+	ENV_EFI                         \
+	"kernel_addr_r=" __stringify(KERNEL_LOADADDR) "\0" \
+	"fdtfile=" DEFAULT_FDT_FILE "\0" \
+	"fdt_addr_r="__stringify(FDT_LOADADDR)"\0" \
+	"console=ttymxc1,115200\0" \
+	"mmcpart=" __stringify(SYS_MMC_IMG_LOAD_PART) "\0" \
+	"mmcroot=" CONFIG_MMCROOT " rootwait rw\0" \
+	"scriptaddr=0x43500000\0" \
+	"dfu_alt_info=mmc 0=flash-bin raw 0x42 0x2000 mmcpart 1\0" \
+	"usbsetup=usb start\0" \
+	"bsp_bootcmd=" CMD_SET_BOOT "\0"
+
+#else /*Boot environment without UEFI support*/
+#undef CONFIG_EXTRA_ENV_SETTINGS
+#define CONFIG_EXTRA_ENV_SETTINGS           \
+	CONFIG_MFG_ENV_SETTINGS \
+	ENV_COMMON                       \
+	ENV_BOOTARG_BASE                 \
+	ENV_KERNEL                       \
+	ENV_FDT                          \
+	ENV_FDT_OVERLAY                  \
+	ENV_ROOT                         \
+	"bootcmd=" CMD_SET_BOOT "\0"
+
+#endif /*CONFIG_EFI_SECURE_BOOT*/
+
+#endif
diff --git a/include/configs/imx_env.h b/include/configs/imx_env.h
new file mode 100644
index 0000000000..de4636d1da
--- /dev/null
+++ b/include/configs/imx_env.h
@@ -0,0 +1,49 @@
+/* Copyright 2018 NXP
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#ifndef __IMX_COMMON_CONFIG_H
+#define __IMX_COMMON_CONFIG_H
+
+#ifdef CONFIG_ARM64
+    #define MFG_BOOT_CMD "booti "
+#else
+    #define MFG_BOOT_CMD "bootz "
+#endif
+
+#ifdef CONFIG_USB_PORT_AUTO
+    #define FASTBOOT_CMD "echo \"Run fastboot ...\"; fastboot auto; "
+#else
+    #define FASTBOOT_CMD "echo \"Run fastboot ...\"; fastboot 0; "
+#endif
+
+/* define the nandfit partiton environment for uuu */
+#if defined(CONFIG_IMX8MM) || defined(CONFIG_IMX8MQ) || \
+	defined(CONFIG_IMX8QM) || defined(CONFIG_IMX8QXP) || \
+	defined(CONFIG_IMX8DXL) || defined(CONFIG_IMX8MN) || \
+	defined(CONFIG_IMX8MP)
+#define MFG_NAND_FIT_PARTITION "nandfit_part=yes\0"
+#else
+#define MFG_NAND_FIT_PARTITION ""
+#endif
+
+#define MFG_ENV_SETTINGS_DEFAULT \
+	"mfgtool_args=setenv bootargs console=${console},${baudrate} " \
+		"rdinit=/linuxrc " \
+		"clk_ignore_unused "\
+		"\0" \
+	"kboot="MFG_BOOT_CMD"\0"\
+	"bootcmd_mfg=run mfgtool_args;" \
+        "if iminfo ${initrd_addr}; then " \
+            "if test ${tee} = yes; then " \
+                "bootm ${tee_addr} ${initrd_addr} ${fdt_addr}; " \
+            "else " \
+                MFG_BOOT_CMD "${loadaddr} ${initrd_addr} ${fdt_addr}; " \
+            "fi; " \
+        "else " \
+		FASTBOOT_CMD  \
+        "fi;\0" \
+	MFG_NAND_FIT_PARTITION \
+
+#endif
