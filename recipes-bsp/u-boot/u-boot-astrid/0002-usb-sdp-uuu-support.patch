diff --git a/Makefile b/Makefile
index 697cc51d67..9dec1773ba 100644
--- a/Makefile
+++ b/Makefile
@@ -836,6 +836,7 @@ libs-y += drivers/usb/musb/
 libs-y += drivers/usb/musb-new/
 libs-y += drivers/usb/phy/
 libs-y += drivers/usb/ulpi/
+libs-y += drivers/usb/imx/
 ifdef CONFIG_POST
 libs-y += post/
 endif
diff --git a/arch/arm/include/asm/arch-imx8m/clock.h b/arch/arm/include/asm/arch-imx8m/clock.h
index c705dfdf46..c349b42a47 100644
--- a/arch/arm/include/asm/arch-imx8m/clock.h
+++ b/arch/arm/include/asm/arch-imx8m/clock.h
@@ -277,3 +277,4 @@ int enable_i2c_clk(unsigned char enable, unsigned int i2c_num);
 int set_clk_enet(enum enet_freq type);
 int set_clk_eqos(enum enet_freq type);
 void hab_caam_clock_enable(unsigned char enable);
+void enable_usboh3_clk(unsigned char enable);
diff --git a/arch/arm/include/asm/arch-imx8m/imx-regs.h b/arch/arm/include/asm/arch-imx8m/imx-regs.h
index 45d95a7c19..1d66a4faac 100644
--- a/arch/arm/include/asm/arch-imx8m/imx-regs.h
+++ b/arch/arm/include/asm/arch-imx8m/imx-regs.h
@@ -47,6 +47,7 @@
 #define USDHC2_BASE_ADDR	0x30B50000
 #ifdef CONFIG_IMX8MM
 #define USDHC3_BASE_ADDR	0x30B60000
+#define USB_BASE_ADDR		0x32E40000
 #endif
 
 #define TZASC_BASE_ADDR		0x32F80000
@@ -515,5 +516,14 @@ struct pgc_reg {
 	u32 pgauxsw;
 	u32 pgdr;
 };
+
+#include <stdbool.h>
+bool is_usb_boot(void);
+#define is_boot_from_usb  is_usb_boot
+
+#if defined(CONFIG_IMX8MM)
+#define disconnect_from_pc(void) writel(0x0, USB_BASE_ADDR + 0x140)
+#endif
+
 #endif
 #endif
diff --git a/arch/arm/include/asm/arch-imx8m/sys_proto.h b/arch/arm/include/asm/arch-imx8m/sys_proto.h
index d328542ece..3e54f9b676 100644
--- a/arch/arm/include/asm/arch-imx8m/sys_proto.h
+++ b/arch/arm/include/asm/arch-imx8m/sys_proto.h
@@ -11,6 +11,7 @@
 void set_wdog_reset(struct wdog_regs *wdog);
 void enable_tzc380(void);
 void restore_boot_params(void);
+int imx8m_usb_power(int usb_id, bool on);
 extern unsigned long rom_pointer[];
 enum boot_device get_boot_device(void);
 bool is_usb_boot(void);
diff --git a/arch/arm/include/asm/mach-imx/regs-usbphy.h b/arch/arm/include/asm/mach-imx/regs-usbphy.h
index 2b18ec20f3..bd1bca54b6 100644
--- a/arch/arm/include/asm/mach-imx/regs-usbphy.h
+++ b/arch/arm/include/asm/mach-imx/regs-usbphy.h
@@ -22,4 +22,7 @@
 #define USBPHY_CTRL_CLKGATE				(1 << 30)
 #define USBPHY_CTRL_SFTRST				(1 << 31)
 
+#define USBNC_PHY_STATUS_OFFSET	0x23C
+#define USBNC_PHYSTATUS_ID_DIG	(1 << 4) /* otg_id status */
+
 #endif /* __REGS_USBPHY_H__ */
diff --git a/arch/arm/include/asm/mach-imx/sys_proto.h b/arch/arm/include/asm/mach-imx/sys_proto.h
index 0c0c7814fb..37fd427cc0 100644
--- a/arch/arm/include/asm/mach-imx/sys_proto.h
+++ b/arch/arm/include/asm/mach-imx/sys_proto.h
@@ -228,6 +228,8 @@ int mxs_reset_block(struct mxs_register_32 *reg);
 int mxs_wait_mask_set(struct mxs_register_32 *reg, u32 mask, u32 timeout);
 int mxs_wait_mask_clr(struct mxs_register_32 *reg, u32 mask, u32 timeout);
 
+void board_late_mmc_env_init(void);
+
 unsigned long call_imx_sip(unsigned long id, unsigned long reg0,
 			   unsigned long reg1, unsigned long reg2,
 			   unsigned long reg3);
diff --git a/arch/arm/mach-imx/imx8m/clock_imx8mm.c b/arch/arm/mach-imx/imx8m/clock_imx8mm.c
index 76132defc2..aa1d6a33e4 100644
--- a/arch/arm/mach-imx/imx8m/clock_imx8mm.c
+++ b/arch/arm/mach-imx/imx8m/clock_imx8mm.c
@@ -908,6 +908,22 @@ u32 imx_get_eqos_csr_clk(void)
 }
 #endif
 
+void enable_usboh3_clk(unsigned char enable)
+{
+	if (enable) {
+		clock_enable(CCGR_USB_MSCALE_PL301, 0);
+		/* 500M */
+		clock_set_target_val(USB_BUS_CLK_ROOT, CLK_ROOT_ON | CLK_ROOT_SOURCE_SEL(1));
+		/* 100M */
+		clock_set_target_val(USB_CORE_REF_CLK_ROOT, CLK_ROOT_ON | CLK_ROOT_SOURCE_SEL(1));
+		/* 100M */
+		clock_set_target_val(USB_PHY_REF_CLK_ROOT, CLK_ROOT_ON | CLK_ROOT_SOURCE_SEL(1));
+		clock_enable(CCGR_USB_MSCALE_PL301, 1);
+	} else {
+		clock_enable(CCGR_USB_MSCALE_PL301, 0);
+	}
+}
+
 #ifdef CONFIG_FEC_MXC
 int set_clk_enet(enum enet_freq type)
 {
diff --git a/arch/arm/mach-imx/imx8m/soc.c b/arch/arm/mach-imx/imx8m/soc.c
index 1a5a391443..a92c21bcb5 100644
--- a/arch/arm/mach-imx/imx8m/soc.c
+++ b/arch/arm/mach-imx/imx8m/soc.c
@@ -29,6 +29,7 @@
 #include <imx_sip.h>
 #include <linux/arm-smccc.h>
 #include <linux/bitops.h>
+#include <asm/setup.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -673,6 +674,18 @@ bool is_usb_boot(void)
 {
 	return get_boot_device() == USB_BOOT;
 }
+#ifdef CONFIG_SERIAL_TAG
+void get_board_serial(struct tag_serialnr *serialnr)
+{
+	struct ocotp_regs *ocotp = (struct ocotp_regs *)OCOTP_BASE_ADDR;
+	struct fuse_bank *bank = &ocotp->bank[0];
+	struct fuse_bank0_regs *fuse =
+		(struct fuse_bank0_regs *)bank->fuse_regs;
+
+	serialnr->low = fuse->uid_low;
+	serialnr->high = fuse->uid_high;
+}
+#endif
 
 #ifdef CONFIG_OF_SYSTEM_SETUP
 bool check_fdt_new_path(void *blob)
@@ -1216,6 +1229,62 @@ int arch_misc_init(void)
 }
 #endif
 
+#ifdef CONFIG_SPL_BUILD
+static uint32_t gpc_pu_m_core_offset[11] = {
+	0xc00, 0xc40, 0xc80, 0xcc0,
+	0xdc0, 0xe00, 0xe40, 0xe80,
+	0xec0, 0xf00, 0xf40,
+};
+
+#define PGC_PCR				0
+
+void imx_gpc_set_m_core_pgc(unsigned int offset, bool pdn)
+{
+	uint32_t val;
+	uintptr_t reg = GPC_BASE_ADDR + offset;
+
+	val = readl(reg);
+	val &= ~(0x1 << PGC_PCR);
+
+	if(pdn)
+		val |= 0x1 << PGC_PCR;
+	writel(val, reg);
+}
+
+void imx8m_usb_power_domain(uint32_t domain_id, bool on)
+{
+	uint32_t val;
+	uintptr_t reg;
+
+	imx_gpc_set_m_core_pgc(gpc_pu_m_core_offset[domain_id], true);
+
+	reg = GPC_BASE_ADDR + (on ? 0xf8 : 0x104);
+	val = 1 << (domain_id > 3 ? (domain_id + 3) : domain_id);
+	writel(val, reg);
+	while (readl(reg) & val)
+		;
+	imx_gpc_set_m_core_pgc(gpc_pu_m_core_offset[domain_id], false);
+}
+#endif
+
+int imx8m_usb_power(int usb_id, bool on)
+{
+	if (usb_id > 1)
+		return -EINVAL;
+
+#ifdef CONFIG_SPL_BUILD
+	imx8m_usb_power_domain(2 + usb_id, on);
+#else
+	struct arm_smccc_res res;
+	arm_smccc_smc(IMX_SIP_GPC, IMX_SIP_GPC_PM_DOMAIN,
+			2 + usb_id, on, 0, 0, 0, 0, &res);
+	if (res.a0)
+		return -EPERM;
+#endif
+
+	return 0;
+}
+
 void imx_tmu_arch_init(void *reg_base)
 {
 	if (is_imx8mm() || is_imx8mn()) {
diff --git a/common/autoboot.c b/common/autoboot.c
index b8861d5621..1df1b5d034 100644
--- a/common/autoboot.c
+++ b/common/autoboot.c
@@ -449,6 +449,21 @@ const char *bootdelay_process(void)
 	if (IS_ENABLED(CONFIG_OF_CONTROL))
 		bootdelay = ofnode_conf_read_int("bootdelay", bootdelay);
 
+#if defined(is_boot_from_usb)
+	if (is_boot_from_usb() && env_get("bootcmd_mfg")) {
+		disconnect_from_pc();
+		printf("Boot from USB for mfgtools\n");
+		bootdelay = 0;
+		env_set_default("Use default environment for \
+				 mfgtools\n", 0);
+	} else if (is_boot_from_usb()) {
+		printf("Boot from USB for uuu\n");
+		env_set("bootcmd", "fastboot 0");
+	} else {
+		printf("Normal Boot\n");
+	}
+#endif
+
 	debug("### main_loop entered: bootdelay=%d\n\n", bootdelay);
 
 	if (IS_ENABLED(CONFIG_AUTOBOOT_MENU_SHOW))
@@ -465,6 +480,13 @@ const char *bootdelay_process(void)
 	else
 		s = env_get("bootcmd");
 
+#if defined(is_boot_from_usb)
+	if (is_boot_from_usb() && env_get("bootcmd_mfg")) {
+		s = env_get("bootcmd_mfg");
+		printf("Run bootcmd_mfg: %s\n", s);
+	}
+#endif
+
 	if (IS_ENABLED(CONFIG_OF_CONTROL))
 		process_fdt_options(gd->fdt_blob);
 	stored_bootdelay = bootdelay;
diff --git a/disk/part_efi.c b/disk/part_efi.c
index f1f3e5bcef..c0c381614e 100644
--- a/disk/part_efi.c
+++ b/disk/part_efi.c
@@ -151,6 +151,25 @@ static int validate_gpt_header(gpt_header *gpt_h, lbaint_t lba,
 	return 0;
 }
 
+static void prepare_last_lba_gpt_header(struct blk_desc *dev_desc, gpt_header *gpt_h)
+{
+	uint32_t calc_crc32;
+	uint64_t val;
+
+	/* recalculate the values for the Backup GPT Header */
+	val = le64_to_cpu(gpt_h->my_lba);
+	gpt_h->my_lba = cpu_to_le64(dev_desc->lba - 1);;
+	gpt_h->alternate_lba = cpu_to_le64(val);
+	gpt_h->last_usable_lba = cpu_to_le64(dev_desc->lba - 34);
+	gpt_h->partition_entry_lba =
+			cpu_to_le64(le64_to_cpu(gpt_h->last_usable_lba) + 1);
+	gpt_h->header_crc32 = 0;
+
+	calc_crc32 = efi_crc32((const unsigned char *)gpt_h,
+			       le32_to_cpu(gpt_h->header_size));
+	gpt_h->header_crc32 = cpu_to_le32(calc_crc32);
+}
+
 static int validate_gpt_entries(gpt_header *gpt_h, gpt_entry *gpt_e)
 {
 	uint32_t calc_crc32;
@@ -876,6 +895,58 @@ int write_mbr_and_gpt_partitions(struct blk_desc *dev_desc, void *buf)
 
 	return 0;
 }
+int write_backup_gpt_partitions(struct blk_desc *dev_desc, void *buf)
+{
+	gpt_header *gpt_h;
+	gpt_entry *gpt_e;
+	int gpt_e_blk_cnt;
+	lbaint_t lba;
+	int cnt;
+
+	if (is_valid_gpt_buf(dev_desc, buf))
+		return -1;
+
+	/* determine start of GPT Header in the buffer */
+	gpt_h = buf + (GPT_PRIMARY_PARTITION_TABLE_LBA *
+		       dev_desc->blksz);
+
+	/* determine start of GPT Entries in the buffer */
+	gpt_e = buf + (le64_to_cpu(gpt_h->partition_entry_lba) *
+		       dev_desc->blksz);
+	gpt_e_blk_cnt = BLOCK_CNT((le32_to_cpu(gpt_h->num_partition_entries) *
+				   le32_to_cpu(gpt_h->sizeof_partition_entry)),
+				  dev_desc);
+
+	/* write MBR */
+	lba = 0;	/* MBR is always at 0 */
+	cnt = 1;	/* MBR (1 block) */
+	if (blk_dwrite(dev_desc, lba, cnt, buf) != cnt) {
+		printf("%s: failed writing '%s' (%d blks at 0x" LBAF ")\n",
+		       __func__, "MBR", cnt, lba);
+		return 1;
+	}
+
+	prepare_last_lba_gpt_header(dev_desc, gpt_h);
+
+	/* write Backup GPT */
+	lba = le64_to_cpu(gpt_h->partition_entry_lba);
+	cnt = gpt_e_blk_cnt;
+	if (blk_dwrite(dev_desc, lba, cnt, gpt_e) != cnt) {
+		printf("%s: failed writing '%s' (%d blks at 0x" LBAF ")\n",
+		       __func__, "Backup GPT Entries", cnt, lba);
+		return 1;
+	}
+
+	lba = le64_to_cpu(gpt_h->my_lba);
+	cnt = 1;	/* GPT Header (1 block) */
+	if (blk_dwrite(dev_desc, lba, cnt, gpt_h) != cnt) {
+		printf("%s: failed writing '%s' (%d blks at 0x" LBAF ")\n",
+		       __func__, "Backup GPT Header", cnt, lba);
+		return 1;
+	}
+
+	return 0;
+}
 #endif
 
 /*
diff --git a/drivers/Makefile b/drivers/Makefile
index 4e7cf28440..035b159d57 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -59,7 +59,7 @@ obj-$(CONFIG_OMAP_USB_PHY) += usb/phy/
 obj-$(CONFIG_SPL_SATA) += ata/ scsi/
 obj-$(CONFIG_HAVE_BLOCK_DEVICE) += block/
 obj-$(CONFIG_SPL_THERMAL) += thermal/
-
+obj-$(CONFIG_SPL_USB_GADGET) += usb/imx/
 endif
 endif
 
diff --git a/drivers/fastboot/Makefile b/drivers/fastboot/Makefile
index 048af5aa82..6a7da0437a 100644
--- a/drivers/fastboot/Makefile
+++ b/drivers/fastboot/Makefile
@@ -5,3 +5,4 @@ obj-y += fb_getvar.o
 obj-y += fb_command.o
 obj-$(CONFIG_FASTBOOT_FLASH_MMC) += fb_mmc.o
 obj-$(CONFIG_FASTBOOT_FLASH_NAND) += fb_nand.o
+obj-y += fb_fsl/
diff --git a/drivers/fastboot/fb_command.c b/drivers/fastboot/fb_command.c
index 98eccc3455..4d890f94c3 100644
--- a/drivers/fastboot/fb_command.c
+++ b/drivers/fastboot/fb_command.c
@@ -13,7 +13,9 @@
 #include <flash.h>
 #include <part.h>
 #include <stdlib.h>
-
+#if CONFIG_IS_ENABLED(FASTBOOT_UUU_SUPPORT)
+#include <fb_fsl.h>
+#endif
 /**
  * image_size - final fastboot image size
  */
@@ -313,9 +315,16 @@ void fastboot_data_complete(char *response)
 static void flash(char *cmd_parameter, char *response)
 {
 #if CONFIG_IS_ENABLED(FASTBOOT_FLASH_MMC)
+
+#if CONFIG_IS_ENABLED(FASTBOOT_UUU_SUPPORT)
+	fastboot_process_flash(cmd_parameter, fastboot_buf_addr,
+		image_size, response);
+#else
 	fastboot_mmc_flash_write(cmd_parameter, fastboot_buf_addr, image_size,
 				 response);
 #endif
+#endif
+
 #if CONFIG_IS_ENABLED(FASTBOOT_FLASH_NAND)
 	fastboot_nand_flash_write(cmd_parameter, fastboot_buf_addr, image_size,
 				  response);
@@ -357,10 +366,12 @@ static void run_ucmd(char *cmd_parameter, char *response)
 		return;
 	}
 
-	if (run_command(cmd_parameter, 0))
+	if (run_command(cmd_parameter, 0)) {
 		fastboot_fail("", response);
-	else
+	} else {
 		fastboot_okay(NULL, response);
+		fastboot_setup();
+	}
 }
 
 static char g_a_cmd_buff[64];
diff --git a/drivers/fastboot/fb_fsl/Makefile b/drivers/fastboot/fb_fsl/Makefile
new file mode 100644
index 0000000000..0461f68f7c
--- /dev/null
+++ b/drivers/fastboot/fb_fsl/Makefile
@@ -0,0 +1,11 @@
+#
+# Copyright 2019 NXP
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+ccflags-y += -I./lib
+
+ifndef CONFIG_SPL_BUILD
+obj-y += fb_fsl_dev.o fb_fsl_common.o fb_fsl_partitions.o
+endif
diff --git a/drivers/fastboot/fb_fsl/fb_fsl_common.c b/drivers/fastboot/fb_fsl/fb_fsl_common.c
new file mode 100644
index 0000000000..559e7e4755
--- /dev/null
+++ b/drivers/fastboot/fb_fsl/fb_fsl_common.c
@@ -0,0 +1,426 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2019 NXP
+ */
+
+#include <asm/mach-imx/sys_proto.h>
+#include <fb_fsl.h>
+#include <fastboot.h>
+#include <mmc.h>
+#include <android_image.h>
+#include <asm/bootm.h>
+#include <nand.h>
+#include <part.h>
+#include <sparse_format.h>
+#include <image-sparse.h>
+#include <image.h>
+#include <asm/mach-imx/boot_mode.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/setup.h>
+#include <env.h>
+#ifdef CONFIG_ANDROID_RECOVERY
+#include <recovery.h>
+#endif
+
+#ifdef CONFIG_BCB_SUPPORT
+#include "bcb.h"
+#endif
+
+#ifdef CONFIG_AVB_SUPPORT
+#include <dt_table.h>
+#include <fsl_avb.h>
+#endif
+
+#ifdef CONFIG_ANDROID_THINGS_SUPPORT
+#include <asm-generic/gpio.h>
+#include <asm/mach-imx/gpio.h>
+#include "../lib/avb/fsl/fsl_avbkey.h"
+#include "../arch/arm/include/asm/mach-imx/hab.h"
+#endif
+
+#ifdef CONFIG_IMX_TRUSTY_OS
+#include "u-boot/sha256.h"
+#include <trusty/libtipc.h>
+
+extern int armv7_init_nonsec(void);
+extern void trusty_os_init(void);
+#endif
+
+#include "fb_fsl_common.h"
+
+#include <serial.h>
+#include <stdio_dev.h>
+
+#if defined(CONFIG_AVB_SUPPORT) && defined(CONFIG_MMC)
+AvbABOps fsl_avb_ab_ops = {
+	.read_ab_metadata = fsl_avb_ab_data_read,
+	.write_ab_metadata = fsl_avb_ab_data_write,
+	.ops = NULL
+};
+#ifdef CONFIG_AVB_ATX
+AvbAtxOps fsl_avb_atx_ops = {
+	.ops = NULL,
+	.read_permanent_attributes = fsl_read_permanent_attributes,
+	.read_permanent_attributes_hash = fsl_read_permanent_attributes_hash,
+#ifdef CONFIG_IMX_TRUSTY_OS
+	.set_key_version = fsl_write_rollback_index_rpmb,
+#else
+	.set_key_version = fsl_set_key_version,
+#endif
+	.get_random = fsl_get_random
+};
+#endif
+AvbOps fsl_avb_ops = {
+	.ab_ops = &fsl_avb_ab_ops,
+#ifdef CONFIG_AVB_ATX
+	.atx_ops = &fsl_avb_atx_ops,
+#endif
+	.read_from_partition = fsl_read_from_partition_multi,
+	.write_to_partition = fsl_write_to_partition,
+#ifdef CONFIG_AVB_ATX
+	.validate_vbmeta_public_key = avb_atx_validate_vbmeta_public_key,
+#else
+	.validate_vbmeta_public_key = fsl_validate_vbmeta_public_key_rpmb,
+#endif
+	.read_rollback_index = fsl_read_rollback_index_rpmb,
+        .write_rollback_index = fsl_write_rollback_index_rpmb,
+	.read_is_device_unlocked = fsl_read_is_device_unlocked,
+	.get_unique_guid_for_partition = fsl_get_unique_guid_for_partition,
+	.get_size_of_partition = fsl_get_size_of_partition
+};
+#endif
+
+int get_block_size(void) {
+        int dev_no = 0;
+        struct blk_desc *dev_desc;
+
+        dev_no = fastboot_devinfo.dev_id;
+        dev_desc = blk_get_dev(fastboot_devinfo.type == DEV_SATA ? "scsi" : "mmc", dev_no);
+        if (NULL == dev_desc) {
+                printf("** Block device %s %d not supported\n",
+                       fastboot_devinfo.type == DEV_SATA ? "scsi" : "mmc",
+                       dev_no);
+                return 0;
+        }
+        return dev_desc->blksz;
+}
+
+struct fastboot_device_info fastboot_devinfo = {0xff, 0xff};
+
+#ifdef CONFIG_FLASH_MCUFIRMWARE_SUPPORT
+struct fastboot_device_info fastboot_firmwareinfo;
+#endif
+
+/**
+ * fastboot_none() - Skip the common write operation, nothing output.
+ *
+ * @response: Pointer to fastboot response buffer
+ */
+void fastboot_none_resp(char *response)
+{
+	*response = 0;
+}
+
+void board_fastboot_setup(void)
+{
+	static char boot_dev_part[32];
+	u32 dev_no;
+
+	switch (get_boot_device()) {
+	case SD1_BOOT:
+	case SD2_BOOT:
+	case SD3_BOOT:
+	case SD4_BOOT:
+	case MMC1_BOOT:
+	case MMC2_BOOT:
+	case MMC3_BOOT:
+	case MMC4_BOOT:
+		dev_no = mmc_get_env_dev();
+		sprintf(boot_dev_part,"mmc%d",dev_no);
+		if (!env_get("fastboot_dev"))
+			env_set("fastboot_dev", boot_dev_part);
+		sprintf(boot_dev_part, "boota mmc%d", dev_no);
+		if (!env_get("bootcmd"))
+			env_set("bootcmd", boot_dev_part);
+		break;
+	case USB_BOOT:
+		printf("Detect USB boot. Will enter fastboot mode!\n");
+		if (!env_get("bootcmd"))
+			env_set("bootcmd", "fastboot 0");
+		break;
+	default:
+		if (!env_get("bootcmd"))
+			printf("unsupported boot devices\n");
+		break;
+	}
+
+	/* add soc type into bootargs */
+	if (is_mx6dqp()) {
+		if (!env_get("soc_type"))
+			env_set("soc_type", "imx6qp");
+	} else if (is_mx6dq()) {
+		if (!env_get("soc_type"))
+			env_set("soc_type", "imx6q");
+	} else if (is_mx6sdl()) {
+		if (!env_get("soc_type"))
+			env_set("soc_type", "imx6dl");
+	} else if (is_mx6sx()) {
+		if (!env_get("soc_type"))
+			env_set("soc_type", "imx6sx");
+	} else if (is_mx6sl()) {
+		if (!env_get("soc_type"))
+			env_set("soc_type", "imx6sl");
+	} else if (is_mx6ul()) {
+		if (!env_get("soc_type"))
+			env_set("soc_type", "imx6ul");
+	} else if (is_mx7()) {
+		if (!env_get("soc_type"))
+			env_set("soc_type", "imx7d");
+	} else if (is_mx7ulp()) {
+		if (!env_get("soc_type"))
+			env_set("soc_type", "imx7ulp");
+	} else if (is_imx8qm()) {
+		if (!env_get("soc_type"))
+			env_set("soc_type", "imx8qm");
+		if (is_soc_rev(CHIP_REV_A))
+			env_set("soc_rev", "reva");
+		else if (is_soc_rev(CHIP_REV_B))
+			env_set("soc_rev", "revb");
+	} else if (is_imx8qxp()) {
+		if (!env_get("soc_type"))
+			env_set("soc_type", "imx8qxp");
+		if (is_soc_rev(CHIP_REV_A))
+			env_set("soc_rev", "reva");
+		else if (is_soc_rev(CHIP_REV_B))
+			env_set("soc_rev", "revb");
+		else if (is_soc_rev(CHIP_REV_C))
+			env_set("soc_rev", "revc");
+	} else if (is_imx8mq()) {
+		if (!env_get("soc_type"))
+			env_set("soc_type", "imx8mq");
+	} else if (is_imx8mm()) {
+		if (!env_get("soc_type"))
+			env_set("soc_type", "imx8mm");
+	} else if (is_imx8mn()) {
+		if (!env_get("soc_type"))
+			env_set("soc_type", "imx8mn");
+	} else if (is_imx8mp()) {
+		if (!env_get("soc_type"))
+			env_set("soc_type", "imx8mp");
+	}
+}
+
+#ifdef CONFIG_ANDROID_RECOVERY
+void board_recovery_setup(void)
+{
+/* boot from current mmc with avb verify */
+#ifdef CONFIG_AVB_SUPPORT
+	if (!env_get("bootcmd_android_recovery"))
+		env_set("bootcmd_android_recovery", "boota recovery");
+#else
+	static char boot_dev_part[32];
+	u32 dev_no;
+
+	int bootdev = get_boot_device();
+	switch (bootdev) {
+	case SD1_BOOT:
+	case SD2_BOOT:
+	case SD3_BOOT:
+	case SD4_BOOT:
+	case MMC1_BOOT:
+	case MMC2_BOOT:
+	case MMC3_BOOT:
+	case MMC4_BOOT:
+		dev_no = mmc_get_env_dev();
+		sprintf(boot_dev_part,"boota mmc%d recovery",dev_no);
+		if (!env_get("bootcmd_android_recovery"))
+			env_set("bootcmd_android_recovery", boot_dev_part);
+		break;
+	default:
+		printf("Unsupported bootup device for recovery: dev: %d\n",
+			bootdev);
+		return;
+	}
+#endif /* CONFIG_AVB_SUPPORT */
+	printf("setup env for recovery..\n");
+	env_set("bootcmd", env_get("bootcmd_android_recovery"));
+}
+#endif /*CONFIG_ANDROID_RECOVERY*/
+
+#ifdef CONFIG_IMX_TRUSTY_OS
+#ifdef CONFIG_ARM64
+void tee_setup(void)
+{
+	trusty_ipc_init();
+}
+
+#else
+extern bool tos_flashed;
+
+void tee_setup(void)
+{
+	/* load tee from boot1 of eMMC. */
+	int mmcc = mmc_get_env_dev();
+	struct blk_desc *dev_desc = NULL;
+
+	struct mmc *mmc;
+	mmc = find_mmc_device(mmcc);
+	if (!mmc) {
+	            printf("boota: cannot find '%d' mmc device\n", mmcc);
+		            goto fail;
+	}
+
+	dev_desc = blk_get_dev("mmc", mmcc);
+	if (NULL == dev_desc) {
+	            printf("** Block device MMC %d not supported\n", mmcc);
+		            goto fail;
+	}
+
+	/* below was i.MX mmc operation code */
+	if (mmc_init(mmc)) {
+	            printf("mmc%d init failed\n", mmcc);
+		            goto fail;
+	}
+
+	struct fastboot_ptentry *tee_pte;
+	char *tee_ptn = FASTBOOT_PARTITION_TEE;
+	tee_pte = fastboot_flash_find_ptn(tee_ptn);
+	mmc_switch_part(mmc, TEE_HWPARTITION_ID);
+	if (!tee_pte) {
+		printf("boota: cannot find tee partition!\n");
+		fastboot_flash_dump_ptn();
+	}
+
+	if (blk_dread(dev_desc, tee_pte->start,
+		    tee_pte->length, (void *)TRUSTY_OS_ENTRY) < 0) {
+		printf("Failed to load tee.");
+	}
+	mmc_switch_part(mmc, FASTBOOT_MMC_USER_PARTITION_ID);
+
+	tos_flashed = false;
+	if(!valid_tos()) {
+		printf("TOS not flashed! Will enter TOS recovery mode. Everything will be wiped!\n");
+		fastboot_wipe_all();
+		run_command("fastboot 0", 0);
+		goto fail;
+	}
+#ifdef NON_SECURE_FASTBOOT
+	armv7_init_nonsec();
+	trusty_os_init();
+	trusty_ipc_init();
+#endif
+
+fail:
+	return;
+
+}
+#endif /* CONFIG_ARM64 */
+#endif /* CONFIG_IMX_TRUSTY_OS */
+
+static int _fastboot_setup_dev(int *switched)
+{
+	char *fastboot_env;
+	struct fastboot_device_info devinfo;;
+	fastboot_env = env_get("fastboot_dev");
+
+	if (fastboot_env) {
+		if (!strcmp(fastboot_env, "sata")) {
+			devinfo.type = DEV_SATA;
+			devinfo.dev_id = 0;
+		} else if (!strncmp(fastboot_env, "mmc", 3)) {
+			devinfo.type = DEV_MMC;
+			if(env_get("target_ubootdev"))
+				devinfo.dev_id = simple_strtoul(env_get("target_ubootdev"), NULL, 10);
+			else
+				devinfo.dev_id = mmc_get_env_dev();
+		} else {
+			return 1;
+		}
+	} else {
+		return 1;
+	}
+#ifdef CONFIG_FLASH_MCUFIRMWARE_SUPPORT
+	/* For imx7ulp, flash m4 images directly to spi nor-flash, M4 will
+	 * run automatically after powered on. For imx8mq, flash m4 images to
+	 * physical partition 'mcu_os', m4 will be kicked off by A core. */
+	fastboot_firmwareinfo.type = ANDROID_MCU_FRIMWARE_DEV_TYPE;
+#endif
+
+	if (switched) {
+		if (devinfo.type != fastboot_devinfo.type || devinfo.dev_id != fastboot_devinfo.dev_id)
+			*switched = 1;
+		else
+			*switched = 0;
+	}
+
+	fastboot_devinfo.type	 = devinfo.type;
+	fastboot_devinfo.dev_id = devinfo.dev_id;
+
+	return 0;
+}
+
+void fastboot_setup(void)
+{
+	int sw, ret;
+	struct tag_serialnr serialnr;
+	char serial[17];
+
+	if (!env_get("serial#")) {
+		get_board_serial(&serialnr);
+		sprintf(serial, "%08x%08x", serialnr.high, serialnr.low);
+		env_set("serial#", serial);
+	}
+
+	/*execute board relevant initilizations for preparing fastboot */
+	board_fastboot_setup();
+
+	/*get the fastboot dev*/
+	ret = _fastboot_setup_dev(&sw);
+
+	/*load partitions information for the fastboot dev*/
+	if (!ret && sw)
+		fastboot_load_partitions();
+
+	fastboot_init(NULL, 0);
+#ifdef CONFIG_AVB_SUPPORT
+	fsl_avb_ab_ops.ops = &fsl_avb_ops;
+#ifdef CONFIG_AVB_ATX
+	fsl_avb_atx_ops.ops = &fsl_avb_ops;
+#endif
+#endif
+}
+#if 0
+static void fastboot_putc(struct stdio_dev *dev, const char c)
+{
+	char buff[6] = "INFO";
+	buff[4] = c;
+	buff[5] = 0;
+	fastboot_tx_write_more(buff);
+}
+
+#define FASTBOOT_MAX_LEN 64
+
+static void fastboot_puts(struct stdio_dev *dev, const char *s)
+{
+	char buff[FASTBOOT_MAX_LEN + 1] = "INFO";
+	int len = strlen(s);
+	int i, left;
+
+	for (i = 0; i < len; i += FASTBOOT_MAX_LEN - 4) {
+		left = len - i;
+		if (left > FASTBOOT_MAX_LEN - 4)
+			left = FASTBOOT_MAX_LEN - 4;
+
+		memcpy(buff + 4, s + i, left);
+		buff[left + 4] = 0;
+		fastboot_tx_write_more(buff);
+	}
+}
+
+struct stdio_dev g_fastboot_stdio = {
+	.name = "fastboot",
+	.flags = DEV_FLAGS_OUTPUT,
+	.putc = fastboot_putc,
+	.puts = fastboot_puts,
+};
+#endif
diff --git a/drivers/fastboot/fb_fsl/fb_fsl_common.h b/drivers/fastboot/fb_fsl/fb_fsl_common.h
new file mode 100644
index 0000000000..6b957c43d5
--- /dev/null
+++ b/drivers/fastboot/fb_fsl/fb_fsl_common.h
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) 2016, Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * o Redistributions of source code must retain the above copyright notice, this list
+ *   of conditions and the following disclaimer.
+ *
+ * o Redistributions in binary form must reproduce the above copyright notice, this
+ *   list of conditions and the following disclaimer in the documentation and/or
+ *   other materials provided with the distribution.
+ *
+ * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
+ *   contributors may be used to endorse or promote products derived from this
+ *   software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef FB_FSL_COMMON_H
+#define FB_FSL_COMMON_H
+
+#ifdef CONFIG_AVB_SUPPORT
+#include <dt_table.h>
+#include <fsl_avb.h>
+#endif
+
+#if defined(CONFIG_AVB_SUPPORT) && defined(CONFIG_MMC)
+extern AvbABOps fsl_avb_ab_ops;
+#ifdef CONFIG_AVB_ATX
+extern AvbAtxOps fsl_avb_atx_ops;
+#endif
+extern AvbOps fsl_avb_ops;
+#endif
+
+#define IMX_SERIAL_LEN 32
+
+int get_block_size(void);
+void process_erase_mmc(const char *cmdbuf, char *response);
+char *get_serial(void);
+
+#endif	// FB_FSL_COMMON_H
diff --git a/drivers/fastboot/fb_fsl/fb_fsl_dev.c b/drivers/fastboot/fb_fsl/fb_fsl_dev.c
new file mode 100644
index 0000000000..0ac2de5d72
--- /dev/null
+++ b/drivers/fastboot/fb_fsl/fb_fsl_dev.c
@@ -0,0 +1,562 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2019 NXP
+ */
+
+#include <asm/mach-imx/sys_proto.h>
+#include <fb_fsl.h>
+#include <fastboot.h>
+#include <mmc.h>
+#include <android_image.h>
+#include <asm/bootm.h>
+#include <nand.h>
+#include <part.h>
+#include <sparse_format.h>
+#include <image-sparse.h>
+#include <image.h>
+#include <asm/mach-imx/boot_mode.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/setup.h>
+#include <env.h>
+
+#include "fb_fsl_common.h"
+
+static lbaint_t mmc_sparse_write(struct sparse_storage *info,
+		lbaint_t blk, lbaint_t blkcnt, const void *buffer)
+{
+#define SPARSE_FILL_BUF_SIZE (2 * 1024 * 1024)
+
+
+	struct blk_desc *dev_desc = (struct blk_desc *)info->priv;
+	ulong ret = 0;
+	void *data;
+	int fill_buf_num_blks, cnt;
+
+	if ((unsigned long)buffer & (CONFIG_SYS_CACHELINE_SIZE - 1)) {
+
+		fill_buf_num_blks = SPARSE_FILL_BUF_SIZE / info->blksz;
+
+		data = memalign(CONFIG_SYS_CACHELINE_SIZE, fill_buf_num_blks * info->blksz);
+
+		while (blkcnt) {
+
+			if (blkcnt > fill_buf_num_blks)
+				cnt = fill_buf_num_blks;
+			else
+				cnt = blkcnt;
+
+			memcpy(data, buffer, cnt * info->blksz);
+
+			ret += blk_dwrite(dev_desc, blk, cnt, data);
+
+			blk += cnt;
+			blkcnt -= cnt;
+			buffer = (void *)((unsigned long)buffer + cnt * info->blksz);
+
+		}
+
+		free(data);
+	} else {
+		ret = blk_dwrite(dev_desc, blk, blkcnt, buffer);
+	}
+
+	return ret;
+}
+
+static lbaint_t mmc_sparse_reserve(struct sparse_storage *info,
+		lbaint_t blk, lbaint_t blkcnt)
+{
+	return blkcnt;
+}
+
+int write_backup_gpt(void *download_buffer)
+{
+	int mmc_no = 0;
+	struct mmc *mmc;
+	struct blk_desc *dev_desc;
+
+	mmc_no = fastboot_devinfo.dev_id;
+	mmc = find_mmc_device(mmc_no);
+	if (mmc == NULL) {
+		printf("invalid mmc device\n");
+		return -1;
+	}
+	dev_desc = blk_get_dev("mmc", mmc_no);
+	if (dev_desc == NULL) {
+		printf("Can't get Block device MMC %d\n",
+			mmc_no);
+		return -ENODEV;
+	}
+
+	/* write backup get partition */
+	if (write_backup_gpt_partitions(dev_desc, download_buffer)) {
+		printf("writing GPT image fail\n");
+		return -1;
+	}
+
+	printf("flash backup gpt image successfully\n");
+	return 0;
+}
+
+static int get_fastboot_target_dev(char *mmc_dev, struct fastboot_ptentry *ptn)
+{
+	int dev = 0;
+	struct mmc *target_mmc;
+
+	/* Support flash bootloader to mmc 'target_ubootdev' devices, if the
+	* 'target_ubootdev' env is not set just flash bootloader to current
+	* mmc device.
+	*/
+	if ((!strncmp(ptn->name, FASTBOOT_PARTITION_BOOTLOADER,
+					sizeof(FASTBOOT_PARTITION_BOOTLOADER))) &&
+					(env_get("target_ubootdev"))) {
+		dev = simple_strtoul(env_get("target_ubootdev"), NULL, 10);
+
+		/* if target_ubootdev is set, it must be that users want to change
+		 * fastboot device, then fastboot environment need to be updated */
+		fastboot_setup();
+
+		target_mmc = find_mmc_device(dev);
+		if ((target_mmc == NULL) || mmc_init(target_mmc)) {
+			printf("MMC card init failed!\n");
+			return -1;
+		} else {
+			printf("Flash target is mmc%d\n", dev);
+			if (target_mmc->part_config != MMCPART_NOAVAILABLE)
+				sprintf(mmc_dev, "mmc dev %x %x", dev, /*slot no*/
+						FASTBOOT_MMC_BOOT_PARTITION_ID/*part no*/);
+			else
+				sprintf(mmc_dev, "mmc dev %x", dev);
+			}
+	} else if (ptn->partition_id != FASTBOOT_MMC_NONE_PARTITION_ID)
+		sprintf(mmc_dev, "mmc dev %x %x",
+				fastboot_devinfo.dev_id, /*slot no*/
+				ptn->partition_id /*part no*/);
+	else
+		sprintf(mmc_dev, "mmc dev %x",
+				fastboot_devinfo.dev_id /*slot no*/);
+	return 0;
+}
+
+static void process_flash_blkdev(const char *cmdbuf, void *download_buffer,
+			      u32 download_bytes, char *response)
+{
+	if (download_bytes) {
+		struct fastboot_ptentry *ptn;
+
+		/* Next is the partition name */
+		ptn = fastboot_flash_find_ptn(cmdbuf);
+		if (ptn == NULL) {
+			fastboot_fail("partition does not exist", response);
+			fastboot_flash_dump_ptn();
+		} else if ((download_bytes >
+			   ptn->length * MMC_SATA_BLOCK_SIZE) &&
+				!(ptn->flags & FASTBOOT_PTENTRY_FLAGS_WRITE_ENV)) {
+			printf("Image too large for the partition\n");
+			fastboot_fail("image too large for partition", response);
+		} else {
+			unsigned int temp;
+
+			char blk_dev[128];
+			char blk_write[128];
+			int blkret;
+
+			printf("writing to partition '%s'\n", ptn->name);
+			/* Get target flash device. */
+			if (get_fastboot_target_dev(blk_dev, ptn) != 0)
+				return;
+
+			if (!fastboot_parts_is_raw(ptn) &&
+				is_sparse_image(download_buffer)) {
+				int dev_no = 0;
+				struct mmc *mmc;
+				struct blk_desc *dev_desc;
+				struct disk_partition info;
+				struct sparse_storage sparse;
+				int err;
+
+				dev_no = fastboot_devinfo.dev_id;
+
+				printf("sparse flash target is %s:%d\n",
+				       fastboot_devinfo.type == DEV_SATA ? "scsi" : "mmc",
+				       dev_no);
+				if (fastboot_devinfo.type == DEV_MMC) {
+					mmc = find_mmc_device(dev_no);
+					if (mmc && mmc_init(mmc))
+						printf("MMC card init failed!\n");
+				}
+
+				dev_desc = blk_get_dev(fastboot_devinfo.type == DEV_SATA ? "scsi" : "mmc", dev_no);
+				if (!dev_desc || dev_desc->type == DEV_TYPE_UNKNOWN) {
+					printf("** Block device %s %d not supported\n",
+					       fastboot_devinfo.type == DEV_SATA ? "scsi" : "mmc",
+					       dev_no);
+					return;
+				}
+
+				if( strncmp(ptn->name, FASTBOOT_PARTITION_ALL,
+					    strlen(FASTBOOT_PARTITION_ALL)) == 0) {
+					info.blksz = dev_desc->blksz;
+					info.size = dev_desc->lba;
+					info.start = 0;
+				} else {
+
+					if (part_get_info(dev_desc,
+							  ptn->partition_index, &info)) {
+						printf("Bad partition index:%d for partition:%s\n",
+						ptn->partition_index, ptn->name);
+						return;
+					}
+				}
+				printf("writing to partition '%s' for sparse, buffer size %d\n",
+						ptn->name, download_bytes);
+
+				sparse.blksz = info.blksz;
+				sparse.start = info.start;
+				sparse.size = info.size;
+				sparse.write = mmc_sparse_write;
+				sparse.reserve = mmc_sparse_reserve;
+				sparse.mssg = fastboot_fail;
+				printf("Flashing sparse image at offset " LBAFU "\n",
+				       sparse.start);
+
+				sparse.priv = dev_desc;
+				err = write_sparse_image(&sparse, ptn->name, download_buffer,
+						   response);
+
+				if (!err)
+					fastboot_okay(NULL, response);
+			} else {
+				/* Will flash images in below case:
+				 * 1. Is not gpt partition.
+				 * 2. Is gpt partition but no overlay detected.
+				 * */
+				if (strncmp(ptn->name, "gpt", 3) || !bootloader_gpt_overlay()) {
+					/* block count */
+					if (strncmp(ptn->name, "gpt", 3) == 0) {
+						temp = (ANDROID_GPT_END +
+								MMC_SATA_BLOCK_SIZE - 1) /
+								MMC_SATA_BLOCK_SIZE;
+					} else {
+						temp = (download_bytes +
+								MMC_SATA_BLOCK_SIZE - 1) /
+								MMC_SATA_BLOCK_SIZE;
+					}
+
+					sprintf(blk_write, "%s write 0x%x 0x%x 0x%x",
+						fastboot_devinfo.type == DEV_SATA ? "scsi" : "mmc",
+						(unsigned int)(uintptr_t)download_buffer, /*source*/
+						ptn->start, /*dest*/
+						temp /*length*/);
+
+					printf("Initializing '%s'\n", ptn->name);
+
+					blkret = run_command(blk_dev, 0);
+					if (blkret)
+						fastboot_fail("Init of BLK device failed", response);
+					else
+						fastboot_okay(NULL, response);
+
+					printf("Writing '%s'\n", ptn->name);
+					if (run_command(blk_write, 0)) {
+						printf("Writing '%s' FAILED!\n", ptn->name);
+						fastboot_fail("Write partition failed", response);
+					} else {
+						printf("Writing '%s' DONE!\n", ptn->name);
+						fastboot_okay(NULL, response);
+					}
+				}
+				/* Write backup gpt image */
+				if (strncmp(ptn->name, "gpt", 3) == 0) {
+					if (write_backup_gpt(download_buffer))
+						fastboot_fail("write backup GPT image fail", response);
+					else
+						fastboot_okay(NULL, response);
+
+					/* will force scan the device,
+					 * so dev_desc can be re-inited
+					 * with the latest data */
+					run_command(blk_dev, 0);
+				}
+			}
+		}
+	} else {
+		fastboot_fail("no image downloaded", response);
+	}
+}
+
+static void process_erase_blkdev(const char *cmdbuf, char *response)
+{
+	int mmc_no = 0;
+	char blk_dev[128];
+	lbaint_t blks, blks_start, blks_size, grp_size;
+	struct mmc *mmc;
+	struct blk_desc *dev_desc;
+	struct fastboot_ptentry *ptn;
+	struct disk_partition info;
+
+	ptn = fastboot_flash_find_ptn(cmdbuf);
+	if ((ptn == NULL) || (ptn->flags & FASTBOOT_PTENTRY_FLAGS_UNERASEABLE)) {
+		fastboot_fail("partition does not exist or uneraseable", response);
+		fastboot_flash_dump_ptn();
+		return;
+	}
+
+	if (fastboot_devinfo.type == DEV_SATA) {
+		printf("Not support erase on SATA\n");
+		return;
+	}
+
+	mmc_no = fastboot_devinfo.dev_id;
+	printf("erase target is MMC:%d\n", mmc_no);
+
+	mmc = find_mmc_device(mmc_no);
+	if ((mmc == NULL) || mmc_init(mmc)) {
+		printf("MMC card init failed!\n");
+		return;
+	}
+
+	dev_desc = blk_get_dev("mmc", mmc_no);
+	if (NULL == dev_desc) {
+		printf("Block device MMC %d not supported\n",
+			mmc_no);
+		fastboot_fail("not valid MMC card", response);
+		return;
+	}
+
+	/* Get and switch target flash device. */
+	if (get_fastboot_target_dev(blk_dev, ptn) != 0) {
+		printf("failed to get target dev!\n");
+		return;
+	} else if (run_command(blk_dev, 0)) {
+		printf("Init of BLK device failed\n");
+		return;
+	}
+
+	if (part_get_info(dev_desc,
+				ptn->partition_index, &info)) {
+		printf("Bad partition index:%d for partition:%s\n",
+		ptn->partition_index, ptn->name);
+		fastboot_fail("erasing of MMC card", response);
+		return;
+	}
+
+	/* Align blocks to erase group size to avoid erasing other partitions */
+	grp_size = mmc->erase_grp_size;
+	blks_start = (info.start + grp_size - 1) & ~(grp_size - 1);
+	if (info.size >= grp_size)
+		blks_size = (info.size - (blks_start - info.start)) &
+				(~(grp_size - 1));
+	else
+		blks_size = 0;
+
+	printf("Erasing blocks " LBAFU " to " LBAFU " due to alignment\n",
+	       blks_start, blks_start + blks_size);
+
+	blks = blk_derase(dev_desc, blks_start, blks_size);
+	if (blks != blks_size) {
+		printf("failed erasing from device %d", dev_desc->devnum);
+		fastboot_fail("erasing of MMC card", response);
+		return;
+	}
+
+	printf("........ erased " LBAFU " bytes from '%s'\n",
+	       blks_size * info.blksz, cmdbuf);
+	fastboot_okay(NULL, response);
+
+    return;
+}
+
+#ifdef CONFIG_FLASH_MCUFIRMWARE_SUPPORT
+static void process_flash_sf(const char *cmdbuf, void *download_buffer,
+			      u32 download_bytes, char *response)
+{
+	int blksz = 0;
+	blksz = get_block_size();
+
+	if (download_bytes) {
+		struct fastboot_ptentry *ptn;
+		ptn = fastboot_flash_find_ptn(cmdbuf);
+		if (ptn == 0) {
+			fastboot_fail("partition does not exist", response);
+			fastboot_flash_dump_ptn();
+		} else if ((download_bytes > ptn->length * blksz)) {
+			fastboot_fail("image too large for partition", response);
+		/* TODO : Improve check for yaffs write */
+		} else {
+			int ret;
+			char sf_command[128];
+			/* Normal case */
+			/* Probe device */
+			sprintf(sf_command, "sf probe");
+			ret = run_command(sf_command, 0);
+			if (ret){
+				fastboot_fail("Probe sf failed", response);
+				return;
+			}
+			/* Erase */
+			sprintf(sf_command, "sf erase 0x%x 0x%lx", ptn->start * blksz, /*start*/
+			ptn->length * blksz /*size*/);
+			ret = run_command(sf_command, 0);
+			if (ret) {
+				fastboot_fail("Erasing sf failed", response);
+				return;
+			}
+			/* Write image */
+			sprintf(sf_command, "sf write 0x%x 0x%x 0x%x",
+					(unsigned int)(ulong)download_buffer, /* source */
+					ptn->start * blksz, /* start */
+					download_bytes /*size*/);
+			printf("sf write '%s'\n", ptn->name);
+			ret = run_command(sf_command, 0);
+			if (ret){
+				fastboot_fail("Writing sf failed", response);
+				return;
+			}
+			printf("sf write finished '%s'\n", ptn->name);
+			fastboot_okay(NULL, response);
+		}
+	} else {
+		fastboot_fail("no image downloaded", response);
+	}
+}
+
+#ifdef CONFIG_ARCH_IMX8M
+/* Check if the mcu image is built for running from TCM */
+static bool is_tcm_image(unsigned char *image_addr)
+{
+	u32 stack;
+
+	stack = *(u32 *)image_addr;
+
+	if ((stack != (u32)ANDROID_MCU_FIRMWARE_HEADER_STACK)) {
+		printf("Please flash mcu firmware images for running from TCM\n");
+		return false;
+	} else
+		return true;
+}
+#endif
+#endif
+
+void fastboot_process_erase(const char *cmdbuf, char *response)
+{
+	switch (fastboot_devinfo.type) {
+	case DEV_SATA:
+	case DEV_MMC:
+		process_erase_blkdev(cmdbuf, response);
+		break;
+	default:
+		printf("Not support flash command for current device %d\n",
+			fastboot_devinfo.type);
+		fastboot_fail("failed to flash device", response);
+		break;
+	}
+}
+
+void fastboot_process_flash(const char *cmdbuf, void *download_buffer,
+			      u32 download_bytes, char *response)
+{
+/* Check if we need to flash mcu firmware */
+#ifdef CONFIG_FLASH_MCUFIRMWARE_SUPPORT
+	if (!strncmp(cmdbuf, FASTBOOT_MCU_FIRMWARE_PARTITION,
+				sizeof(FASTBOOT_MCU_FIRMWARE_PARTITION))) {
+		switch (fastboot_firmwareinfo.type) {
+		case DEV_SF:
+			process_flash_sf(cmdbuf, download_buffer,
+				download_bytes, response);
+			break;
+#ifdef CONFIG_ARCH_IMX8M
+		case DEV_MMC:
+			if (is_tcm_image(download_buffer))
+				process_flash_blkdev(cmdbuf, download_buffer,
+					download_bytes, response);
+			break;
+#endif
+		default:
+			printf("Don't support flash firmware\n");
+		}
+		return;
+	}
+#endif
+	/* Normal case */
+	switch (fastboot_devinfo.type) {
+	case DEV_SATA:
+	case DEV_MMC:
+		process_flash_blkdev(cmdbuf, download_buffer,
+			download_bytes, response);
+		break;
+	default:
+		printf("Not support flash command for current device %d\n",
+			fastboot_devinfo.type);
+		fastboot_fail("failed to flash device", response);
+		break;
+	}
+}
+
+/* erase a partition on mmc */
+void process_erase_mmc(const char *cmdbuf, char *response)
+{
+	int mmc_no = 0;
+	lbaint_t blks, blks_start, blks_size, grp_size;
+	struct mmc *mmc;
+	struct blk_desc *dev_desc;
+	struct fastboot_ptentry *ptn;
+	struct disk_partition info;
+
+	ptn = fastboot_flash_find_ptn(cmdbuf);
+	if ((ptn == NULL) || (ptn->flags & FASTBOOT_PTENTRY_FLAGS_UNERASEABLE)) {
+		sprintf(response, "FAILpartition does not exist or uneraseable");
+		fastboot_flash_dump_ptn();
+		return;
+	}
+
+	mmc_no = fastboot_devinfo.dev_id;
+	printf("erase target is MMC:%d\n", mmc_no);
+
+	mmc = find_mmc_device(mmc_no);
+	if ((mmc == NULL) || mmc_init(mmc)) {
+		printf("MMC card init failed!\n");
+		return;
+	}
+
+	dev_desc = blk_get_dev("mmc", mmc_no);
+	if (NULL == dev_desc) {
+		printf("Block device MMC %d not supported\n",
+			mmc_no);
+		sprintf(response, "FAILnot valid MMC card");
+		return;
+	}
+
+	if (part_get_info(dev_desc,
+				ptn->partition_index, &info)) {
+		printf("Bad partition index:%d for partition:%s\n",
+		ptn->partition_index, ptn->name);
+		sprintf(response, "FAILerasing of MMC card");
+		return;
+	}
+
+	/* Align blocks to erase group size to avoid erasing other partitions */
+	grp_size = mmc->erase_grp_size;
+	blks_start = (info.start + grp_size - 1) & ~(grp_size - 1);
+	if (info.size >= grp_size)
+		blks_size = (info.size - (blks_start - info.start)) &
+				(~(grp_size - 1));
+	else
+		blks_size = 0;
+
+	printf("Erasing blocks " LBAFU " to " LBAFU " due to alignment\n",
+	       blks_start, blks_start + blks_size);
+
+	blks = blk_derase(dev_desc, blks_start, blks_size);
+	if (blks != blks_size) {
+		printf("failed erasing from device %d", dev_desc->devnum);
+		sprintf(response, "FAILerasing of MMC card");
+		return;
+	}
+
+	printf("........ erased " LBAFU " bytes from '%s'\n",
+	       blks_size * info.blksz, cmdbuf);
+	sprintf(response, "OKAY");
+
+    return;
+}
diff --git a/drivers/fastboot/fb_fsl/fb_fsl_partitions.c b/drivers/fastboot/fb_fsl/fb_fsl_partitions.c
new file mode 100644
index 0000000000..b4219d0f76
--- /dev/null
+++ b/drivers/fastboot/fb_fsl/fb_fsl_partitions.c
@@ -0,0 +1,408 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2019-2020 NXP
+ */
+
+#include <asm/mach-imx/sys_proto.h>
+#include <fb_fsl.h>
+#include <fastboot.h>
+#include <mmc.h>
+#include <android_image.h>
+#include <asm/bootm.h>
+#include <nand.h>
+#include <part.h>
+#include <sparse_format.h>
+#include <image-sparse.h>
+#include <image.h>
+#include <asm/mach-imx/boot_mode.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/setup.h>
+#include <env.h>
+#ifdef CONFIG_DM_SCSI
+#include <scsi.h>
+#endif
+
+#if defined(CONFIG_FASTBOOT_LOCK)
+#include "fastboot_lock_unlock.h"
+#endif
+
+#ifdef CONFIG_IMX_TRUSTY_OS
+#include "u-boot/sha256.h"
+#include <trusty/libtipc.h>
+#endif
+
+
+#ifndef TRUSTY_OS_MMC_BLKS
+#define TRUSTY_OS_MMC_BLKS 0x7FF
+#endif
+
+#define MEK_8QM_EMMC 0
+
+enum {
+	PTN_GPT_INDEX = 0,
+	PTN_TEE_INDEX,
+#ifdef CONFIG_FLASH_MCUFIRMWARE_SUPPORT
+	PTN_MCU_OS_INDEX,
+#endif
+	PTN_ALL_INDEX,
+	PTN_BOOTLOADER_INDEX,
+};
+
+struct fastboot_ptentry g_ptable[MAX_PTN];
+unsigned int g_pcount;
+
+static ulong bootloader_mmc_offset(void)
+{
+	if (is_imx8mq() || is_imx8mm() || ((is_imx8qm() || is_imx8qxp()) && is_soc_rev(CHIP_REV_A)))
+		return 0x8400;
+	else if (is_imx8qm() || (is_imx8qxp() && !is_soc_rev(CHIP_REV_B))) {
+		if (MEK_8QM_EMMC == fastboot_devinfo.dev_id)
+		/* target device is eMMC boot0 partition, bootloader offset is 0x0 */
+			return 0x0;
+		else
+		/* target device is SD card, bootloader offset is 0x8000 */
+			return 0x8000;
+	} else if (is_imx8mn() || is_imx8mp()) {
+		/* target device is eMMC boot0 partition, bootloader offset is 0x0 */
+		if (env_get_ulong("emmc_dev", 10, 2) == fastboot_devinfo.dev_id)
+			return 0;
+		else
+			return 0x8000;
+	}
+	else if (is_imx8())
+		return 0x8000;
+	else
+		return 0x400;
+}
+
+bool bootloader_gpt_overlay(void)
+{
+	return (g_ptable[PTN_GPT_INDEX].partition_id  == g_ptable[PTN_BOOTLOADER_INDEX].partition_id  &&
+		bootloader_mmc_offset() < ANDROID_GPT_END);
+}
+
+/**
+   @mmc_dos_partition_index: the partition index in mbr.
+   @mmc_partition_index: the boot partition or user partition index,
+   not related to the partition table.
+ */
+static int _fastboot_parts_add_ptable_entry(int ptable_index,
+				      int mmc_dos_partition_index,
+				      int mmc_partition_index,
+				      const char *name,
+				      const char *fstype,
+				      struct blk_desc *dev_desc,
+				      struct fastboot_ptentry *ptable)
+{
+	struct disk_partition info;
+
+	if (part_get_info(dev_desc,
+			       mmc_dos_partition_index, &info)) {
+		debug("Bad partition index:%d for partition:%s\n",
+		       mmc_dos_partition_index, name);
+		return -1;
+	}
+	ptable[ptable_index].start = info.start;
+	ptable[ptable_index].length = info.size;
+	ptable[ptable_index].partition_id = mmc_partition_index;
+	ptable[ptable_index].partition_index = mmc_dos_partition_index;
+	strncpy(ptable[ptable_index].name, (const char *)info.name,
+			sizeof(ptable[ptable_index].name) - 1);
+
+#ifdef CONFIG_PARTITION_UUIDS
+	strcpy(ptable[ptable_index].uuid, (const char *)info.uuid);
+#endif
+#ifdef CONFIG_ANDROID_AB_SUPPORT
+	if (!strcmp((const char *)info.name, FASTBOOT_PARTITION_SYSTEM_A) ||
+	    !strcmp((const char *)info.name, FASTBOOT_PARTITION_SYSTEM_B) ||
+	    !strcmp((const char *)info.name, FASTBOOT_PARTITION_OEM_A) ||
+	    !strcmp((const char *)info.name, FASTBOOT_PARTITION_VENDOR_A) ||
+	    !strcmp((const char *)info.name, FASTBOOT_PARTITION_OEM_B) ||
+	    !strcmp((const char *)info.name, FASTBOOT_PARTITION_VENDOR_B) ||
+	    !strcmp((const char *)info.name, FASTBOOT_PARTITION_DATA) ||
+#else
+	if (!strcmp((const char *)info.name, FASTBOOT_PARTITION_SYSTEM) ||
+	    !strcmp((const char *)info.name, FASTBOOT_PARTITION_DATA) ||
+	    !strcmp((const char *)info.name, FASTBOOT_PARTITION_DEVICE) ||
+	    !strcmp((const char *)info.name, FASTBOOT_PARTITION_CACHE) ||
+#endif
+	    !strcmp((const char *)info.name, FASTBOOT_PARTITION_METADATA))
+		strcpy(ptable[ptable_index].fstype, "ext4");
+	else
+		strcpy(ptable[ptable_index].fstype, "raw");
+	return 0;
+}
+
+static int _fastboot_parts_load_from_ptable(void)
+{
+	int i;
+
+	/* mmc boot partition: -1 means no partition, 0 user part., 1 boot part.
+	 * default is no partition, for emmc default user part, except emmc*/
+	int boot_partition = FASTBOOT_MMC_NONE_PARTITION_ID;
+	int user_partition = FASTBOOT_MMC_NONE_PARTITION_ID;
+
+	struct mmc *mmc;
+	struct blk_desc *dev_desc;
+	struct fastboot_ptentry ptable[MAX_PTN];
+
+	/* sata case in env */
+	if (fastboot_devinfo.type == DEV_SATA) {
+#ifdef CONFIG_DM_SCSI
+		int sata_device_no = fastboot_devinfo.dev_id;
+		puts("flash target is SATA\n");
+		scsi_scan(false);
+		dev_desc = blk_get_dev("scsi", sata_device_no);
+#else /*! CONFIG_SATA*/
+		puts("SATA isn't buildin\n");
+		return -1;
+#endif /*! CONFIG_SATA*/
+	} else if (fastboot_devinfo.type == DEV_MMC) {
+		int mmc_no = fastboot_devinfo.dev_id;
+
+		printf("flash target is MMC:%d\n", mmc_no);
+		mmc = find_mmc_device(mmc_no);
+
+		if (mmc == NULL) {
+			printf("invalid mmc device %d\n", mmc_no);
+			return -1;
+		}
+
+		/* Force to init mmc */
+		mmc->has_init = 0;
+		if (mmc_init(mmc))
+			printf("MMC card init failed!\n");
+
+		dev_desc = blk_get_dev("mmc", mmc_no);
+		if (!dev_desc || dev_desc->type == DEV_TYPE_UNKNOWN) {
+			printf("** Block device MMC %d not supported\n",
+				mmc_no);
+			return -1;
+		}
+
+		/* multiple boot paritions for eMMC 4.3 later */
+		if (mmc->part_config != MMCPART_NOAVAILABLE) {
+			boot_partition = FASTBOOT_MMC_BOOT_PARTITION_ID;
+			user_partition = FASTBOOT_MMC_USER_PARTITION_ID;
+		}
+	} else {
+		printf("Can't setup partition table on this device %d\n",
+			fastboot_devinfo.type);
+		return -1;
+	}
+
+	memset((char *)ptable, 0,
+		    sizeof(struct fastboot_ptentry) * (MAX_PTN));
+	/* GPT */
+	strcpy(ptable[PTN_GPT_INDEX].name, FASTBOOT_PARTITION_GPT);
+	ptable[PTN_GPT_INDEX].start = ANDROID_GPT_OFFSET / dev_desc->blksz;
+	ptable[PTN_GPT_INDEX].length = ANDROID_GPT_SIZE  / dev_desc->blksz;
+	ptable[PTN_GPT_INDEX].partition_id = user_partition;
+	ptable[PTN_GPT_INDEX].flags = FASTBOOT_PTENTRY_FLAGS_UNERASEABLE;
+	strcpy(ptable[PTN_GPT_INDEX].fstype, "raw");
+
+#ifndef CONFIG_ARM64
+	/* Trusty OS */
+	strcpy(ptable[PTN_TEE_INDEX].name, FASTBOOT_PARTITION_TEE);
+	ptable[PTN_TEE_INDEX].start = 0;
+	ptable[PTN_TEE_INDEX].length = TRUSTY_OS_MMC_BLKS;
+	ptable[PTN_TEE_INDEX].partition_id = TEE_HWPARTITION_ID;
+	strcpy(ptable[PTN_TEE_INDEX].fstype, "raw");
+#endif
+
+	/* Add mcu_os partition if we support mcu firmware image flash */
+#ifdef CONFIG_FLASH_MCUFIRMWARE_SUPPORT
+	strcpy(ptable[PTN_MCU_OS_INDEX].name, FASTBOOT_MCU_FIRMWARE_PARTITION);
+	ptable[PTN_MCU_OS_INDEX].start = ANDROID_MCU_FIRMWARE_START / dev_desc->blksz;
+	ptable[PTN_MCU_OS_INDEX].length = ANDROID_MCU_FIRMWARE_SIZE / dev_desc->blksz;
+	ptable[PTN_MCU_OS_INDEX].flags = FASTBOOT_PTENTRY_FLAGS_UNERASEABLE;
+	ptable[PTN_MCU_OS_INDEX].partition_id = user_partition;
+	strcpy(ptable[PTN_MCU_OS_INDEX].fstype, "raw");
+#endif
+
+	strcpy(ptable[PTN_ALL_INDEX].name, FASTBOOT_PARTITION_ALL);
+	ptable[PTN_ALL_INDEX].start = 0;
+	ptable[PTN_ALL_INDEX].length = dev_desc->lba;
+	ptable[PTN_ALL_INDEX].partition_id = user_partition;
+	strcpy(ptable[PTN_ALL_INDEX].fstype, "device");
+
+	/* Bootloader */
+	strcpy(ptable[PTN_BOOTLOADER_INDEX].name, FASTBOOT_PARTITION_BOOTLOADER);
+	ptable[PTN_BOOTLOADER_INDEX].start =
+				bootloader_mmc_offset() / dev_desc->blksz;
+	ptable[PTN_BOOTLOADER_INDEX].length =
+				 ANDROID_BOOTLOADER_SIZE / dev_desc->blksz;
+	ptable[PTN_BOOTLOADER_INDEX].partition_id = boot_partition;
+	ptable[PTN_BOOTLOADER_INDEX].flags = FASTBOOT_PTENTRY_FLAGS_UNERASEABLE;
+	strcpy(ptable[PTN_BOOTLOADER_INDEX].fstype, "raw");
+
+	int tbl_idx;
+	int part_idx = 1;
+	int ret;
+	for (tbl_idx = PTN_BOOTLOADER_INDEX + 1; tbl_idx < MAX_PTN; tbl_idx++) {
+		ret = _fastboot_parts_add_ptable_entry(tbl_idx,
+				part_idx++,
+				user_partition,
+				NULL,
+				NULL,
+				dev_desc, ptable);
+		if (ret)
+			break;
+	}
+	for (i = 0; i < tbl_idx; i++)
+		fastboot_flash_add_ptn(&ptable[i]);
+
+	return 0;
+}
+
+void fastboot_load_partitions(void)
+{
+	g_pcount = 0;
+	_fastboot_parts_load_from_ptable();
+}
+
+/*
+ * Android style flash utilties */
+void fastboot_flash_add_ptn(struct fastboot_ptentry *ptn)
+{
+	if (g_pcount < MAX_PTN) {
+		memcpy(g_ptable + g_pcount, ptn, sizeof(struct fastboot_ptentry));
+		g_pcount++;
+	}
+}
+
+void fastboot_flash_dump_ptn(void)
+{
+	unsigned int n;
+	for (n = 0; n < g_pcount; n++) {
+		struct fastboot_ptentry *ptn = g_ptable + n;
+		printf("idx %d, ptn %d name='%s' start=%d len=%ld\n",
+			n, ptn->partition_index, ptn->name, ptn->start, ptn->length);
+	}
+}
+
+
+struct fastboot_ptentry *fastboot_flash_find_ptn(const char *name)
+{
+	unsigned int n;
+
+	for (n = 0; n < g_pcount; n++) {
+		/* Make sure a substring is not accepted */
+		if (strlen(name) == strlen(g_ptable[n].name)) {
+			if (0 == strcmp(g_ptable[n].name, name))
+				return g_ptable + n;
+		}
+	}
+
+	return 0;
+}
+
+int fastboot_flash_find_index(const char *name)
+{
+	struct fastboot_ptentry *ptentry = fastboot_flash_find_ptn(name);
+	if (ptentry == NULL) {
+		printf("cannot get the partion info for %s\n",name);
+		fastboot_flash_dump_ptn();
+		return -1;
+	}
+	return ptentry->partition_index;
+}
+
+struct fastboot_ptentry *fastboot_flash_get_ptn(unsigned int n)
+{
+	if (n < g_pcount)
+		return g_ptable + n;
+	else
+		return 0;
+}
+
+unsigned int fastboot_flash_get_ptn_count(void)
+{
+	return g_pcount;
+}
+
+bool fastboot_parts_is_raw(struct fastboot_ptentry *ptn)
+{
+	if (ptn) {
+		if (!strncmp(ptn->name, FASTBOOT_PARTITION_BOOTLOADER,
+			strlen(FASTBOOT_PARTITION_BOOTLOADER)))
+			return true;
+#ifdef CONFIG_ANDROID_AB_SUPPORT
+		else if (!strncmp(ptn->name, FASTBOOT_PARTITION_GPT,
+			strlen(FASTBOOT_PARTITION_GPT)) ||
+			!strncmp(ptn->name, FASTBOOT_PARTITION_BOOT_A,
+			strlen(FASTBOOT_PARTITION_BOOT_A)) ||
+			!strncmp(ptn->name, FASTBOOT_PARTITION_BOOT_B,
+			strlen(FASTBOOT_PARTITION_BOOT_B)))
+			return true;
+#else
+		else if (!strncmp(ptn->name, FASTBOOT_PARTITION_BOOT,
+			strlen(FASTBOOT_PARTITION_BOOT)))
+			return true;
+#endif
+#if defined(CONFIG_FASTBOOT_LOCK)
+		else if (!strncmp(ptn->name, FASTBOOT_PARTITION_FBMISC,
+			strlen(FASTBOOT_PARTITION_FBMISC)))
+			return true;
+#endif
+		else if (!strncmp(ptn->name, FASTBOOT_PARTITION_MISC,
+			strlen(FASTBOOT_PARTITION_MISC)))
+			return true;
+	}
+
+	 return false;
+}
+
+static bool is_exist(char (*partition_base_name)[20], char *buffer, int count)
+{
+	int n;
+
+	for (n = 0; n < count; n++) {
+		if (!strcmp(partition_base_name[n],buffer))
+			return true;
+	}
+	return false;
+}
+
+/*get partition base name from gpt without "_a/_b"*/
+int fastboot_parts_get_name(char (*partition_base_name)[20])
+{
+	int n = 0;
+	int count = 0;
+	char *ptr1, *ptr2;
+	char buffer[20];
+
+	for (n = 0; n < g_pcount; n++) {
+		strcpy(buffer,g_ptable[n].name);
+		ptr1 = strstr(buffer, "_a");
+		ptr2 = strstr(buffer, "_b");
+		if (ptr1 != NULL) {
+			*ptr1 = '\0';
+			if (!is_exist(partition_base_name,buffer,count)) {
+				strcpy(partition_base_name[count++],buffer);
+			}
+		} else if (ptr2 != NULL) {
+			*ptr2 = '\0';
+			if (!is_exist(partition_base_name,buffer,count)) {
+				strcpy(partition_base_name[count++],buffer);
+			}
+		} else {
+			strcpy(partition_base_name[count++],buffer);
+		}
+	}
+	return count;
+}
+
+bool fastboot_parts_is_slot(void)
+{
+	char slot_suffix[2][5] = {"_a","_b"};
+	int n;
+
+	for (n = 0; n < g_pcount; n++) {
+		if (strstr(g_ptable[n].name, slot_suffix[0]) ||
+		strstr(g_ptable[n].name, slot_suffix[1]))
+			return true;
+	}
+	return false;
+}
+
diff --git a/drivers/fastboot/fb_fsl_partitions.c b/drivers/fastboot/fb_fsl_partitions.c
new file mode 100644
index 0000000000..342b56d735
--- /dev/null
+++ b/drivers/fastboot/fb_fsl_partitions.c
@@ -0,0 +1,408 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2019-2020 NXP
+ */
+
+#include <asm/mach-imx/sys_proto.h>
+#include <fb_fsl.h>
+#include <fastboot.h>
+#include <mmc.h>
+#include <android_image.h>
+#include <asm/bootm.h>
+#include <nand.h>
+#include <part.h>
+#include <sparse_format.h>
+#include <image-sparse.h>
+#include <image.h>
+#include <asm/mach-imx/boot_mode.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/setup.h>
+#include <env.h>
+#ifdef CONFIG_DM_SCSI
+#include <scsi.h>
+#endif
+
+#if defined(CONFIG_FASTBOOT_LOCK)
+#include "fastboot_lock_unlock.h"
+#endif
+
+#ifdef CONFIG_IMX_TRUSTY_OS
+#include "u-boot/sha256.h"
+#include <trusty/libtipc.h>
+#endif
+
+
+#ifndef TRUSTY_OS_MMC_BLKS
+#define TRUSTY_OS_MMC_BLKS 0x7FF
+#endif
+
+#define MEK_8QM_EMMC 0
+
+enum {
+	PTN_GPT_INDEX = 0,
+	PTN_TEE_INDEX,
+#ifdef CONFIG_FLASH_MCUFIRMWARE_SUPPORT
+	PTN_MCU_OS_INDEX,
+#endif
+	PTN_ALL_INDEX,
+	PTN_BOOTLOADER_INDEX,
+};
+
+struct fastboot_ptentry g_ptable[MAX_PTN];
+unsigned int g_pcount;
+
+static ulong bootloader_mmc_offset(void)
+{
+	if (is_imx8mq() || is_imx8mm() || ((is_imx8qm() || is_imx8qxp()) && is_soc_rev(CHIP_REV_A)))
+		return 0x8400;
+	else if (is_imx8qm() || (is_imx8qxp() && !is_soc_rev(CHIP_REV_B))) {
+		if (MEK_8QM_EMMC == fastboot_devinfo.dev_id)
+		/* target device is eMMC boot0 partition, bootloader offset is 0x0 */
+			return 0x0;
+		else
+		/* target device is SD card, bootloader offset is 0x8000 */
+			return 0x8000;
+	} else if (is_imx8mn() || is_imx8mp() {
+		/* target device is eMMC boot0 partition, bootloader offset is 0x0 */
+		if (env_get_ulong("emmc_dev", 10, 2) == fastboot_devinfo.dev_id)
+			return 0;
+		else
+			return 0x8000;
+	}
+	else if (is_imx8())
+		return 0x8000;
+	else
+		return 0x400;
+}
+
+bool bootloader_gpt_overlay(void)
+{
+	return (g_ptable[PTN_GPT_INDEX].partition_id  == g_ptable[PTN_BOOTLOADER_INDEX].partition_id  &&
+		bootloader_mmc_offset() < ANDROID_GPT_END);
+}
+
+/**
+   @mmc_dos_partition_index: the partition index in mbr.
+   @mmc_partition_index: the boot partition or user partition index,
+   not related to the partition table.
+ */
+static int _fastboot_parts_add_ptable_entry(int ptable_index,
+				      int mmc_dos_partition_index,
+				      int mmc_partition_index,
+				      const char *name,
+				      const char *fstype,
+				      struct blk_desc *dev_desc,
+				      struct fastboot_ptentry *ptable)
+{
+	struct disk_partition info;
+
+	if (part_get_info(dev_desc,
+			       mmc_dos_partition_index, &info)) {
+		debug("Bad partition index:%d for partition:%s\n",
+		       mmc_dos_partition_index, name);
+		return -1;
+	}
+	ptable[ptable_index].start = info.start;
+	ptable[ptable_index].length = info.size;
+	ptable[ptable_index].partition_id = mmc_partition_index;
+	ptable[ptable_index].partition_index = mmc_dos_partition_index;
+	strncpy(ptable[ptable_index].name, (const char *)info.name,
+			sizeof(ptable[ptable_index].name) - 1);
+
+#ifdef CONFIG_PARTITION_UUIDS
+	strcpy(ptable[ptable_index].uuid, (const char *)info.uuid);
+#endif
+#ifdef CONFIG_ANDROID_AB_SUPPORT
+	if (!strcmp((const char *)info.name, FASTBOOT_PARTITION_SYSTEM_A) ||
+	    !strcmp((const char *)info.name, FASTBOOT_PARTITION_SYSTEM_B) ||
+	    !strcmp((const char *)info.name, FASTBOOT_PARTITION_OEM_A) ||
+	    !strcmp((const char *)info.name, FASTBOOT_PARTITION_VENDOR_A) ||
+	    !strcmp((const char *)info.name, FASTBOOT_PARTITION_OEM_B) ||
+	    !strcmp((const char *)info.name, FASTBOOT_PARTITION_VENDOR_B) ||
+	    !strcmp((const char *)info.name, FASTBOOT_PARTITION_DATA) ||
+#else
+	if (!strcmp((const char *)info.name, FASTBOOT_PARTITION_SYSTEM) ||
+	    !strcmp((const char *)info.name, FASTBOOT_PARTITION_DATA) ||
+	    !strcmp((const char *)info.name, FASTBOOT_PARTITION_DEVICE) ||
+	    !strcmp((const char *)info.name, FASTBOOT_PARTITION_CACHE) ||
+#endif
+	    !strcmp((const char *)info.name, FASTBOOT_PARTITION_METADATA))
+		strcpy(ptable[ptable_index].fstype, "ext4");
+	else
+		strcpy(ptable[ptable_index].fstype, "raw");
+	return 0;
+}
+
+static int _fastboot_parts_load_from_ptable(void)
+{
+	int i;
+
+	/* mmc boot partition: -1 means no partition, 0 user part., 1 boot part.
+	 * default is no partition, for emmc default user part, except emmc*/
+	int boot_partition = FASTBOOT_MMC_NONE_PARTITION_ID;
+	int user_partition = FASTBOOT_MMC_NONE_PARTITION_ID;
+
+	struct mmc *mmc;
+	struct blk_desc *dev_desc;
+	struct fastboot_ptentry ptable[MAX_PTN];
+
+	/* sata case in env */
+	if (fastboot_devinfo.type == DEV_SATA) {
+#ifdef CONFIG_DM_SCSI
+		int sata_device_no = fastboot_devinfo.dev_id;
+		puts("flash target is SATA\n");
+		scsi_scan(false);
+		dev_desc = blk_get_dev("scsi", sata_device_no);
+#else /*! CONFIG_SATA*/
+		puts("SATA isn't buildin\n");
+		return -1;
+#endif /*! CONFIG_SATA*/
+	} else if (fastboot_devinfo.type == DEV_MMC) {
+		int mmc_no = fastboot_devinfo.dev_id;
+
+		printf("flash target is MMC:%d\n", mmc_no);
+		mmc = find_mmc_device(mmc_no);
+
+		if (mmc == NULL) {
+			printf("invalid mmc device %d\n", mmc_no);
+			return -1;
+		}
+
+		/* Force to init mmc */
+		mmc->has_init = 0;
+		if (mmc_init(mmc))
+			printf("MMC card init failed!\n");
+
+		dev_desc = blk_get_dev("mmc", mmc_no);
+		if (!dev_desc || dev_desc->type == DEV_TYPE_UNKNOWN) {
+			printf("** Block device MMC %d not supported\n",
+				mmc_no);
+			return -1;
+		}
+
+		/* multiple boot paritions for eMMC 4.3 later */
+		if (mmc->part_config != MMCPART_NOAVAILABLE) {
+			boot_partition = FASTBOOT_MMC_BOOT_PARTITION_ID;
+			user_partition = FASTBOOT_MMC_USER_PARTITION_ID;
+		}
+	} else {
+		printf("Can't setup partition table on this device %d\n",
+			fastboot_devinfo.type);
+		return -1;
+	}
+
+	memset((char *)ptable, 0,
+		    sizeof(struct fastboot_ptentry) * (MAX_PTN));
+	/* GPT */
+	strcpy(ptable[PTN_GPT_INDEX].name, FASTBOOT_PARTITION_GPT);
+	ptable[PTN_GPT_INDEX].start = ANDROID_GPT_OFFSET / dev_desc->blksz;
+	ptable[PTN_GPT_INDEX].length = ANDROID_GPT_SIZE  / dev_desc->blksz;
+	ptable[PTN_GPT_INDEX].partition_id = user_partition;
+	ptable[PTN_GPT_INDEX].flags = FASTBOOT_PTENTRY_FLAGS_UNERASEABLE;
+	strcpy(ptable[PTN_GPT_INDEX].fstype, "raw");
+
+#ifndef CONFIG_ARM64
+	/* Trusty OS */
+	strcpy(ptable[PTN_TEE_INDEX].name, FASTBOOT_PARTITION_TEE);
+	ptable[PTN_TEE_INDEX].start = 0;
+	ptable[PTN_TEE_INDEX].length = TRUSTY_OS_MMC_BLKS;
+	ptable[PTN_TEE_INDEX].partition_id = TEE_HWPARTITION_ID;
+	strcpy(ptable[PTN_TEE_INDEX].fstype, "raw");
+#endif
+
+	/* Add mcu_os partition if we support mcu firmware image flash */
+#ifdef CONFIG_FLASH_MCUFIRMWARE_SUPPORT
+	strcpy(ptable[PTN_MCU_OS_INDEX].name, FASTBOOT_MCU_FIRMWARE_PARTITION);
+	ptable[PTN_MCU_OS_INDEX].start = ANDROID_MCU_FIRMWARE_START / dev_desc->blksz;
+	ptable[PTN_MCU_OS_INDEX].length = ANDROID_MCU_FIRMWARE_SIZE / dev_desc->blksz;
+	ptable[PTN_MCU_OS_INDEX].flags = FASTBOOT_PTENTRY_FLAGS_UNERASEABLE;
+	ptable[PTN_MCU_OS_INDEX].partition_id = user_partition;
+	strcpy(ptable[PTN_MCU_OS_INDEX].fstype, "raw");
+#endif
+
+	strcpy(ptable[PTN_ALL_INDEX].name, FASTBOOT_PARTITION_ALL);
+	ptable[PTN_ALL_INDEX].start = 0;
+	ptable[PTN_ALL_INDEX].length = dev_desc->lba;
+	ptable[PTN_ALL_INDEX].partition_id = user_partition;
+	strcpy(ptable[PTN_ALL_INDEX].fstype, "device");
+
+	/* Bootloader */
+	strcpy(ptable[PTN_BOOTLOADER_INDEX].name, FASTBOOT_PARTITION_BOOTLOADER);
+	ptable[PTN_BOOTLOADER_INDEX].start =
+				bootloader_mmc_offset() / dev_desc->blksz;
+	ptable[PTN_BOOTLOADER_INDEX].length =
+				 ANDROID_BOOTLOADER_SIZE / dev_desc->blksz;
+	ptable[PTN_BOOTLOADER_INDEX].partition_id = boot_partition;
+	ptable[PTN_BOOTLOADER_INDEX].flags = FASTBOOT_PTENTRY_FLAGS_UNERASEABLE;
+	strcpy(ptable[PTN_BOOTLOADER_INDEX].fstype, "raw");
+
+	int tbl_idx;
+	int part_idx = 1;
+	int ret;
+	for (tbl_idx = PTN_BOOTLOADER_INDEX + 1; tbl_idx < MAX_PTN; tbl_idx++) {
+		ret = _fastboot_parts_add_ptable_entry(tbl_idx,
+				part_idx++,
+				user_partition,
+				NULL,
+				NULL,
+				dev_desc, ptable);
+		if (ret)
+			break;
+	}
+	for (i = 0; i < tbl_idx; i++)
+		fastboot_flash_add_ptn(&ptable[i]);
+
+	return 0;
+}
+
+void fastboot_load_partitions(void)
+{
+	g_pcount = 0;
+	_fastboot_parts_load_from_ptable();
+}
+
+/*
+ * Android style flash utilties */
+void fastboot_flash_add_ptn(struct fastboot_ptentry *ptn)
+{
+	if (g_pcount < MAX_PTN) {
+		memcpy(g_ptable + g_pcount, ptn, sizeof(struct fastboot_ptentry));
+		g_pcount++;
+	}
+}
+
+void fastboot_flash_dump_ptn(void)
+{
+	unsigned int n;
+	for (n = 0; n < g_pcount; n++) {
+		struct fastboot_ptentry *ptn = g_ptable + n;
+		printf("idx %d, ptn %d name='%s' start=%d len=%ld\n",
+			n, ptn->partition_index, ptn->name, ptn->start, ptn->length);
+	}
+}
+
+
+struct fastboot_ptentry *fastboot_flash_find_ptn(const char *name)
+{
+	unsigned int n;
+
+	for (n = 0; n < g_pcount; n++) {
+		/* Make sure a substring is not accepted */
+		if (strlen(name) == strlen(g_ptable[n].name)) {
+			if (0 == strcmp(g_ptable[n].name, name))
+				return g_ptable + n;
+		}
+	}
+
+	return 0;
+}
+
+int fastboot_flash_find_index(const char *name)
+{
+	struct fastboot_ptentry *ptentry = fastboot_flash_find_ptn(name);
+	if (ptentry == NULL) {
+		printf("cannot get the partion info for %s\n",name);
+		fastboot_flash_dump_ptn();
+		return -1;
+	}
+	return ptentry->partition_index;
+}
+
+struct fastboot_ptentry *fastboot_flash_get_ptn(unsigned int n)
+{
+	if (n < g_pcount)
+		return g_ptable + n;
+	else
+		return 0;
+}
+
+unsigned int fastboot_flash_get_ptn_count(void)
+{
+	return g_pcount;
+}
+
+bool fastboot_parts_is_raw(struct fastboot_ptentry *ptn)
+{
+	if (ptn) {
+		if (!strncmp(ptn->name, FASTBOOT_PARTITION_BOOTLOADER,
+			strlen(FASTBOOT_PARTITION_BOOTLOADER)))
+			return true;
+#ifdef CONFIG_ANDROID_AB_SUPPORT
+		else if (!strncmp(ptn->name, FASTBOOT_PARTITION_GPT,
+			strlen(FASTBOOT_PARTITION_GPT)) ||
+			!strncmp(ptn->name, FASTBOOT_PARTITION_BOOT_A,
+			strlen(FASTBOOT_PARTITION_BOOT_A)) ||
+			!strncmp(ptn->name, FASTBOOT_PARTITION_BOOT_B,
+			strlen(FASTBOOT_PARTITION_BOOT_B)))
+			return true;
+#else
+		else if (!strncmp(ptn->name, FASTBOOT_PARTITION_BOOT,
+			strlen(FASTBOOT_PARTITION_BOOT)))
+			return true;
+#endif
+#if defined(CONFIG_FASTBOOT_LOCK)
+		else if (!strncmp(ptn->name, FASTBOOT_PARTITION_FBMISC,
+			strlen(FASTBOOT_PARTITION_FBMISC)))
+			return true;
+#endif
+		else if (!strncmp(ptn->name, FASTBOOT_PARTITION_MISC,
+			strlen(FASTBOOT_PARTITION_MISC)))
+			return true;
+	}
+
+	 return false;
+}
+
+static bool is_exist(char (*partition_base_name)[20], char *buffer, int count)
+{
+	int n;
+
+	for (n = 0; n < count; n++) {
+		if (!strcmp(partition_base_name[n],buffer))
+			return true;
+	}
+	return false;
+}
+
+/*get partition base name from gpt without "_a/_b"*/
+int fastboot_parts_get_name(char (*partition_base_name)[20])
+{
+	int n = 0;
+	int count = 0;
+	char *ptr1, *ptr2;
+	char buffer[20];
+
+	for (n = 0; n < g_pcount; n++) {
+		strcpy(buffer,g_ptable[n].name);
+		ptr1 = strstr(buffer, "_a");
+		ptr2 = strstr(buffer, "_b");
+		if (ptr1 != NULL) {
+			*ptr1 = '\0';
+			if (!is_exist(partition_base_name,buffer,count)) {
+				strcpy(partition_base_name[count++],buffer);
+			}
+		} else if (ptr2 != NULL) {
+			*ptr2 = '\0';
+			if (!is_exist(partition_base_name,buffer,count)) {
+				strcpy(partition_base_name[count++],buffer);
+			}
+		} else {
+			strcpy(partition_base_name[count++],buffer);
+		}
+	}
+	return count;
+}
+
+bool fastboot_parts_is_slot(void)
+{
+	char slot_suffix[2][5] = {"_a","_b"};
+	int n;
+
+	for (n = 0; n < g_pcount; n++) {
+		if (strstr(g_ptable[n].name, slot_suffix[0]) ||
+		strstr(g_ptable[n].name, slot_suffix[1]))
+			return true;
+	}
+	return false;
+}
+
diff --git a/drivers/fastboot/fb_getvar.c b/drivers/fastboot/fb_getvar.c
index 018989dd16..fca76ec343 100644
--- a/drivers/fastboot/fb_getvar.c
+++ b/drivers/fastboot/fb_getvar.c
@@ -26,6 +26,7 @@ static void getvar_has_slot(char *var_parameter, char *response);
 #endif
 #if CONFIG_IS_ENABLED(FASTBOOT_FLASH_MMC)
 static void getvar_partition_type(char *part_name, char *response);
+static void getvar_logical_blocksize(char *var_parameter, char *response);
 #endif
 #if CONFIG_IS_ENABLED(FASTBOOT_FLASH)
 static void getvar_partition_size(char *part_name, char *response);
@@ -67,6 +68,9 @@ static const struct {
 	}, {
 		.variable = "has-slot",
 		.dispatch = getvar_has_slot
+	}, {
+		.variable = "logical-block-size",
+		.dispatch = getvar_logical_blocksize
 #endif
 #if CONFIG_IS_ENABLED(FASTBOOT_FLASH_MMC)
 	}, {
@@ -232,6 +236,23 @@ static void getvar_partition_type(char *part_name, char *response)
 			fastboot_okay(fs_get_type_name(), response);
 	}
 }
+
+static void getvar_logical_blocksize(char *var_parameter, char *response)
+{
+	u32 blksz;
+	struct blk_desc *dev_desc;
+
+	dev_desc = blk_get_dev("mmc", CONFIG_FASTBOOT_FLASH_MMC_DEV);
+
+	if (!dev_desc) {
+		pr_err("** Block device mmc %d not supported\n",
+		       CONFIG_FASTBOOT_FLASH_MMC_DEV);
+		fastboot_fail("Get logical_blocksize failed", response);
+		return;
+	}
+
+	fastboot_response("OKAY", response, "0x%08x", dev_desc->blksz);
+}
 #endif
 
 #if CONFIG_IS_ENABLED(FASTBOOT_FLASH)
diff --git a/drivers/usb/gadget/ci_udc.c b/drivers/usb/gadget/ci_udc.c
index 542684c1c3..1869965057 100644
--- a/drivers/usb/gadget/ci_udc.c
+++ b/drivers/usb/gadget/ci_udc.c
@@ -13,16 +13,27 @@
 #include <cpu_func.h>
 #include <net.h>
 #include <malloc.h>
+#include <dm.h>
+#include <dm/device_compat.h>
+#include <clk.h>
+#include <power-domain.h>
 #include <asm/byteorder.h>
 #include <asm/cache.h>
 #include <linux/delay.h>
 #include <linux/errno.h>
 #include <asm/io.h>
 #include <asm/unaligned.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/arch/clock.h>
+#include <asm/mach-imx/regs-usbphy.h>
 #include <linux/types.h>
 #include <linux/usb/ch9.h>
 #include <linux/usb/gadget.h>
+#include <linux/usb/otg.h>
+#include <dm/pinctrl.h>
 #include <usb/ci_udc.h>
+#include <usb/ehci-ci.h>
+#include <usb/usb_mx6_common.h>
 #include "../host/ehci.h"
 #include "ci_udc.h"
 
@@ -93,9 +104,18 @@ static int ci_ep_dequeue(struct usb_ep *ep, struct usb_request *req);
 static struct usb_request *
 ci_ep_alloc_request(struct usb_ep *ep, unsigned int gfp_flags);
 static void ci_ep_free_request(struct usb_ep *ep, struct usb_request *_req);
+#if CONFIG_IS_ENABLED(DM_USB_GADGET)
+static int ci_udc_gadget_start(struct usb_gadget *g,
+			       struct usb_gadget_driver *driver);
+static int ci_udc_gadget_stop(struct usb_gadget *g);
+#endif
 
 static struct usb_gadget_ops ci_udc_ops = {
 	.pullup = ci_pullup,
+#if CONFIG_IS_ENABLED(DM_USB_GADGET)
+	.udc_start		= ci_udc_gadget_start,
+	.udc_stop		= ci_udc_gadget_stop,
+#endif
 };
 
 static struct usb_ep_ops ci_ep_ops = {
@@ -869,7 +889,7 @@ void udc_irq(void)
 	}
 }
 
-int usb_gadget_handle_interrupts(int index)
+int ci_udc_handle_interrupts(void)
 {
 	u32 value;
 	struct ci_udc *udc = (struct ci_udc *)controller.ctrl->hcor;
@@ -1013,6 +1033,112 @@ static int ci_udc_probe(void)
 	return 0;
 }
 
+bool dfu_usb_get_reset(void)
+{
+	struct ci_udc *udc = (struct ci_udc *)controller.ctrl->hcor;
+
+	return !!(readl(&udc->usbsts) & STS_URI);
+}
+
+static int ci_udc_otg_phy_mode2(ulong phy_addr)
+{
+	void *__iomem phy_ctrl, *__iomem phy_status;
+	void *__iomem phy_base = (void *__iomem)phy_addr;
+	u32 val;
+
+	if (is_mx6() || is_mx7ulp() || is_imx8()) {
+		phy_ctrl = (void __iomem *)(phy_base + USBPHY_CTRL);
+		val = readl(phy_ctrl);
+		if (val & USBPHY_CTRL_OTG_ID)
+			return USB_INIT_DEVICE;
+		else
+			return USB_INIT_HOST;
+	} else if (is_mx7() || is_imx8mm() || is_imx8mn()) {
+		phy_status = (void __iomem *)(phy_base +
+					      USBNC_PHY_STATUS_OFFSET);
+		val = readl(phy_status);
+		if (val & USBNC_PHYSTATUS_ID_DIG)
+			return USB_INIT_DEVICE;
+		else
+			return USB_INIT_HOST;
+	} else {
+		return -EINVAL;
+	}
+}
+
+bool udc_irq_reset(void)
+{
+	struct ci_udc *udc = (struct ci_udc *)controller.ctrl->hcor;
+	unsigned n = readl(&udc->usbsts);
+	writel(n, &udc->usbsts);
+
+	n &= (STS_SLI | STS_URI | STS_PCI | STS_UI | STS_UEI);
+	if (n == 0)
+		return false;
+
+	if (n & STS_URI) {
+		DBG("-- reset --\n");
+		return true;
+	}
+
+	if (n & STS_SLI)
+		DBG("-- suspend --\n");
+
+	return false;
+}
+
+bool ci_udc_check_bus_active(ulong ehci_addr, ulong phy_addr, int index)
+{
+	struct usb_ehci *ehci = (struct usb_ehci *)ehci_addr;
+	struct ehci_ctrl ctrl;
+	int ret;
+	bool active = false;
+
+	ret = ehci_mx6_common_init(ehci, index);
+	if (ret)
+		return false;
+
+	if (ci_udc_otg_phy_mode2(phy_addr) != USB_INIT_DEVICE)
+		return false;
+
+	ctrl.hccr = (struct ehci_hccr *)((ulong)&ehci->caplength);
+	ctrl.hcor = (struct ehci_hcor *)((ulong)ctrl.hccr +
+			HC_LENGTH(ehci_readl(&(ctrl.hccr)->cr_capbase)));
+	controller.ctrl = &ctrl;
+
+	ret = ci_udc_probe();
+	if (ret) {
+		return false;
+	}
+
+	ci_pullup(NULL, 1);
+
+	int count = 100;
+	while (count > 0) {
+		if (udc_irq_reset()) {
+			active = true;
+			break;
+		}
+		mdelay(10);
+		count--;
+	}
+
+	ci_pullup(NULL, 0);
+
+	ci_ep_free_request(&controller.ep[0].ep, &controller.ep0_req->req);
+	free(controller.items_mem);
+	free(controller.epts);
+
+	return active;
+}
+
+
+#if !CONFIG_IS_ENABLED(DM_USB_GADGET)
+int usb_gadget_handle_interrupts(int index)
+{
+	return ci_udc_handle_interrupts();
+}
+
 int usb_gadget_register_driver(struct usb_gadget_driver *driver)
 {
 	int ret;
@@ -1066,10 +1192,280 @@ int usb_gadget_unregister_driver(struct usb_gadget_driver *driver)
 
 	return 0;
 }
+#else /* !CONFIG_IS_ENABLED(DM_USB_GADGET) */
 
-bool dfu_usb_get_reset(void)
+static int ci_udc_gadget_start(struct usb_gadget *g,
+			       struct usb_gadget_driver *driver)
 {
-	struct ci_udc *udc = (struct ci_udc *)controller.ctrl->hcor;
+	if (!driver)
+		return -EINVAL;
+	if (!driver->bind || !driver->setup || !driver->disconnect)
+		return -EINVAL;
 
-	return !!(readl(&udc->usbsts) & STS_URI);
+	controller.driver = driver;
+	return 0;
+}
+
+static int ci_udc_gadget_stop(struct usb_gadget *g)
+{
+	controller.driver = NULL;
+
+	ci_ep_free_request(&controller.ep[0].ep, &controller.ep0_req->req);
+	free(controller.items_mem);
+	free(controller.epts);
+	return 0;
 }
+
+struct ci_udc_priv_data {
+	struct ehci_ctrl ctrl;
+	struct udevice otgdev;
+	struct clk_bulk		clks;
+	int phy_off;
+	struct power_domain otg_pd;
+	struct clk phy_clk;
+	struct power_domain phy_pd;
+};
+
+int dm_usb_gadget_handle_interrupts(struct udevice *dev)
+{
+	return ci_udc_handle_interrupts();
+}
+
+static int ci_udc_phy_setup(struct udevice *dev, struct ci_udc_priv_data *priv)
+{
+	struct udevice __maybe_unused phy_dev;
+	priv->phy_off = fdtdec_lookup_phandle(gd->fdt_blob,
+					      dev_of_offset(dev),
+					      "phys");
+	if (priv->phy_off < 0)
+		return -EINVAL;
+
+	dev_set_ofnode(&phy_dev, offset_to_ofnode(priv->phy_off));
+
+#if CONFIG_IS_ENABLED(POWER_DOMAIN)
+	/* Need to power on the PHY before access it */
+	if (!power_domain_get(&phy_dev, &priv->phy_pd)) {
+		if (power_domain_on(&priv->phy_pd))
+			return -EINVAL;
+	}
+#endif
+
+#if CONFIG_IS_ENABLED(CLK)
+	int ret;
+
+	ret = clk_get_by_index(&phy_dev, 0, &priv->phy_clk);
+	if (ret) {
+		printf("Failed to get phy_clk\n");
+		return ret;
+	}
+
+	ret = clk_enable(&priv->phy_clk);
+	if (ret) {
+		printf("Failed to enable phy_clk\n");
+		return ret;
+	}
+#endif
+
+	return 0;
+}
+
+static int ci_udc_phy_shutdown(struct ci_udc_priv_data *priv)
+{
+	int ret = 0;
+
+#if CONFIG_IS_ENABLED(CLK)
+	if (priv->phy_clk.dev) {
+		ret = clk_disable(&priv->phy_clk);
+		if (ret)
+			return ret;
+
+		ret = clk_free(&priv->phy_clk);
+		if (ret)
+			return ret;
+	}
+#endif
+
+#if CONFIG_IS_ENABLED(POWER_DOMAIN)
+	ret = power_domain_off(&priv->phy_pd);
+	if (ret)
+		printf("Power down USB PHY failed! (error = %d)\n", ret);
+#endif
+	return ret;
+}
+
+static int ci_udc_otg_clk_init(struct udevice *dev,
+			       struct clk_bulk *clks)
+{
+	int ret;
+
+	ret = clk_get_bulk(dev, clks);
+	if (ret == -ENOSYS)
+		return 0;
+
+	if (ret)
+		return ret;
+
+#if CONFIG_IS_ENABLED(CLK)
+	ret = clk_enable_bulk(clks);
+	if (ret) {
+		clk_release_bulk(clks);
+		return ret;
+	}
+#endif
+
+	return 0;
+}
+
+static int ci_udc_otg_phy_mode(struct udevice *dev)
+{
+	struct ci_udc_priv_data *priv = dev_get_priv(dev);
+
+	void *__iomem phy_ctrl, *__iomem phy_status;
+	void *__iomem phy_base = (void *__iomem)devfdt_get_addr(&priv->otgdev);
+	u32 val;
+
+	if (is_mx6() || is_mx7ulp() || is_imx8()) {
+		phy_base = (void __iomem *)fdtdec_get_addr(gd->fdt_blob,
+							   priv->phy_off,
+							   "reg");
+		if ((fdt_addr_t)phy_base == FDT_ADDR_T_NONE)
+			return -EINVAL;
+
+		phy_ctrl = (void __iomem *)(phy_base + USBPHY_CTRL);
+		val = readl(phy_ctrl);
+		if (val & USBPHY_CTRL_OTG_ID)
+			return USB_INIT_DEVICE;
+		else
+			return USB_INIT_HOST;
+	} else if (is_mx7() || is_imx8mm() || is_imx8mn()) {
+		phy_status = (void __iomem *)(phy_base +
+					      USBNC_PHY_STATUS_OFFSET);
+		val = readl(phy_status);
+		if (val & USBNC_PHYSTATUS_ID_DIG)
+			return USB_INIT_DEVICE;
+		else
+			return USB_INIT_HOST;
+	} else {
+		return -EINVAL;
+	}
+}
+
+static int ci_udc_otg_ofdata_to_platdata(struct udevice *dev)
+{
+	struct ci_udc_priv_data *priv = dev_get_priv(dev);
+	int node = dev_of_offset(dev);
+	int usbotg_off;
+
+	if (usb_get_dr_mode(dev_ofnode(dev)) != USB_DR_MODE_PERIPHERAL) {
+		dev_dbg(dev, "Invalid mode\n");
+		return -ENODEV;
+	}
+
+	usbotg_off = fdtdec_lookup_phandle(gd->fdt_blob,
+					   node,
+					   "chipidea,usb");
+	if (usbotg_off < 0)
+		return -EINVAL;
+	dev_set_ofnode(&priv->otgdev, offset_to_ofnode(usbotg_off));
+	priv->otgdev.parent = dev->parent;
+
+	return 0;
+}
+
+static int ci_udc_otg_probe(struct udevice *dev)
+{
+	struct ci_udc_priv_data *priv = dev_get_priv(dev);
+	struct usb_ehci *ehci;
+	int ret;
+
+	ehci = (struct usb_ehci *)devfdt_get_addr(&priv->otgdev);
+
+	pinctrl_select_state(&priv->otgdev, "default");
+
+#if defined(CONFIG_MX6)
+	if (usb_fused((u32)ehci)) {
+		printf("USB@0x%x is fused, disable it\n", (u32)ehci);
+		return -ENODEV;
+	}
+#endif
+
+	ret = board_usb_init(dev_seq(dev), USB_INIT_DEVICE);
+	if (ret) {
+		printf("Failed to initialize board for USB\n");
+		return ret;
+	}
+
+#if CONFIG_IS_ENABLED(POWER_DOMAIN)
+	if (!power_domain_get(&priv->otgdev, &priv->otg_pd)) {
+		if (power_domain_on(&priv->otg_pd))
+			return -EINVAL;
+	}
+#endif
+
+	ret = ci_udc_phy_setup(&priv->otgdev, priv);
+	if (ret)
+		return ret;
+
+	ret = ci_udc_otg_clk_init(&priv->otgdev, &priv->clks);
+	if (ret)
+		return ret;
+
+	ret = ehci_mx6_common_init(ehci, dev_seq(dev));
+	if (ret)
+		return ret;
+
+	if (ci_udc_otg_phy_mode(dev) != USB_INIT_DEVICE)
+		return -ENODEV;
+
+	priv->ctrl.hccr = (struct ehci_hccr *)((ulong)&ehci->caplength);
+	priv->ctrl.hcor = (struct ehci_hcor *)((ulong)priv->ctrl.hccr +
+			HC_LENGTH(ehci_readl(&(priv->ctrl.hccr)->cr_capbase)));
+	controller.ctrl = &priv->ctrl;
+
+	ret = ci_udc_probe();
+	if (ret) {
+		DBG("udc probe failed, returned %d\n", ret);
+		return ret;
+	}
+
+	ret = usb_add_gadget_udc((struct device *)dev, &controller.gadget);
+
+	return ret;
+}
+
+static int ci_udc_otg_remove(struct udevice *dev)
+{
+	struct ci_udc_priv_data *priv = dev_get_priv(dev);
+
+	usb_del_gadget_udc(&controller.gadget);
+
+	clk_release_bulk(&priv->clks);
+	ci_udc_phy_shutdown(priv);
+#if CONFIG_IS_ENABLED(POWER_DOMAIN)
+	if (power_domain_off(&priv->otg_pd)) {
+		printf("Power down USB controller failed!\n");
+		return -EINVAL;
+	}
+#endif
+	board_usb_cleanup(dev_seq(dev), USB_INIT_DEVICE);
+
+	controller.ctrl = NULL;
+	return 0;
+}
+
+static const struct udevice_id ci_udc_otg_ids[] = {
+	{ .compatible = "fsl,imx27-usb-gadget" },
+	{ }
+};
+
+U_BOOT_DRIVER(ci_udc_otg) = {
+	.name	= "ci-udc-otg",
+	.id	= UCLASS_USB_GADGET_GENERIC,
+	.of_match = ci_udc_otg_ids,
+	.of_to_plat = ci_udc_otg_ofdata_to_platdata,
+	.probe = ci_udc_otg_probe,
+	.remove = ci_udc_otg_remove,
+	.priv_auto = sizeof(struct ci_udc_priv_data),
+};
+
+#endif /* !CONFIG_IS_ENABLED(DM_USB_GADGET) */
diff --git a/drivers/usb/host/ehci-mx6.c b/drivers/usb/host/ehci-mx6.c
index 060b02accc..82ae58f851 100644
--- a/drivers/usb/host/ehci-mx6.c
+++ b/drivers/usb/host/ehci-mx6.c
@@ -357,6 +357,8 @@ int ehci_hcd_init(int index, enum usb_init_type init,
 		(struct usbphy_regs __iomem *)USB_PHY0_BASE_ADDR;
 	struct usbnc_regs *usbnc = (struct usbnc_regs *)(USB_BASE_ADDR +
 			(0x10000 * index) + USBNC_OFFSET);
+#elif defined(CONFIG_IMX8M)
+	u32 controller_spacing = 0x10000;
 #endif
 	struct usb_ehci *ehci = (struct usb_ehci *)(USB_BASE_ADDR +
 		(controller_spacing * index));
@@ -390,9 +392,9 @@ int ehci_hcd_init(int index, enum usb_init_type init,
 #elif defined (CONFIG_MX7ULP)
 	usb_power_config_mx7ulp(usbphy);
 #endif
-
+#if !defined(CONFIG_PHY)
 	usb_oc_config(usbnc, index);
-
+#endif
 #if defined(CONFIG_MX6) || defined(CONFIG_MX7ULP) || defined(CONFIG_IMXRT)
 	if (index < ARRAY_SIZE(phy_bases)) {
 		usb_internal_phy_clock_gate((void __iomem *)phy_bases[index], 1);
diff --git a/drivers/usb/imx/Makefile b/drivers/usb/imx/Makefile
new file mode 100644
index 0000000000..30c06b7bf8
--- /dev/null
+++ b/drivers/usb/imx/Makefile
@@ -0,0 +1,8 @@
+# SPDX-License-Identifier: GPL-2.0+
+#
+# Copyright 2019 NXP
+#
+
+obj-$(CONFIG_USB_EHCI_MX6) += usb-mx6-common.o
+obj-$(CONFIG_USB_EHCI_MX7) += usb-mx6-common.o
+obj-$(CONFIG_CI_UDC) += usb-mx6-common.o
diff --git a/drivers/usb/imx/usb-mx6-common.c b/drivers/usb/imx/usb-mx6-common.c
new file mode 100644
index 0000000000..d2dd715eaf
--- /dev/null
+++ b/drivers/usb/imx/usb-mx6-common.c
@@ -0,0 +1,396 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (c) 2009 Daniel Mack <daniel@caiaq.de>
+ * Copyright (C) 2010 Freescale Semiconductor, Inc.
+ * Copyright 2017-2019 NXP
+ *
+ */
+
+#include <common.h>
+#include <usb.h>
+#include <errno.h>
+#include <wait_bit.h>
+#include <linux/compiler.h>
+#include <usb/ehci-ci.h>
+#include <asm/io.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/clock.h>
+#include <asm/mach-imx/iomux-v3.h>
+#include <asm/mach-imx/regs-usbphy.h>
+#include <asm/mach-imx/sys_proto.h>
+#include <asm/mach-types.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/global_data.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define USB_OTGREGS_OFFSET	0x000
+#define USB_H1REGS_OFFSET	0x200
+#define USB_H2REGS_OFFSET	0x400
+#define USB_H3REGS_OFFSET	0x600
+#define USB_OTHERREGS_OFFSET	0x800
+
+#define USB_H1_CTRL_OFFSET	0x04
+
+#define ANADIG_USB2_CHRG_DETECT_EN_B		0x00100000
+#define ANADIG_USB2_CHRG_DETECT_CHK_CHRG_B	0x00080000
+
+#define ANADIG_USB2_PLL_480_CTRL_BYPASS		0x00010000
+#define ANADIG_USB2_PLL_480_CTRL_ENABLE		0x00002000
+#define ANADIG_USB2_PLL_480_CTRL_POWER		0x00001000
+#define ANADIG_USB2_PLL_480_CTRL_EN_USB_CLKS	0x00000040
+
+#define USBNC_OFFSET		0x200
+#define USBNC_PHYCFG2_ACAENB	(1 << 4) /* otg_id detection enable */
+#define UCTRL_PWR_POL		(1 << 9) /* OTG Polarity of Power Pin */
+#define UCTRL_OVER_CUR_POL	(1 << 8) /* OTG Polarity of Overcurrent */
+#define UCTRL_OVER_CUR_DIS	(1 << 7) /* Disable OTG Overcurrent Detection */
+
+#define PLL_USB_EN_USB_CLKS_MASK	(0x01 << 6)
+#define PLL_USB_PWR_MASK		(0x01 << 12)
+#define PLL_USB_ENABLE_MASK		(0x01 << 13)
+#define PLL_USB_BYPASS_MASK		(0x01 << 16)
+#define PLL_USB_REG_ENABLE_MASK		(0x01 << 21)
+#define PLL_USB_DIV_SEL_MASK		(0x07 << 22)
+#define PLL_USB_LOCK_MASK		(0x01 << 31)
+
+/* USBCMD */
+#define UCMD_RUN_STOP           (1 << 0) /* controller run/stop */
+#define UCMD_RESET		(1 << 1) /* controller reset */
+
+#if defined(CONFIG_MX6) || defined(CONFIG_MX7ULP) || defined(CONFIG_IMX8)
+static const ulong phy_bases[] = {
+	USB_PHY0_BASE_ADDR,
+#if defined(USB_PHY1_BASE_ADDR)
+	USB_PHY1_BASE_ADDR,
+#endif
+};
+
+static void usb_internal_phy_clock_gate(int index, int on)
+{
+	void __iomem *phy_reg;
+
+	if (index >= ARRAY_SIZE(phy_bases))
+		return;
+
+	phy_reg = (void __iomem *)phy_bases[index];
+	phy_reg += on ? USBPHY_CTRL_CLR : USBPHY_CTRL_SET;
+	writel(USBPHY_CTRL_CLKGATE, phy_reg);
+}
+
+static void usb_power_config(int index)
+{
+	if (index >= ARRAY_SIZE(phy_bases))
+                return;
+
+#if defined(CONFIG_MX7ULP)
+	struct usbphy_regs __iomem *usbphy =
+		(struct usbphy_regs __iomem *)USB_PHY0_BASE_ADDR;
+
+	writel(ANADIG_USB2_CHRG_DETECT_EN_B |
+		   ANADIG_USB2_CHRG_DETECT_CHK_CHRG_B,
+		   &usbphy->usb1_chrg_detect);
+
+	scg_enable_usb_pll(true);
+
+#elif defined(CONFIG_IMX8)
+
+
+	struct usbphy_regs __iomem *usbphy = (struct usbphy_regs __iomem *)phy_bases[index];
+
+	int timeout = 1000000;
+
+	writel(ANADIG_USB2_CHRG_DETECT_EN_B |
+		   ANADIG_USB2_CHRG_DETECT_CHK_CHRG_B,
+		   &usbphy->usb1_chrg_detect);
+
+	if (!(readl(&usbphy->usb1_pll_480_ctrl) & PLL_USB_LOCK_MASK)) {
+
+		/* Enable the regulator first */
+		writel(PLL_USB_REG_ENABLE_MASK,
+		       &usbphy->usb1_pll_480_ctrl_set);
+
+		/* Wait at least 25us */
+		udelay(25);
+
+		/* Enable the power */
+		writel(PLL_USB_PWR_MASK, &usbphy->usb1_pll_480_ctrl_set);
+
+		/* Wait lock */
+		while (timeout--) {
+			if (readl(&usbphy->usb1_pll_480_ctrl) &
+			    PLL_USB_LOCK_MASK)
+				break;
+			udelay(10);
+		}
+
+		if (timeout <= 0) {
+			/* If timeout, we power down the pll */
+			writel(PLL_USB_PWR_MASK,
+			       &usbphy->usb1_pll_480_ctrl_clr);
+			return;
+		}
+	}
+
+	/* Clear the bypass */
+	writel(PLL_USB_BYPASS_MASK, &usbphy->usb1_pll_480_ctrl_clr);
+
+	/* Enable the PLL clock out to USB */
+	writel((PLL_USB_EN_USB_CLKS_MASK | PLL_USB_ENABLE_MASK),
+	       &usbphy->usb1_pll_480_ctrl_set);
+
+#else
+	struct anatop_regs __iomem *anatop =
+		(struct anatop_regs __iomem *)ANATOP_BASE_ADDR;
+	void __iomem *chrg_detect;
+	void __iomem *pll_480_ctrl_clr;
+	void __iomem *pll_480_ctrl_set;
+
+	switch (index) {
+	case 0:
+		chrg_detect = &anatop->usb1_chrg_detect;
+		pll_480_ctrl_clr = &anatop->usb1_pll_480_ctrl_clr;
+		pll_480_ctrl_set = &anatop->usb1_pll_480_ctrl_set;
+		break;
+	case 1:
+		chrg_detect = &anatop->usb2_chrg_detect;
+		pll_480_ctrl_clr = &anatop->usb2_pll_480_ctrl_clr;
+		pll_480_ctrl_set = &anatop->usb2_pll_480_ctrl_set;
+		break;
+	default:
+		return;
+	}
+	/*
+	 * Some phy and power's special controls
+	 * 1. The external charger detector needs to be disabled
+	 * or the signal at DP will be poor
+	 * 2. The PLL's power and output to usb
+	 * is totally controlled by IC, so the Software only needs
+	 * to enable them at initializtion.
+	 */
+	writel(ANADIG_USB2_CHRG_DETECT_EN_B |
+		     ANADIG_USB2_CHRG_DETECT_CHK_CHRG_B,
+		     chrg_detect);
+
+	writel(ANADIG_USB2_PLL_480_CTRL_BYPASS,
+		     pll_480_ctrl_clr);
+
+	writel(ANADIG_USB2_PLL_480_CTRL_ENABLE |
+		     ANADIG_USB2_PLL_480_CTRL_POWER |
+		     ANADIG_USB2_PLL_480_CTRL_EN_USB_CLKS,
+		     pll_480_ctrl_set);
+
+#endif
+}
+
+/* Return 0 : host node, <>0 : device mode */
+static int usb_phy_enable(int index, struct usb_ehci *ehci)
+{
+	void __iomem *phy_reg;
+	void __iomem *phy_ctrl;
+	void __iomem *usb_cmd;
+	int ret;
+
+	if (index >= ARRAY_SIZE(phy_bases))
+		return 0;
+
+	phy_reg = (void __iomem *)phy_bases[index];
+	phy_ctrl = (void __iomem *)(phy_reg + USBPHY_CTRL);
+	usb_cmd = (void __iomem *)&ehci->usbcmd;
+
+	/* Stop then Reset */
+	clrbits_le32(usb_cmd, UCMD_RUN_STOP);
+	ret = wait_for_bit_le32(usb_cmd, UCMD_RUN_STOP, false, 10000, false);
+	if (ret)
+		return ret;
+
+	setbits_le32(usb_cmd, UCMD_RESET);
+	ret = wait_for_bit_le32(usb_cmd, UCMD_RESET, false, 10000, false);
+	if (ret)
+		return ret;
+
+	/* Reset USBPHY module */
+	setbits_le32(phy_ctrl, USBPHY_CTRL_SFTRST);
+	udelay(10);
+
+	/* Remove CLKGATE and SFTRST */
+	clrbits_le32(phy_ctrl, USBPHY_CTRL_CLKGATE | USBPHY_CTRL_SFTRST);
+	udelay(10);
+
+	/* Power up the PHY */
+	writel(0, phy_reg + USBPHY_PWD);
+	/* enable FS/LS device */
+	setbits_le32(phy_ctrl, USBPHY_CTRL_ENUTMILEVEL2 |
+			USBPHY_CTRL_ENUTMILEVEL3);
+
+	return 0;
+}
+
+int usb_phy_mode(int port)
+{
+	void __iomem *phy_reg;
+	void __iomem *phy_ctrl;
+	u32 val;
+
+	if (port >= ARRAY_SIZE(phy_bases))
+		return USB_INIT_HOST;
+
+	phy_reg = (void __iomem *)phy_bases[port];
+	phy_ctrl = (void __iomem *)(phy_reg + USBPHY_CTRL);
+
+	val = readl(phy_ctrl);
+
+	if (val & USBPHY_CTRL_OTG_ID)
+		return USB_INIT_DEVICE;
+	else
+		return USB_INIT_HOST;
+}
+
+#if defined(CONFIG_MX7ULP)
+struct usbnc_regs {
+	u32 ctrl1;
+	u32 ctrl2;
+	u32 reserve0[2];
+	u32 hsic_ctrl;
+};
+#elif defined(CONFIG_IMX8)
+struct usbnc_regs {
+	u32 ctrl1;
+	u32 ctrl2;
+	u32 reserve1[10];
+	u32 phy_cfg1;
+	u32 phy_cfg2;
+	u32 reserve2;
+	u32 phy_status;
+	u32 reserve3[4];
+	u32 adp_cfg1;
+	u32 adp_cfg2;
+	u32 adp_status;
+};
+#else
+/* Base address for this IP block is 0x02184800 */
+struct usbnc_regs {
+	u32	ctrl[4];	/* otg/host1-3 */
+	u32	uh2_hsic_ctrl;
+	u32	uh3_hsic_ctrl;
+	u32	otg_phy_ctrl_0;
+	u32	uh1_phy_ctrl_0;
+};
+#endif
+
+#elif defined(CONFIG_USB_EHCI_MX7)
+struct usbnc_regs {
+	u32 ctrl1;
+	u32 ctrl2;
+	u32 reserve1[10];
+	u32 phy_cfg1;
+	u32 phy_cfg2;
+	u32 reserve2;
+	u32 phy_status;
+	u32 reserve3[4];
+	u32 adp_cfg1;
+	u32 adp_cfg2;
+	u32 adp_status;
+};
+
+static void usb_power_config(int index)
+{
+	struct usbnc_regs *usbnc = (struct usbnc_regs *)(ulong)(USB_BASE_ADDR +
+			(0x10000 * index) + USBNC_OFFSET);
+	void __iomem *phy_cfg2 = (void __iomem *)(&usbnc->phy_cfg2);
+
+	/*
+	 * Clear the ACAENB to enable usb_otg_id detection,
+	 * otherwise it is the ACA detection enabled.
+	 */
+	clrbits_le32(phy_cfg2, USBNC_PHYCFG2_ACAENB);
+}
+
+int usb_phy_mode(int port)
+{
+	struct usbnc_regs *usbnc = (struct usbnc_regs *)(ulong)(USB_BASE_ADDR +
+			(0x10000 * port) + USBNC_OFFSET);
+	void __iomem *status = (void __iomem *)(&usbnc->phy_status);
+	u32 val;
+
+	val = readl(status);
+
+	if (val & USBNC_PHYSTATUS_ID_DIG)
+		return USB_INIT_DEVICE;
+	else
+		return USB_INIT_HOST;
+}
+#endif
+
+static void usb_oc_config(int index)
+{
+#if defined(CONFIG_MX6)
+	struct usbnc_regs *usbnc = (struct usbnc_regs *)(USB_BASE_ADDR +
+			USB_OTHERREGS_OFFSET);
+	void __iomem *ctrl = (void __iomem *)(&usbnc->ctrl[index]);
+#elif defined(CONFIG_USB_EHCI_MX7) || defined(CONFIG_MX7ULP) || defined(CONFIG_IMX8)
+	struct usbnc_regs *usbnc = (struct usbnc_regs *)(ulong)(USB_BASE_ADDR +
+			(0x10000 * index) + USBNC_OFFSET);
+	void __iomem *ctrl = (void __iomem *)(&usbnc->ctrl1);
+#endif
+
+#if CONFIG_MACH_TYPE == MACH_TYPE_MX6Q_ARM2
+	/* mx6qarm2 seems to required a different setting*/
+	clrbits_le32(ctrl, UCTRL_OVER_CUR_POL);
+#else
+	setbits_le32(ctrl, UCTRL_OVER_CUR_POL);
+#endif
+
+	setbits_le32(ctrl, UCTRL_OVER_CUR_DIS);
+
+	/* Set power polarity to high active */
+#ifdef CONFIG_MXC_USB_OTG_HACTIVE
+	setbits_le32(ctrl, UCTRL_PWR_POL);
+#else
+	clrbits_le32(ctrl, UCTRL_PWR_POL);
+#endif
+}
+
+/**
+ * board_ehci_hcd_init - set usb vbus voltage
+ * @port:      usb otg port
+ *
+ * Target board specific, setup iomux pad to setup supply vbus voltage
+ * for usb otg port. Machine board file overrides board_ehci_hcd_init
+ *
+ * Return: 0 Success
+ */
+int __weak board_ehci_hcd_init(int port)
+{
+	return 0;
+}
+
+int ehci_mx6_common_init(struct usb_ehci *ehci, int index)
+{
+	int ret;
+	u32 portsc;
+
+	enable_usboh3_clk(1);
+	mdelay(1);
+
+	portsc = readl(&ehci->portsc);
+	if (portsc & PORT_PTS_PHCD) {
+		debug("suspended: portsc %x, enabled it.\n", portsc);
+		clrbits_le32(&ehci->portsc, PORT_PTS_PHCD);
+	}
+
+	/* Do board specific initialization */
+	ret = board_ehci_hcd_init(index);
+	if (ret)
+		return ret;
+
+	usb_power_config(index);
+	usb_oc_config(index);
+
+#if defined(CONFIG_MX6) || defined(CONFIG_MX7ULP) || defined(CONFIG_IMX8)
+	usb_internal_phy_clock_gate(index, 1);
+	usb_phy_enable(index, ehci);
+#endif
+
+	return 0;
+}
diff --git a/include/fb_fsl.h b/include/fb_fsl.h
new file mode 100644
index 0000000000..dece725c1b
--- /dev/null
+++ b/include/fb_fsl.h
@@ -0,0 +1,260 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2010-2016 Freescale Semiconductor, Inc.
+ * Copyright 2017-2019 NXP
+ */
+
+#ifndef FB_FSL_H
+#define FB_FSL_H
+#include <stdbool.h>
+#include <linux/types.h>
+
+#define FASTBOOT_PTENTRY_FLAGS_REPEAT(n)              (n & 0x0f)
+#define FASTBOOT_PTENTRY_FLAGS_REPEAT_MASK            0x0000000F
+
+/* Writes happen a block at a time.
+   If the write fails, go to next block
+   NEXT_GOOD_BLOCK and CONTIGOUS_BLOCK can not both be set */
+#define FASTBOOT_PTENTRY_FLAGS_WRITE_NEXT_GOOD_BLOCK  0x00000010
+
+/* Find a contiguous block big enough for a the whole file
+   NEXT_GOOD_BLOCK and CONTIGOUS_BLOCK can not both be set */
+#define FASTBOOT_PTENTRY_FLAGS_WRITE_CONTIGUOUS_BLOCK 0x00000020
+
+/* Write the file with write.i */
+#define FASTBOOT_PTENTRY_FLAGS_WRITE_I                0x00000100
+
+/* Write the file with write.trimffs */
+#define FASTBOOT_PTENTRY_FLAGS_WRITE_TRIMFFS          0x00000200
+
+/* Write the file as a series of variable/value pairs
+   using the setenv and saveenv commands */
+#define FASTBOOT_PTENTRY_FLAGS_WRITE_ENV              0x00000400
+
+/* Uneraseable partition */
+#define FASTBOOT_PTENTRY_FLAGS_UNERASEABLE            0x00000800
+
+#define FASTBOOT_MMC_BOOT_PARTITION_ID  1
+#define FASTBOOT_MMC_USER_PARTITION_ID  0
+#define FASTBOOT_MMC_NONE_PARTITION_ID -1
+#define FASTBOOT_MMC_BOOT1_PARTITION_ID  2
+
+#define FASTBOOT_PARTITION_TEE "tos"
+#define FASTBOOT_PARTITION_PRDATA "presistdata"
+
+#ifdef CONFIG_AVB_SUPPORT
+#define FASTBOOT_PARTITION_AVBKEY "avbkey"
+#endif
+
+#ifdef CONFIG_FLASH_MCUFIRMWARE_SUPPORT
+#define FASTBOOT_MCU_FIRMWARE_PARTITION "mcu_os"
+#endif
+
+#define FASTBOOT_PARTITION_METADATA "metadata"
+
+#ifdef CONFIG_ANDROID_AB_SUPPORT
+#define FASTBOOT_PARTITION_BOOT_A "boot_a"
+#define FASTBOOT_PARTITION_RECOVERY "recovery"
+#define FASTBOOT_PARTITION_SYSTEM_A "system_a"
+#define FASTBOOT_PARTITION_BOOTLOADER "bootloader0"
+#define FASTBOOT_PARTITION_DATA "userdata"
+#define FASTBOOT_PARTITION_BOOT_B "boot_b"
+#define FASTBOOT_PARTITION_SYSTEM_B "system_b"
+#define FASTBOOT_PARTITION_OEM_A "oem_a"
+#define FASTBOOT_PARTITION_VENDOR_A "vendor_a"
+#define FASTBOOT_PARTITION_OEM_B "oem_b"
+#define FASTBOOT_PARTITION_VENDOR_B "vendor_b"
+#ifdef CONFIG_AVB_SUPPORT
+#define FASTBOOT_PARTITION_VBMETA_A "vbmeta_a"
+#define FASTBOOT_PARTITION_VBMETA_B "vbmeta_b"
+#endif
+#define FASTBOOT_PARTITION_MISC "misc"
+#define FASTBOOT_PARTITION_GPT "gpt"
+#define FASTBOOT_PARTITION_FBMISC "fbmisc"
+#else
+#define FASTBOOT_PARTITION_BOOT "boot"
+#define FASTBOOT_PARTITION_RECOVERY "recovery"
+#define FASTBOOT_PARTITION_SYSTEM "system"
+#define FASTBOOT_PARTITION_CACHE "cache"
+#define FASTBOOT_PARTITION_DEVICE "device"
+#define FASTBOOT_PARTITION_BOOTLOADER "bootloader"
+#define FASTBOOT_PARTITION_DATA "userdata"
+#define FASTBOOT_PARTITION_GPT "gpt"
+#define FASTBOOT_PARTITION_MISC "misc"
+#define FASTBOOT_PARTITION_FBMISC "fbmisc"
+#endif
+
+#ifdef CONFIG_IMX_TRUSTY_OS
+#ifndef CONFIG_AVB_ATX
+#define FASTBOOT_SET_RPMB_STAGED_KEY "set-rpmb-staged-key"
+#define FASTBOOT_SET_RPMB_HARDWARE_KEY "set-rpmb-hardware-key"
+#define FASTBOOT_SET_VBMETA_PUBLIC_KEY "set-public-key"
+#define FASTBOOT_ERASE_RPMB "erase-rpmb"
+#endif
+
+#define FASTBOOT_SET_CA_RESP "at-set-ca-response"
+#define FASTBOOT_GET_CA_REQ  "at-get-ca-request"
+#define FASTBOOT_SET_RSA_ATTESTATION_KEY  "set-rsa-atte-key"
+#define FASTBOOT_SET_EC_ATTESTATION_KEY  "set-ec-atte-key"
+#define FASTBOOT_APPEND_RSA_ATTESTATION_CERT  "append-rsa-atte-cert"
+#define FASTBOOT_APPEND_EC_ATTESTATION_CERT  "append-ec-atte-cert"
+#define FASTBOOT_SET_RSA_ATTESTATION_KEY_ENC  "set-rsa-atte-key-enc"
+#define FASTBOOT_SET_EC_ATTESTATION_KEY_ENC  "set-ec-atte-key-enc"
+#define FASTBOOT_APPEND_RSA_ATTESTATION_CERT_ENC  "append-rsa-atte-cert-enc"
+#define FASTBOOT_APPEND_EC_ATTESTATION_CERT_ENC  "append-ec-atte-cert-enc"
+#define FASTBOOT_GET_MPPUBK  "get-mppubk"
+#define FASTBOOT_GET_SERIAL_NUMBER  "get-serial-number"
+#define FASTBOOT_APPEND_ATTESTATION_ID "append-device-id"
+#define FASTBOOT_WV_PROVISION	"provision-wv-keybox"
+#define FASTBOOT_WV_PROVISION_ENC	"provision-wv-keybox-enc"
+#endif
+
+#ifdef CONFIG_ANDROID_THINGS_SUPPORT
+#define FASTBOOT_BOOTLOADER_VBOOT_KEY "fuse at-bootloader-vboot-key"
+#ifdef CONFIG_AVB_ATX
+#define FASTBOOT_AVB_AT_PERM_ATTR "fuse at-perm-attr"
+#define FASTBOOT_AT_UNLOCK_VBOOT "at-unlock-vboot"
+#define FASTBOOT_AT_LOCK_VBOOT "at-lock-vboot"
+#define FASTBOOT_AT_DISABLE_UNLOCK_VBOOT "at-disable-unlock-vboot"
+#define FASTBOOT_AT_GET_UNLOCK_CHALLENGE "at-get-vboot-unlock-challenge"
+#endif /* CONFIG_AVB_ATX */
+#endif /* CONFIG_ANDROID_THINGS_SUPPORT */
+
+#ifndef TEE_HWPARTITION_ID
+#define TEE_HWPARTITION_ID 2
+#endif
+
+#define FASTBOOT_PARTITION_ALL "all"
+
+#define MMC_SATA_BLOCK_SIZE 512
+
+#define ANDROID_MBR_OFFSET	    0
+#define ANDROID_MBR_SIZE	    0x200
+#define ANDROID_BOOTLOADER_SIZE	    0x400000
+
+#define ANDROID_GPT_OFFSET         0
+#define ANDROID_GPT_SIZE           0x100000
+#define ANDROID_GPT_END	           0x4400
+
+/* To support the Android-style naming of flash */
+#define MAX_PTN		    32
+
+enum {
+    DEV_SATA,
+    DEV_MMC,
+    DEV_NAND,
+#ifdef CONFIG_FLASH_MCUFIRMWARE_SUPPORT
+    /* SPI Flash */
+    DEV_SF
+#endif
+};
+
+typedef enum {
+#ifdef CONFIG_ANDROID_RECOVERY
+	/* Revoery boot due to combo keys pressed */
+	BOOTMODE_RECOVERY_KEY_PRESSED,
+	/* Recovery boot due to boot-recovery cmd in misc parition */
+	BOOTMODE_RECOVERY_BCB_CMD,
+#endif
+	/* Fastboot boot due to bootonce-bootloader cmd in misc parition */
+	BOOTMODE_FASTBOOT_BCB_CMD,
+	/* Normal boot */
+	BOOTMODE_NORMAL
+}FbBootMode;
+
+/* flash partitions are defined in terms of blocks
+** (flash erase units)
+*/
+struct fastboot_ptentry {
+	/* The logical name for this partition, null terminated */
+	char name[20];
+	/* The start wrt the nand part, must be multiple of nand block size */
+	unsigned int start;
+	/* The length of the partition, must be multiple of nand block size */
+	unsigned long length;
+	/* Controls the details of how operations are done on the partition
+	   See the FASTBOOT_PTENTRY_FLAGS_*'s defined below */
+	unsigned int flags;
+	/* partition id: 0 - normal partition; 1 - boot partition */
+	unsigned int partition_id;
+	/* partition number in block device */
+	unsigned int partition_index;
+	/* partition file system type in string */
+	char fstype[16];
+	/* filesystem UUID as string, if exists */
+#ifdef CONFIG_PARTITION_UUIDS
+	char uuid[37];
+#endif
+};
+
+struct fastboot_device_info {
+	unsigned char type;
+	unsigned char dev_id;
+};
+
+extern struct fastboot_device_info fastboot_devinfo;
+
+#ifdef CONFIG_FLASH_MCUFIRMWARE_SUPPORT
+extern struct fastboot_device_info fastboot_firmwareinfo;
+#endif
+
+extern struct fastboot_ptentry g_ptable[MAX_PTN];
+extern unsigned int g_pcount;
+
+/* Prepare the fastboot environments,
+  * should be executed before "fastboot" cmd
+  */
+void fastboot_setup(void);
+
+
+/* The Android-style flash handling */
+
+/* tools to populate and query the partition table */
+void fastboot_flash_add_ptn(struct fastboot_ptentry *ptn);
+struct fastboot_ptentry *fastboot_flash_find_ptn(const char *name);
+struct fastboot_ptentry *fastboot_flash_get_ptn(unsigned n);
+unsigned int fastboot_flash_get_ptn_count(void);
+void fastboot_flash_dump_ptn(void);
+
+/* Make board into special boot mode  */
+void fastboot_run_bootmode(void);
+
+/*Setup board-relative fastboot environment */
+void board_fastboot_setup(void);
+
+/*return partition index according name*/
+int fastboot_flash_find_index(const char *name);
+
+bool fastboot_parts_is_slot(void);
+
+bool fastboot_parts_is_raw(struct fastboot_ptentry *ptn);
+
+/*get partition base name from gpt without "_a/_b"*/
+int fastboot_parts_get_name(char (*partition_base_name)[20]);
+
+void fastboot_load_partitions(void);
+
+void fastboot_none_resp(char *response);
+
+void fastboot_process_erase(const char *cmdbuf, char *response);
+
+void fastboot_process_flash(const char *cmdbuf, void *download_buffer,
+			      u32 download_bytes, char *response);
+
+/*check whether bootloader is overlay with GPT table*/
+bool bootloader_gpt_overlay(void);
+/* Check whether the combo keys pressed
+ * Return 1 if combo keys pressed for recovery boot
+ * Return 0 if no combo keys pressed
+ */
+int is_recovery_key_pressing(void);
+
+/* Reads |num_bytes| from offset |offset| from partition with name
+ * |partition| (NUL-terminated UTF-8 string). If |offset| is
+ * negative, its absolute value should be interpreted as the number
+ * of bytes from the end of the partition.
+ * It's basically copied from fsl_read_from_partition_multi() because
+ * we may want to read partition when AVB is not enabled. */
+int read_from_partition_multi(const char* partition,
+		int64_t offset, size_t num_bytes,void* buffer, size_t* out_num_read);
+#endif /* FB_FSL_H */
diff --git a/include/part.h b/include/part.h
index 53cfbdd876..34bb3b122d 100644
--- a/include/part.h
+++ b/include/part.h
@@ -418,6 +418,15 @@ int is_valid_gpt_buf(struct blk_desc *dev_desc, void *buf);
  */
 int write_mbr_and_gpt_partitions(struct blk_desc *dev_desc, void *buf);
 
+/**
+ * write_backup_gpt_partitions - write MBR, backup gpt table.
+ * @param dev_desc - block device descriptor
+ * @param buf - buffer which contains the MBR and Primary GPT info
+ *
+ * @return - '0' on success, otherwise error
+ */
+int write_backup_gpt_partitions(struct blk_desc *dev_desc, void *buf);
+
 /**
  * gpt_verify_headers() - Function to read and CRC32 check of the GPT's header
  *                        and partition table entries (PTE)
diff --git a/include/usb/usb_mx6_common.h b/include/usb/usb_mx6_common.h
new file mode 100644
index 0000000000..39751fded4
--- /dev/null
+++ b/include/usb/usb_mx6_common.h
@@ -0,0 +1,12 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2019 NXP
+ *
+ */
+
+#ifndef __USB_MX6_COMMON_H__
+#define __USB_MX6_COMMON_H__
+#include <usb/ehci-ci.h>
+
+int ehci_mx6_common_init(struct usb_ehci *ehci, int index);
+#endif /* __USB_MX6_COMMON_H__ */
